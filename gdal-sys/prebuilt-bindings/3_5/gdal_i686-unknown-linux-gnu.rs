/* automatically generated by rust-bindgen 0.70.1 */

pub type va_list = __builtin_va_list;
pub type __int64_t = ::std::ffi::c_longlong;
pub type __uint64_t = ::std::ffi::c_ulonglong;
pub type __dev_t = __uint64_t;
pub type __uid_t = ::std::ffi::c_uint;
pub type __gid_t = ::std::ffi::c_uint;
pub type __ino_t = ::std::ffi::c_ulong;
pub type __mode_t = ::std::ffi::c_uint;
pub type __nlink_t = ::std::ffi::c_uint;
pub type __off_t = ::std::ffi::c_long;
pub type __off64_t = __int64_t;
pub type __time_t = ::std::ffi::c_long;
pub type __blksize_t = ::std::ffi::c_long;
pub type __blkcnt_t = ::std::ffi::c_long;
pub type __syscall_slong_t = ::std::ffi::c_long;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::ffi::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::ffi::c_int,
    pub _IO_read_ptr: *mut ::std::ffi::c_char,
    pub _IO_read_end: *mut ::std::ffi::c_char,
    pub _IO_read_base: *mut ::std::ffi::c_char,
    pub _IO_write_base: *mut ::std::ffi::c_char,
    pub _IO_write_ptr: *mut ::std::ffi::c_char,
    pub _IO_write_end: *mut ::std::ffi::c_char,
    pub _IO_buf_base: *mut ::std::ffi::c_char,
    pub _IO_buf_end: *mut ::std::ffi::c_char,
    pub _IO_save_base: *mut ::std::ffi::c_char,
    pub _IO_backup_base: *mut ::std::ffi::c_char,
    pub _IO_save_end: *mut ::std::ffi::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::ffi::c_int,
    pub _flags2: ::std::ffi::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::ffi::c_ushort,
    pub _vtable_offset: ::std::ffi::c_schar,
    pub _shortbuf: [::std::ffi::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::ffi::c_void,
    pub __pad5: usize,
    pub _mode: ::std::ffi::c_int,
    pub _unused2: [::std::ffi::c_char; 40usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _IO_FILE"][::std::mem::size_of::<_IO_FILE>() - 148usize];
    ["Alignment of _IO_FILE"][::std::mem::align_of::<_IO_FILE>() - 4usize];
    ["Offset of field: _IO_FILE::_flags"][::std::mem::offset_of!(_IO_FILE, _flags) - 0usize];
    ["Offset of field: _IO_FILE::_IO_read_ptr"]
        [::std::mem::offset_of!(_IO_FILE, _IO_read_ptr) - 4usize];
    ["Offset of field: _IO_FILE::_IO_read_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_read_end) - 8usize];
    ["Offset of field: _IO_FILE::_IO_read_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_read_base) - 12usize];
    ["Offset of field: _IO_FILE::_IO_write_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_write_base) - 16usize];
    ["Offset of field: _IO_FILE::_IO_write_ptr"]
        [::std::mem::offset_of!(_IO_FILE, _IO_write_ptr) - 20usize];
    ["Offset of field: _IO_FILE::_IO_write_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_write_end) - 24usize];
    ["Offset of field: _IO_FILE::_IO_buf_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_buf_base) - 28usize];
    ["Offset of field: _IO_FILE::_IO_buf_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_buf_end) - 32usize];
    ["Offset of field: _IO_FILE::_IO_save_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_save_base) - 36usize];
    ["Offset of field: _IO_FILE::_IO_backup_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_backup_base) - 40usize];
    ["Offset of field: _IO_FILE::_IO_save_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_save_end) - 44usize];
    ["Offset of field: _IO_FILE::_markers"][::std::mem::offset_of!(_IO_FILE, _markers) - 48usize];
    ["Offset of field: _IO_FILE::_chain"][::std::mem::offset_of!(_IO_FILE, _chain) - 52usize];
    ["Offset of field: _IO_FILE::_fileno"][::std::mem::offset_of!(_IO_FILE, _fileno) - 56usize];
    ["Offset of field: _IO_FILE::_flags2"][::std::mem::offset_of!(_IO_FILE, _flags2) - 60usize];
    ["Offset of field: _IO_FILE::_old_offset"]
        [::std::mem::offset_of!(_IO_FILE, _old_offset) - 64usize];
    ["Offset of field: _IO_FILE::_cur_column"]
        [::std::mem::offset_of!(_IO_FILE, _cur_column) - 68usize];
    ["Offset of field: _IO_FILE::_vtable_offset"]
        [::std::mem::offset_of!(_IO_FILE, _vtable_offset) - 70usize];
    ["Offset of field: _IO_FILE::_shortbuf"][::std::mem::offset_of!(_IO_FILE, _shortbuf) - 71usize];
    ["Offset of field: _IO_FILE::_lock"][::std::mem::offset_of!(_IO_FILE, _lock) - 72usize];
    ["Offset of field: _IO_FILE::_offset"][::std::mem::offset_of!(_IO_FILE, _offset) - 76usize];
    ["Offset of field: _IO_FILE::_codecvt"][::std::mem::offset_of!(_IO_FILE, _codecvt) - 84usize];
    ["Offset of field: _IO_FILE::_wide_data"]
        [::std::mem::offset_of!(_IO_FILE, _wide_data) - 88usize];
    ["Offset of field: _IO_FILE::_freeres_list"]
        [::std::mem::offset_of!(_IO_FILE, _freeres_list) - 92usize];
    ["Offset of field: _IO_FILE::_freeres_buf"]
        [::std::mem::offset_of!(_IO_FILE, _freeres_buf) - 96usize];
    ["Offset of field: _IO_FILE::__pad5"][::std::mem::offset_of!(_IO_FILE, __pad5) - 100usize];
    ["Offset of field: _IO_FILE::_mode"][::std::mem::offset_of!(_IO_FILE, _mode) - 104usize];
    ["Offset of field: _IO_FILE::_unused2"][::std::mem::offset_of!(_IO_FILE, _unused2) - 108usize];
};
pub type wchar_t = ::std::ffi::c_int;
pub type time_t = __time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timespec"][::std::mem::size_of::<timespec>() - 8usize];
    ["Alignment of timespec"][::std::mem::align_of::<timespec>() - 4usize];
    ["Offset of field: timespec::tv_sec"][::std::mem::offset_of!(timespec, tv_sec) - 0usize];
    ["Offset of field: timespec::tv_nsec"][::std::mem::offset_of!(timespec, tv_nsec) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::ffi::c_int,
    pub tm_min: ::std::ffi::c_int,
    pub tm_hour: ::std::ffi::c_int,
    pub tm_mday: ::std::ffi::c_int,
    pub tm_mon: ::std::ffi::c_int,
    pub tm_year: ::std::ffi::c_int,
    pub tm_wday: ::std::ffi::c_int,
    pub tm_yday: ::std::ffi::c_int,
    pub tm_isdst: ::std::ffi::c_int,
    pub tm_gmtoff: ::std::ffi::c_long,
    pub tm_zone: *const ::std::ffi::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of tm"][::std::mem::size_of::<tm>() - 44usize];
    ["Alignment of tm"][::std::mem::align_of::<tm>() - 4usize];
    ["Offset of field: tm::tm_sec"][::std::mem::offset_of!(tm, tm_sec) - 0usize];
    ["Offset of field: tm::tm_min"][::std::mem::offset_of!(tm, tm_min) - 4usize];
    ["Offset of field: tm::tm_hour"][::std::mem::offset_of!(tm, tm_hour) - 8usize];
    ["Offset of field: tm::tm_mday"][::std::mem::offset_of!(tm, tm_mday) - 12usize];
    ["Offset of field: tm::tm_mon"][::std::mem::offset_of!(tm, tm_mon) - 16usize];
    ["Offset of field: tm::tm_year"][::std::mem::offset_of!(tm, tm_year) - 20usize];
    ["Offset of field: tm::tm_wday"][::std::mem::offset_of!(tm, tm_wday) - 24usize];
    ["Offset of field: tm::tm_yday"][::std::mem::offset_of!(tm, tm_yday) - 28usize];
    ["Offset of field: tm::tm_isdst"][::std::mem::offset_of!(tm, tm_isdst) - 32usize];
    ["Offset of field: tm::tm_gmtoff"][::std::mem::offset_of!(tm, tm_gmtoff) - 36usize];
    ["Offset of field: tm::tm_zone"][::std::mem::offset_of!(tm, tm_zone) - 40usize];
};
#[doc = " Int32 type"]
pub type GInt32 = ::std::ffi::c_int;
#[doc = " Unsigned int32 type"]
pub type GUInt32 = ::std::ffi::c_uint;
#[doc = " Int16 type"]
pub type GInt16 = ::std::ffi::c_short;
#[doc = " Unsigned byte type"]
pub type GByte = ::std::ffi::c_uchar;
#[doc = " Large signed integer type (generally 64-bit integer type).\n  Use GInt64 when exactly 64 bit is needed"]
pub type GIntBig = ::std::ffi::c_longlong;
#[doc = " Large unsigned integer type (generally 64-bit unsigned integer type).\n  Use GUInt64 when exactly 64 bit is needed"]
pub type GUIntBig = ::std::ffi::c_ulonglong;
#[doc = " Signed 64 bit integer type"]
pub type GInt64 = GIntBig;
#[doc = " Unsigned 64 bit integer type"]
pub type GUInt64 = GUIntBig;
#[doc = " Integer type large enough to hold the difference between 2 addresses"]
pub type GPtrDiff_t = GIntBig;
#[doc = " Type of a constant null-terminated list of nul terminated strings.\n Seen as char** from C and const char* const* from C++"]
pub type CSLConstList = *mut *mut ::std::ffi::c_char;
extern "C" {
    #[doc = " Add a value to a pointed integer in a thread and SMP-safe way\n and return the resulting value of the operation.\n\n This function, which in most cases is implemented by a few\n efficient machine instructions, guarantees that the value pointed\n by ptr will be incremented in a thread and SMP-safe way.\n The variables for this function must be aligned on a 32-bit boundary.\n\n Depending on the platforms, this function can also act as a\n memory barrier, but this should not be assumed.\n\n Current platforms/architectures where an efficient implementation\n exists are MacOSX, MS Windows, i386/x86_64 with GCC and platforms\n supported by GCC 4.1 or higher. For other platforms supporting\n the pthread library, and when GDAL is configured with thread-support,\n the atomicity will be done with a mutex, but with\n reduced efficiency. For the remaining platforms, a simple addition\n with no locking will be done...\n\n @param ptr a pointer to an integer to increment\n @param increment the amount to add to the pointed integer\n @return the pointed value AFTER the result of the addition"]
    pub fn CPLAtomicAdd(
        ptr: *mut ::std::ffi::c_int,
        increment: ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    #[doc = " Compares *ptr with oldval. If *ptr == oldval, then *ptr is assigned\n newval and TRUE is returned. Otherwise nothing is done, and FALSE is returned.\n\n Current platforms/architectures where an efficient implementation\n exists are MacOSX, MS Windows, i386/x86_64 with GCC and platforms\n supported by GCC 4.1 or higher. For other platforms supporting\n the pthread library, and when GDAL is configured with thread-support,\n the atomicity will be done with a mutex, but with\n reduced efficiency. For the remaining platforms, a simple compare and\n exchange with no locking will be done...\n\n @param ptr a pointer to an integer (aligned on 32bit boundary).\n @param oldval old value\n @param newval new value\n @return TRUE if the exchange has been done"]
    pub fn CPLAtomicCompareAndExchange(
        ptr: *mut ::std::ffi::c_int,
        oldval: ::std::ffi::c_int,
        newval: ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
pub type GDALProgressFunc = ::std::option::Option<
    unsafe extern "C" fn(
        dfComplete: f64,
        pszMessage: *const ::std::ffi::c_char,
        pProgressArg: *mut ::std::ffi::c_void,
    ) -> ::std::ffi::c_int,
>;
extern "C" {
    pub fn GDALDummyProgress(
        arg1: f64,
        arg2: *const ::std::ffi::c_char,
        arg3: *mut ::std::ffi::c_void,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALTermProgress(
        arg1: f64,
        arg2: *const ::std::ffi::c_char,
        arg3: *mut ::std::ffi::c_void,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALScaledProgress(
        arg1: f64,
        arg2: *const ::std::ffi::c_char,
        arg3: *mut ::std::ffi::c_void,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALCreateScaledProgress(
        arg1: f64,
        arg2: f64,
        arg3: GDALProgressFunc,
        arg4: *mut ::std::ffi::c_void,
    ) -> *mut ::std::ffi::c_void;
}
extern "C" {
    pub fn GDALDestroyScaledProgress(arg1: *mut ::std::ffi::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stat {
    pub st_dev: __dev_t,
    pub __pad1: ::std::ffi::c_ushort,
    pub st_ino: __ino_t,
    pub st_mode: __mode_t,
    pub st_nlink: __nlink_t,
    pub st_uid: __uid_t,
    pub st_gid: __gid_t,
    pub st_rdev: __dev_t,
    pub __pad2: ::std::ffi::c_ushort,
    pub st_size: __off_t,
    pub st_blksize: __blksize_t,
    pub st_blocks: __blkcnt_t,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    pub __glibc_reserved4: ::std::ffi::c_ulong,
    pub __glibc_reserved5: ::std::ffi::c_ulong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of stat"][::std::mem::size_of::<stat>() - 88usize];
    ["Alignment of stat"][::std::mem::align_of::<stat>() - 4usize];
    ["Offset of field: stat::st_dev"][::std::mem::offset_of!(stat, st_dev) - 0usize];
    ["Offset of field: stat::__pad1"][::std::mem::offset_of!(stat, __pad1) - 8usize];
    ["Offset of field: stat::st_ino"][::std::mem::offset_of!(stat, st_ino) - 12usize];
    ["Offset of field: stat::st_mode"][::std::mem::offset_of!(stat, st_mode) - 16usize];
    ["Offset of field: stat::st_nlink"][::std::mem::offset_of!(stat, st_nlink) - 20usize];
    ["Offset of field: stat::st_uid"][::std::mem::offset_of!(stat, st_uid) - 24usize];
    ["Offset of field: stat::st_gid"][::std::mem::offset_of!(stat, st_gid) - 28usize];
    ["Offset of field: stat::st_rdev"][::std::mem::offset_of!(stat, st_rdev) - 32usize];
    ["Offset of field: stat::__pad2"][::std::mem::offset_of!(stat, __pad2) - 40usize];
    ["Offset of field: stat::st_size"][::std::mem::offset_of!(stat, st_size) - 44usize];
    ["Offset of field: stat::st_blksize"][::std::mem::offset_of!(stat, st_blksize) - 48usize];
    ["Offset of field: stat::st_blocks"][::std::mem::offset_of!(stat, st_blocks) - 52usize];
    ["Offset of field: stat::st_atim"][::std::mem::offset_of!(stat, st_atim) - 56usize];
    ["Offset of field: stat::st_mtim"][::std::mem::offset_of!(stat, st_mtim) - 64usize];
    ["Offset of field: stat::st_ctim"][::std::mem::offset_of!(stat, st_ctim) - 72usize];
    ["Offset of field: stat::__glibc_reserved4"]
        [::std::mem::offset_of!(stat, __glibc_reserved4) - 80usize];
    ["Offset of field: stat::__glibc_reserved5"]
        [::std::mem::offset_of!(stat, __glibc_reserved5) - 84usize];
};
extern "C" {
    #[doc = " @cond Doxygen_Suppress"]
    pub fn VSIFOpen(arg1: *const ::std::ffi::c_char, arg2: *const ::std::ffi::c_char) -> *mut FILE;
}
extern "C" {
    pub fn VSIFClose(arg1: *mut FILE) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn VSIFSeek(
        arg1: *mut FILE,
        arg2: ::std::ffi::c_long,
        arg3: ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn VSIFTell(arg1: *mut FILE) -> ::std::ffi::c_long;
}
extern "C" {
    pub fn VSIRewind(arg1: *mut FILE);
}
extern "C" {
    pub fn VSIFFlush(arg1: *mut FILE);
}
extern "C" {
    pub fn VSIFRead(
        arg1: *mut ::std::ffi::c_void,
        arg2: usize,
        arg3: usize,
        arg4: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn VSIFWrite(
        arg1: *const ::std::ffi::c_void,
        arg2: usize,
        arg3: usize,
        arg4: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn VSIFGets(
        arg1: *mut ::std::ffi::c_char,
        arg2: ::std::ffi::c_int,
        arg3: *mut FILE,
    ) -> *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn VSIFPuts(arg1: *const ::std::ffi::c_char, arg2: *mut FILE) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn VSIFPrintf(arg1: *mut FILE, arg2: *const ::std::ffi::c_char, ...) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn VSIFGetc(arg1: *mut FILE) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn VSIFPutc(arg1: ::std::ffi::c_int, arg2: *mut FILE) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn VSIUngetc(arg1: ::std::ffi::c_int, arg2: *mut FILE) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn VSIFEof(arg1: *mut FILE) -> ::std::ffi::c_int;
}
#[doc = " @cond Doxygen_Suppress"]
pub type VSIStatBuf = stat;
extern "C" {
    pub fn VSIStat(arg1: *const ::std::ffi::c_char, arg2: *mut VSIStatBuf) -> ::std::ffi::c_int;
}
#[doc = " Type for a file offset"]
pub type vsi_l_offset = GUIntBig;
#[doc = " Opaque type for a FILE that implements the VSIVirtualHandle API"]
pub type VSILFILE = FILE;
extern "C" {
    pub fn VSIFOpenL(
        arg1: *const ::std::ffi::c_char,
        arg2: *const ::std::ffi::c_char,
    ) -> *mut VSILFILE;
}
extern "C" {
    pub fn VSIFOpenExL(
        arg1: *const ::std::ffi::c_char,
        arg2: *const ::std::ffi::c_char,
        arg3: ::std::ffi::c_int,
    ) -> *mut VSILFILE;
}
extern "C" {
    pub fn VSIFOpenEx2L(
        arg1: *const ::std::ffi::c_char,
        arg2: *const ::std::ffi::c_char,
        arg3: ::std::ffi::c_int,
        arg4: CSLConstList,
    ) -> *mut VSILFILE;
}
extern "C" {
    pub fn VSIFCloseL(arg1: *mut VSILFILE) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn VSIFSeekL(
        arg1: *mut VSILFILE,
        arg2: vsi_l_offset,
        arg3: ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn VSIFTellL(arg1: *mut VSILFILE) -> vsi_l_offset;
}
extern "C" {
    pub fn VSIRewindL(arg1: *mut VSILFILE);
}
extern "C" {
    pub fn VSIFReadL(
        arg1: *mut ::std::ffi::c_void,
        arg2: usize,
        arg3: usize,
        arg4: *mut VSILFILE,
    ) -> usize;
}
extern "C" {
    pub fn VSIFReadMultiRangeL(
        nRanges: ::std::ffi::c_int,
        ppData: *mut *mut ::std::ffi::c_void,
        panOffsets: *const vsi_l_offset,
        panSizes: *const usize,
        arg1: *mut VSILFILE,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn VSIFWriteL(
        arg1: *const ::std::ffi::c_void,
        arg2: usize,
        arg3: usize,
        arg4: *mut VSILFILE,
    ) -> usize;
}
extern "C" {
    pub fn VSIFEofL(arg1: *mut VSILFILE) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn VSIFTruncateL(arg1: *mut VSILFILE, arg2: vsi_l_offset) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn VSIFFlushL(arg1: *mut VSILFILE) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn VSIFPrintfL(
        arg1: *mut VSILFILE,
        arg2: *const ::std::ffi::c_char,
        ...
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn VSIFPutcL(arg1: ::std::ffi::c_int, arg2: *mut VSILFILE) -> ::std::ffi::c_int;
}
pub mod VSIRangeStatus {
    #[doc = " Range status"]
    pub type Type = ::std::ffi::c_uint;
    #[doc = "< Unknown"]
    pub const VSI_RANGE_STATUS_UNKNOWN: Type = 0;
    #[doc = "< Data present"]
    pub const VSI_RANGE_STATUS_DATA: Type = 1;
    #[doc = "< Hole"]
    pub const VSI_RANGE_STATUS_HOLE: Type = 2;
}
extern "C" {
    pub fn VSIFGetRangeStatusL(
        fp: *mut VSILFILE,
        nStart: vsi_l_offset,
        nLength: vsi_l_offset,
    ) -> VSIRangeStatus::Type;
}
extern "C" {
    pub fn VSIIngestFile(
        fp: *mut VSILFILE,
        pszFilename: *const ::std::ffi::c_char,
        ppabyRet: *mut *mut GByte,
        pnSize: *mut vsi_l_offset,
        nMaxSize: GIntBig,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn VSIOverwriteFile(
        fpTarget: *mut VSILFILE,
        pszSourceFilename: *const ::std::ffi::c_char,
    ) -> ::std::ffi::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stat64 {
    _unused: [u8; 0],
}
#[doc = " Type for VSIStatL()"]
pub type VSIStatBufL = stat64;
extern "C" {
    pub fn VSIStatL(arg1: *const ::std::ffi::c_char, arg2: *mut VSIStatBufL) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn VSIStatExL(
        pszFilename: *const ::std::ffi::c_char,
        psStatBuf: *mut VSIStatBufL,
        nFlags: ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn VSIIsCaseSensitiveFS(pszFilename: *const ::std::ffi::c_char) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn VSISupportsSparseFiles(pszPath: *const ::std::ffi::c_char) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn VSIHasOptimizedReadMultiRange(pszPath: *const ::std::ffi::c_char) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn VSIGetActualURL(pszFilename: *const ::std::ffi::c_char) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn VSIGetSignedURL(
        pszFilename: *const ::std::ffi::c_char,
        papszOptions: CSLConstList,
    ) -> *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn VSIGetFileSystemOptions(
        pszFilename: *const ::std::ffi::c_char,
    ) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn VSIGetFileSystemsPrefixes() -> *mut *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn VSIFGetNativeFileDescriptorL(arg1: *mut VSILFILE) -> *mut ::std::ffi::c_void;
}
extern "C" {
    pub fn VSIGetFileMetadata(
        pszFilename: *const ::std::ffi::c_char,
        pszDomain: *const ::std::ffi::c_char,
        papszOptions: CSLConstList,
    ) -> *mut *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn VSISetFileMetadata(
        pszFilename: *const ::std::ffi::c_char,
        papszMetadata: CSLConstList,
        pszDomain: *const ::std::ffi::c_char,
        papszOptions: CSLConstList,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn VSISetCredential(
        pszPathPrefix: *const ::std::ffi::c_char,
        pszKey: *const ::std::ffi::c_char,
        pszValue: *const ::std::ffi::c_char,
    );
}
extern "C" {
    pub fn VSIClearCredentials(pszPathPrefix: *const ::std::ffi::c_char);
}
extern "C" {
    pub fn VSIGetCredential(
        pszPath: *const ::std::ffi::c_char,
        pszKey: *const ::std::ffi::c_char,
        pszDefault: *const ::std::ffi::c_char,
    ) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn VSICalloc(arg1: usize, arg2: usize) -> *mut ::std::ffi::c_void;
}
extern "C" {
    pub fn VSIMalloc(arg1: usize) -> *mut ::std::ffi::c_void;
}
extern "C" {
    pub fn VSIFree(arg1: *mut ::std::ffi::c_void);
}
extern "C" {
    pub fn VSIRealloc(arg1: *mut ::std::ffi::c_void, arg2: usize) -> *mut ::std::ffi::c_void;
}
extern "C" {
    pub fn VSIStrdup(arg1: *const ::std::ffi::c_char) -> *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn VSIMallocAligned(nAlignment: usize, nSize: usize) -> *mut ::std::ffi::c_void;
}
extern "C" {
    pub fn VSIMallocAlignedAuto(nSize: usize) -> *mut ::std::ffi::c_void;
}
extern "C" {
    pub fn VSIFreeAligned(ptr: *mut ::std::ffi::c_void);
}
extern "C" {
    pub fn VSIMallocAlignedAutoVerbose(
        nSize: usize,
        pszFile: *const ::std::ffi::c_char,
        nLine: ::std::ffi::c_int,
    ) -> *mut ::std::ffi::c_void;
}
extern "C" {
    #[doc = "VSIMalloc2 allocates (nSize1 * nSize2) bytes.\nIn case of overflow of the multiplication, or if memory allocation fails, a\nNULL pointer is returned and a CE_Failure error is raised with CPLError().\nIf nSize1 == 0 || nSize2 == 0, a NULL pointer will also be returned.\nCPLFree() or VSIFree() can be used to free memory allocated by this function."]
    pub fn VSIMalloc2(nSize1: usize, nSize2: usize) -> *mut ::std::ffi::c_void;
}
extern "C" {
    #[doc = "VSIMalloc3 allocates (nSize1 * nSize2 * nSize3) bytes.\nIn case of overflow of the multiplication, or if memory allocation fails, a\nNULL pointer is returned and a CE_Failure error is raised with CPLError().\nIf nSize1 == 0 || nSize2 == 0 || nSize3 == 0, a NULL pointer will also be returned.\nCPLFree() or VSIFree() can be used to free memory allocated by this function."]
    pub fn VSIMalloc3(nSize1: usize, nSize2: usize, nSize3: usize) -> *mut ::std::ffi::c_void;
}
extern "C" {
    #[doc = " VSIMallocVerbose"]
    pub fn VSIMallocVerbose(
        nSize: usize,
        pszFile: *const ::std::ffi::c_char,
        nLine: ::std::ffi::c_int,
    ) -> *mut ::std::ffi::c_void;
}
extern "C" {
    #[doc = " VSIMalloc2Verbose"]
    pub fn VSIMalloc2Verbose(
        nSize1: usize,
        nSize2: usize,
        pszFile: *const ::std::ffi::c_char,
        nLine: ::std::ffi::c_int,
    ) -> *mut ::std::ffi::c_void;
}
extern "C" {
    #[doc = " VSIMalloc3Verbose"]
    pub fn VSIMalloc3Verbose(
        nSize1: usize,
        nSize2: usize,
        nSize3: usize,
        pszFile: *const ::std::ffi::c_char,
        nLine: ::std::ffi::c_int,
    ) -> *mut ::std::ffi::c_void;
}
extern "C" {
    #[doc = " VSICallocVerbose"]
    pub fn VSICallocVerbose(
        nCount: usize,
        nSize: usize,
        pszFile: *const ::std::ffi::c_char,
        nLine: ::std::ffi::c_int,
    ) -> *mut ::std::ffi::c_void;
}
extern "C" {
    #[doc = " VSIReallocVerbose"]
    pub fn VSIReallocVerbose(
        pOldPtr: *mut ::std::ffi::c_void,
        nNewSize: usize,
        pszFile: *const ::std::ffi::c_char,
        nLine: ::std::ffi::c_int,
    ) -> *mut ::std::ffi::c_void;
}
extern "C" {
    #[doc = " VSIStrdupVerbose"]
    pub fn VSIStrdupVerbose(
        pszStr: *const ::std::ffi::c_char,
        pszFile: *const ::std::ffi::c_char,
        nLine: ::std::ffi::c_int,
    ) -> *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn CPLGetPhysicalRAM() -> GIntBig;
}
extern "C" {
    pub fn CPLGetUsablePhysicalRAM() -> GIntBig;
}
extern "C" {
    pub fn VSIReadDir(arg1: *const ::std::ffi::c_char) -> *mut *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn VSIReadDirRecursive(pszPath: *const ::std::ffi::c_char) -> *mut *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn VSIReadDirEx(
        pszPath: *const ::std::ffi::c_char,
        nMaxFiles: ::std::ffi::c_int,
    ) -> *mut *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn VSISiblingFiles(pszPath: *const ::std::ffi::c_char) -> *mut *mut ::std::ffi::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VSIDIR {
    _unused: [u8; 0],
}
extern "C" {
    pub fn VSIOpenDir(
        pszPath: *const ::std::ffi::c_char,
        nRecurseDepth: ::std::ffi::c_int,
        papszOptions: *const *const ::std::ffi::c_char,
    ) -> *mut VSIDIR;
}
#[doc = " Directory entry."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VSIDIREntry {
    #[doc = " Filename"]
    pub pszName: *mut ::std::ffi::c_char,
    #[doc = " File mode. See VSI_ISREG() / VSI_ISDIR()"]
    pub nMode: ::std::ffi::c_int,
    #[doc = " File size"]
    pub nSize: vsi_l_offset,
    #[doc = " Last modification time (seconds since 1970/01/01)"]
    pub nMTime: GIntBig,
    #[doc = " Whether nMode is known: 0 = unknown, 1 = known."]
    pub bModeKnown: ::std::ffi::c_char,
    #[doc = " Whether nSize is known: 0 = unknown, 1 = known."]
    pub bSizeKnown: ::std::ffi::c_char,
    #[doc = " Whether nMTime is known: 0 = unknown, 1 = known."]
    pub bMTimeKnown: ::std::ffi::c_char,
    #[doc = " NULL-terminated list of extra properties."]
    pub papszExtra: *mut *mut ::std::ffi::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of VSIDIREntry"][::std::mem::size_of::<VSIDIREntry>() - 32usize];
    ["Alignment of VSIDIREntry"][::std::mem::align_of::<VSIDIREntry>() - 4usize];
    ["Offset of field: VSIDIREntry::pszName"]
        [::std::mem::offset_of!(VSIDIREntry, pszName) - 0usize];
    ["Offset of field: VSIDIREntry::nMode"][::std::mem::offset_of!(VSIDIREntry, nMode) - 4usize];
    ["Offset of field: VSIDIREntry::nSize"][::std::mem::offset_of!(VSIDIREntry, nSize) - 8usize];
    ["Offset of field: VSIDIREntry::nMTime"][::std::mem::offset_of!(VSIDIREntry, nMTime) - 16usize];
    ["Offset of field: VSIDIREntry::bModeKnown"]
        [::std::mem::offset_of!(VSIDIREntry, bModeKnown) - 24usize];
    ["Offset of field: VSIDIREntry::bSizeKnown"]
        [::std::mem::offset_of!(VSIDIREntry, bSizeKnown) - 25usize];
    ["Offset of field: VSIDIREntry::bMTimeKnown"]
        [::std::mem::offset_of!(VSIDIREntry, bMTimeKnown) - 26usize];
    ["Offset of field: VSIDIREntry::papszExtra"]
        [::std::mem::offset_of!(VSIDIREntry, papszExtra) - 28usize];
};
extern "C" {
    pub fn VSIGetNextDirEntry(dir: *mut VSIDIR) -> *const VSIDIREntry;
}
extern "C" {
    pub fn VSICloseDir(dir: *mut VSIDIR);
}
extern "C" {
    pub fn VSIMkdir(
        pszPathname: *const ::std::ffi::c_char,
        mode: ::std::ffi::c_long,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn VSIMkdirRecursive(
        pszPathname: *const ::std::ffi::c_char,
        mode: ::std::ffi::c_long,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn VSIRmdir(pszDirname: *const ::std::ffi::c_char) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn VSIRmdirRecursive(pszDirname: *const ::std::ffi::c_char) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn VSIUnlink(pszFilename: *const ::std::ffi::c_char) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn VSIUnlinkBatch(papszFiles: CSLConstList) -> *mut ::std::ffi::c_int;
}
extern "C" {
    pub fn VSIRename(
        oldpath: *const ::std::ffi::c_char,
        newpath: *const ::std::ffi::c_char,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn VSISync(
        pszSource: *const ::std::ffi::c_char,
        pszTarget: *const ::std::ffi::c_char,
        papszOptions: *const *const ::std::ffi::c_char,
        pProgressFunc: GDALProgressFunc,
        pProgressData: *mut ::std::ffi::c_void,
        ppapszOutputs: *mut *mut *mut ::std::ffi::c_char,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn VSIAbortPendingUploads(pszFilename: *const ::std::ffi::c_char) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn VSIStrerror(arg1: ::std::ffi::c_int) -> *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn VSIGetDiskFreeSpace(pszDirname: *const ::std::ffi::c_char) -> GIntBig;
}
extern "C" {
    pub fn VSINetworkStatsReset();
}
extern "C" {
    pub fn VSINetworkStatsGetAsSerializedJSON(
        papszOptions: *mut *mut ::std::ffi::c_char,
    ) -> *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn VSIInstallMemFileHandler();
}
extern "C" {
    #[doc = " @cond Doxygen_Suppress"]
    pub fn VSIInstallLargeFileHandler();
}
extern "C" {
    #[doc = " @endcond"]
    pub fn VSIInstallSubFileHandler();
}
extern "C" {
    pub fn VSIInstallCurlFileHandler();
}
extern "C" {
    pub fn VSICurlClearCache();
}
extern "C" {
    pub fn VSICurlPartialClearCache(pszFilenamePrefix: *const ::std::ffi::c_char);
}
extern "C" {
    pub fn VSIInstallCurlStreamingFileHandler();
}
extern "C" {
    pub fn VSIInstallS3FileHandler();
}
extern "C" {
    pub fn VSIInstallS3StreamingFileHandler();
}
extern "C" {
    pub fn VSIInstallGSFileHandler();
}
extern "C" {
    pub fn VSIInstallGSStreamingFileHandler();
}
extern "C" {
    pub fn VSIInstallAzureFileHandler();
}
extern "C" {
    pub fn VSIInstallAzureStreamingFileHandler();
}
extern "C" {
    pub fn VSIInstallADLSFileHandler();
}
extern "C" {
    pub fn VSIInstallOSSFileHandler();
}
extern "C" {
    pub fn VSIInstallOSSStreamingFileHandler();
}
extern "C" {
    pub fn VSIInstallSwiftFileHandler();
}
extern "C" {
    pub fn VSIInstallSwiftStreamingFileHandler();
}
extern "C" {
    pub fn VSIInstallGZipFileHandler();
}
extern "C" {
    pub fn VSIInstallZipFileHandler();
}
extern "C" {
    pub fn VSIInstallStdinHandler();
}
extern "C" {
    pub fn VSIInstallHdfsHandler();
}
extern "C" {
    pub fn VSIInstallWebHdfsHandler();
}
extern "C" {
    pub fn VSIInstallStdoutHandler();
}
extern "C" {
    pub fn VSIInstallSparseFileHandler();
}
extern "C" {
    pub fn VSIInstallTarFileHandler();
}
extern "C" {
    pub fn VSIInstallCryptFileHandler();
}
extern "C" {
    pub fn VSISetCryptKey(pabyKey: *const GByte, nKeySize: ::std::ffi::c_int);
}
extern "C" {
    #[doc = " @cond Doxygen_Suppress"]
    pub fn VSICleanupFileManager();
}
extern "C" {
    #[doc = " @endcond"]
    pub fn VSIFileFromMemBuffer(
        pszFilename: *const ::std::ffi::c_char,
        pabyData: *mut GByte,
        nDataLength: vsi_l_offset,
        bTakeOwnership: ::std::ffi::c_int,
    ) -> *mut VSILFILE;
}
extern "C" {
    pub fn VSIGetMemFileBuffer(
        pszFilename: *const ::std::ffi::c_char,
        pnDataLength: *mut vsi_l_offset,
        bUnlinkAndSeize: ::std::ffi::c_int,
    ) -> *mut GByte;
}
#[doc = " Callback used by VSIStdoutSetRedirection()"]
pub type VSIWriteFunction = ::std::option::Option<
    unsafe extern "C" fn(
        ptr: *const ::std::ffi::c_void,
        size: usize,
        nmemb: usize,
        stream: *mut FILE,
    ) -> usize,
>;
extern "C" {
    pub fn VSIStdoutSetRedirection(pFct: VSIWriteFunction, stream: *mut FILE);
}
#[doc = " Return information about a handle. Optional (driver dependent)\n @since GDAL 3.0"]
pub type VSIFilesystemPluginStatCallback = ::std::option::Option<
    unsafe extern "C" fn(
        pUserData: *mut ::std::ffi::c_void,
        pszFilename: *const ::std::ffi::c_char,
        pStatBuf: *mut VSIStatBufL,
        nFlags: ::std::ffi::c_int,
    ) -> ::std::ffi::c_int,
>;
#[doc = " Remove handle by name. Optional\n @since GDAL 3.0"]
pub type VSIFilesystemPluginUnlinkCallback = ::std::option::Option<
    unsafe extern "C" fn(
        pUserData: *mut ::std::ffi::c_void,
        pszFilename: *const ::std::ffi::c_char,
    ) -> ::std::ffi::c_int,
>;
#[doc = " Rename handle. Optional\n @since GDAL 3.0"]
pub type VSIFilesystemPluginRenameCallback = ::std::option::Option<
    unsafe extern "C" fn(
        pUserData: *mut ::std::ffi::c_void,
        oldpath: *const ::std::ffi::c_char,
        newpath: *const ::std::ffi::c_char,
    ) -> ::std::ffi::c_int,
>;
#[doc = " Create Directory. Optional\n @since GDAL 3.0"]
pub type VSIFilesystemPluginMkdirCallback = ::std::option::Option<
    unsafe extern "C" fn(
        pUserData: *mut ::std::ffi::c_void,
        pszDirname: *const ::std::ffi::c_char,
        nMode: ::std::ffi::c_long,
    ) -> ::std::ffi::c_int,
>;
#[doc = "  Delete Directory. Optional\n @since GDAL 3.0"]
pub type VSIFilesystemPluginRmdirCallback = ::std::option::Option<
    unsafe extern "C" fn(
        pUserData: *mut ::std::ffi::c_void,
        pszDirname: *const ::std::ffi::c_char,
    ) -> ::std::ffi::c_int,
>;
#[doc = " List directory content. Optional\n @since GDAL 3.0"]
pub type VSIFilesystemPluginReadDirCallback = ::std::option::Option<
    unsafe extern "C" fn(
        pUserData: *mut ::std::ffi::c_void,
        pszDirname: *const ::std::ffi::c_char,
        nMaxFiles: ::std::ffi::c_int,
    ) -> *mut *mut ::std::ffi::c_char,
>;
#[doc = " List related files. Must return NULL if unknown, or a list of relative filenames\n that can be opened along the main file. If no other file than pszFilename needs to\n be opened, return static_cast<char**> (CPLCalloc(1,sizeof(char*)));\n\n Optional\n @since GDAL 3.2"]
pub type VSIFilesystemPluginSiblingFilesCallback = ::std::option::Option<
    unsafe extern "C" fn(
        pUserData: *mut ::std::ffi::c_void,
        pszDirname: *const ::std::ffi::c_char,
    ) -> *mut *mut ::std::ffi::c_char,
>;
#[doc = " Open a handle. Mandatory. Returns an opaque pointer that will be used in subsequent file I/O calls.\n Should return null and/or set errno if the handle does not exist or the access mode is incorrect.\n @since GDAL 3.0"]
pub type VSIFilesystemPluginOpenCallback = ::std::option::Option<
    unsafe extern "C" fn(
        pUserData: *mut ::std::ffi::c_void,
        pszFilename: *const ::std::ffi::c_char,
        pszAccess: *const ::std::ffi::c_char,
    ) -> *mut ::std::ffi::c_void,
>;
#[doc = " Return current position in handle. Mandatory\n @since GDAL 3.0"]
pub type VSIFilesystemPluginTellCallback =
    ::std::option::Option<unsafe extern "C" fn(pFile: *mut ::std::ffi::c_void) -> vsi_l_offset>;
#[doc = " Seek to position in handle. Mandatory except for write only handles\n @since GDAL 3.0"]
pub type VSIFilesystemPluginSeekCallback = ::std::option::Option<
    unsafe extern "C" fn(
        pFile: *mut ::std::ffi::c_void,
        nOffset: vsi_l_offset,
        nWhence: ::std::ffi::c_int,
    ) -> ::std::ffi::c_int,
>;
#[doc = " Read data from current position, returns the number of blocks correctly read.\n Mandatory except for write only handles\n @since GDAL 3.0"]
pub type VSIFilesystemPluginReadCallback = ::std::option::Option<
    unsafe extern "C" fn(
        pFile: *mut ::std::ffi::c_void,
        pBuffer: *mut ::std::ffi::c_void,
        nSize: usize,
        nCount: usize,
    ) -> usize,
>;
#[doc = " Read from multiple offsets. Optional, will be replaced by multiple calls to Read() if not provided\n @since GDAL 3.0"]
pub type VSIFilesystemPluginReadMultiRangeCallback = ::std::option::Option<
    unsafe extern "C" fn(
        pFile: *mut ::std::ffi::c_void,
        nRanges: ::std::ffi::c_int,
        ppData: *mut *mut ::std::ffi::c_void,
        panOffsets: *const vsi_l_offset,
        panSizes: *const usize,
    ) -> ::std::ffi::c_int,
>;
#[doc = " Get empty ranges. Optional\n @since GDAL 3.0"]
pub type VSIFilesystemPluginGetRangeStatusCallback = ::std::option::Option<
    unsafe extern "C" fn(
        pFile: *mut ::std::ffi::c_void,
        nOffset: vsi_l_offset,
        nLength: vsi_l_offset,
    ) -> VSIRangeStatus::Type,
>;
#[doc = " Has end of file been reached. Mandatory? for read handles.\n @since GDAL 3.0"]
pub type VSIFilesystemPluginEofCallback = ::std::option::Option<
    unsafe extern "C" fn(pFile: *mut ::std::ffi::c_void) -> ::std::ffi::c_int,
>;
#[doc = " Write bytes at current offset. Mandatory for writable handles\n @since GDAL 3.0"]
pub type VSIFilesystemPluginWriteCallback = ::std::option::Option<
    unsafe extern "C" fn(
        pFile: *mut ::std::ffi::c_void,
        pBuffer: *const ::std::ffi::c_void,
        nSize: usize,
        nCount: usize,
    ) -> usize,
>;
#[doc = " Sync written bytes. Optional\n @since GDAL 3.0"]
pub type VSIFilesystemPluginFlushCallback = ::std::option::Option<
    unsafe extern "C" fn(pFile: *mut ::std::ffi::c_void) -> ::std::ffi::c_int,
>;
#[doc = " Truncate handle. Mandatory (driver dependent?) for write handles"]
pub type VSIFilesystemPluginTruncateCallback = ::std::option::Option<
    unsafe extern "C" fn(
        pFile: *mut ::std::ffi::c_void,
        nNewSize: vsi_l_offset,
    ) -> ::std::ffi::c_int,
>;
#[doc = " Close file handle. Optional\n @since GDAL 3.0"]
pub type VSIFilesystemPluginCloseCallback = ::std::option::Option<
    unsafe extern "C" fn(pFile: *mut ::std::ffi::c_void) -> ::std::ffi::c_int,
>;
#[doc = " struct containing callbacks to used by the handler.\n (rw), (r), (w) or () at the end indicate whether the given callback is mandatory\n for reading and or writing handlers. A (?) indicates that the callback might\n be mandatory for certain drivers only.\n @since GDAL 3.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VSIFilesystemPluginCallbacksStruct {
    #[doc = " Optional opaque pointer passed back to filemanager callbacks (e.g. open, stat, rmdir)"]
    pub pUserData: *mut ::std::ffi::c_void,
    #[doc = "< stat handle by name (rw)"]
    pub stat: VSIFilesystemPluginStatCallback,
    #[doc = "< unlink handle by name ()"]
    pub unlink: VSIFilesystemPluginUnlinkCallback,
    #[doc = "< rename handle ()"]
    pub rename: VSIFilesystemPluginRenameCallback,
    #[doc = "< make directory ()"]
    pub mkdir: VSIFilesystemPluginMkdirCallback,
    #[doc = "< remove directory ()"]
    pub rmdir: VSIFilesystemPluginRmdirCallback,
    #[doc = "< list directory content (r?)"]
    pub read_dir: VSIFilesystemPluginReadDirCallback,
    #[doc = "< open handle by name (rw)"]
    pub open: VSIFilesystemPluginOpenCallback,
    #[doc = "< get current position of handle (rw)"]
    pub tell: VSIFilesystemPluginTellCallback,
    #[doc = "< set current position of handle (rw)"]
    pub seek: VSIFilesystemPluginSeekCallback,
    #[doc = "< read from current position (r)"]
    pub read: VSIFilesystemPluginReadCallback,
    #[doc = "< read multiple blocks ()"]
    pub read_multi_range: VSIFilesystemPluginReadMultiRangeCallback,
    #[doc = "< get range status ()"]
    pub get_range_status: VSIFilesystemPluginGetRangeStatusCallback,
    #[doc = "< has end of file been reached (r?)"]
    pub eof: VSIFilesystemPluginEofCallback,
    #[doc = "< write bytes to current position (w)"]
    pub write: VSIFilesystemPluginWriteCallback,
    #[doc = "< sync bytes (w)"]
    pub flush: VSIFilesystemPluginFlushCallback,
    #[doc = "< truncate handle (w?)"]
    pub truncate: VSIFilesystemPluginTruncateCallback,
    #[doc = "< close handle  (rw)"]
    pub close: VSIFilesystemPluginCloseCallback,
    #[doc = "< buffer small reads (makes handler read only)"]
    pub nBufferSize: usize,
    #[doc = "< max mem to use per file when buffering"]
    pub nCacheSize: usize,
    #[doc = "< list related files"]
    pub sibling_files: VSIFilesystemPluginSiblingFilesCallback,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of VSIFilesystemPluginCallbacksStruct"]
        [::std::mem::size_of::<VSIFilesystemPluginCallbacksStruct>() - 84usize];
    ["Alignment of VSIFilesystemPluginCallbacksStruct"]
        [::std::mem::align_of::<VSIFilesystemPluginCallbacksStruct>() - 4usize];
    ["Offset of field: VSIFilesystemPluginCallbacksStruct::pUserData"]
        [::std::mem::offset_of!(VSIFilesystemPluginCallbacksStruct, pUserData) - 0usize];
    ["Offset of field: VSIFilesystemPluginCallbacksStruct::stat"]
        [::std::mem::offset_of!(VSIFilesystemPluginCallbacksStruct, stat) - 4usize];
    ["Offset of field: VSIFilesystemPluginCallbacksStruct::unlink"]
        [::std::mem::offset_of!(VSIFilesystemPluginCallbacksStruct, unlink) - 8usize];
    ["Offset of field: VSIFilesystemPluginCallbacksStruct::rename"]
        [::std::mem::offset_of!(VSIFilesystemPluginCallbacksStruct, rename) - 12usize];
    ["Offset of field: VSIFilesystemPluginCallbacksStruct::mkdir"]
        [::std::mem::offset_of!(VSIFilesystemPluginCallbacksStruct, mkdir) - 16usize];
    ["Offset of field: VSIFilesystemPluginCallbacksStruct::rmdir"]
        [::std::mem::offset_of!(VSIFilesystemPluginCallbacksStruct, rmdir) - 20usize];
    ["Offset of field: VSIFilesystemPluginCallbacksStruct::read_dir"]
        [::std::mem::offset_of!(VSIFilesystemPluginCallbacksStruct, read_dir) - 24usize];
    ["Offset of field: VSIFilesystemPluginCallbacksStruct::open"]
        [::std::mem::offset_of!(VSIFilesystemPluginCallbacksStruct, open) - 28usize];
    ["Offset of field: VSIFilesystemPluginCallbacksStruct::tell"]
        [::std::mem::offset_of!(VSIFilesystemPluginCallbacksStruct, tell) - 32usize];
    ["Offset of field: VSIFilesystemPluginCallbacksStruct::seek"]
        [::std::mem::offset_of!(VSIFilesystemPluginCallbacksStruct, seek) - 36usize];
    ["Offset of field: VSIFilesystemPluginCallbacksStruct::read"]
        [::std::mem::offset_of!(VSIFilesystemPluginCallbacksStruct, read) - 40usize];
    ["Offset of field: VSIFilesystemPluginCallbacksStruct::read_multi_range"]
        [::std::mem::offset_of!(VSIFilesystemPluginCallbacksStruct, read_multi_range) - 44usize];
    ["Offset of field: VSIFilesystemPluginCallbacksStruct::get_range_status"]
        [::std::mem::offset_of!(VSIFilesystemPluginCallbacksStruct, get_range_status) - 48usize];
    ["Offset of field: VSIFilesystemPluginCallbacksStruct::eof"]
        [::std::mem::offset_of!(VSIFilesystemPluginCallbacksStruct, eof) - 52usize];
    ["Offset of field: VSIFilesystemPluginCallbacksStruct::write"]
        [::std::mem::offset_of!(VSIFilesystemPluginCallbacksStruct, write) - 56usize];
    ["Offset of field: VSIFilesystemPluginCallbacksStruct::flush"]
        [::std::mem::offset_of!(VSIFilesystemPluginCallbacksStruct, flush) - 60usize];
    ["Offset of field: VSIFilesystemPluginCallbacksStruct::truncate"]
        [::std::mem::offset_of!(VSIFilesystemPluginCallbacksStruct, truncate) - 64usize];
    ["Offset of field: VSIFilesystemPluginCallbacksStruct::close"]
        [::std::mem::offset_of!(VSIFilesystemPluginCallbacksStruct, close) - 68usize];
    ["Offset of field: VSIFilesystemPluginCallbacksStruct::nBufferSize"]
        [::std::mem::offset_of!(VSIFilesystemPluginCallbacksStruct, nBufferSize) - 72usize];
    ["Offset of field: VSIFilesystemPluginCallbacksStruct::nCacheSize"]
        [::std::mem::offset_of!(VSIFilesystemPluginCallbacksStruct, nCacheSize) - 76usize];
    ["Offset of field: VSIFilesystemPluginCallbacksStruct::sibling_files"]
        [::std::mem::offset_of!(VSIFilesystemPluginCallbacksStruct, sibling_files) - 80usize];
};
extern "C" {
    #[doc = " return a VSIFilesystemPluginCallbacksStruct to be populated at runtime with handler callbacks\n @since GDAL 3.0"]
    pub fn VSIAllocFilesystemPluginCallbacksStruct() -> *mut VSIFilesystemPluginCallbacksStruct;
}
extern "C" {
    #[doc = " free resources allocated by VSIAllocFilesystemPluginCallbacksStruct\n @since GDAL 3.0"]
    pub fn VSIFreeFilesystemPluginCallbacksStruct(poCb: *mut VSIFilesystemPluginCallbacksStruct);
}
extern "C" {
    #[doc = " register a handler on the given prefix. All IO on datasets opened with the filename /prefix/xxxxxx\n will go through these callbacks.\n pszPrefix must begin and end with a '/'\n @since GDAL 3.0"]
    pub fn VSIInstallPluginHandler(
        pszPrefix: *const ::std::ffi::c_char,
        poCb: *const VSIFilesystemPluginCallbacksStruct,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    #[doc = " @cond Doxygen_Suppress"]
    pub fn VSITime(arg1: *mut ::std::ffi::c_ulong) -> ::std::ffi::c_ulong;
}
extern "C" {
    pub fn VSICTime(arg1: ::std::ffi::c_ulong) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn VSIGMTime(pnTime: *const time_t, poBrokenTime: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn VSILocalTime(pnTime: *const time_t, poBrokenTime: *mut tm) -> *mut tm;
}
pub mod CPLErr {
    #[doc = " Error category"]
    pub type Type = ::std::ffi::c_uint;
    pub const CE_None: Type = 0;
    pub const CE_Debug: Type = 1;
    pub const CE_Warning: Type = 2;
    pub const CE_Failure: Type = 3;
    pub const CE_Fatal: Type = 4;
}
#[doc = " Error number"]
pub type CPLErrorNum = ::std::ffi::c_int;
extern "C" {
    pub fn CPLError(
        eErrClass: CPLErr::Type,
        err_no: CPLErrorNum,
        fmt: *const ::std::ffi::c_char,
        ...
    );
}
extern "C" {
    pub fn CPLErrorV(
        arg1: CPLErr::Type,
        arg2: CPLErrorNum,
        arg3: *const ::std::ffi::c_char,
        arg4: va_list,
    );
}
extern "C" {
    pub fn CPLEmergencyError(arg1: *const ::std::ffi::c_char) -> !;
}
extern "C" {
    pub fn CPLErrorReset();
}
extern "C" {
    pub fn CPLGetLastErrorNo() -> CPLErrorNum;
}
extern "C" {
    pub fn CPLGetLastErrorType() -> CPLErr::Type;
}
extern "C" {
    pub fn CPLGetLastErrorMsg() -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn CPLGetErrorCounter() -> GUInt32;
}
extern "C" {
    pub fn CPLGetErrorHandlerUserData() -> *mut ::std::ffi::c_void;
}
extern "C" {
    pub fn CPLErrorSetState(
        eErrClass: CPLErr::Type,
        err_no: CPLErrorNum,
        pszMsg: *const ::std::ffi::c_char,
    );
}
extern "C" {
    #[doc = " @cond Doxygen_Suppress"]
    pub fn CPLCleanupErrorMutex();
}
#[doc = " Callback for a custom error handler"]
pub type CPLErrorHandler = ::std::option::Option<
    unsafe extern "C" fn(arg1: CPLErr::Type, arg2: CPLErrorNum, arg3: *const ::std::ffi::c_char),
>;
extern "C" {
    pub fn CPLLoggingErrorHandler(
        arg1: CPLErr::Type,
        arg2: CPLErrorNum,
        arg3: *const ::std::ffi::c_char,
    );
}
extern "C" {
    pub fn CPLDefaultErrorHandler(
        arg1: CPLErr::Type,
        arg2: CPLErrorNum,
        arg3: *const ::std::ffi::c_char,
    );
}
extern "C" {
    pub fn CPLQuietErrorHandler(
        arg1: CPLErr::Type,
        arg2: CPLErrorNum,
        arg3: *const ::std::ffi::c_char,
    );
}
extern "C" {
    pub fn CPLTurnFailureIntoWarning(bOn: ::std::ffi::c_int);
}
extern "C" {
    pub fn CPLSetErrorHandler(arg1: CPLErrorHandler) -> CPLErrorHandler;
}
extern "C" {
    pub fn CPLSetErrorHandlerEx(
        arg1: CPLErrorHandler,
        arg2: *mut ::std::ffi::c_void,
    ) -> CPLErrorHandler;
}
extern "C" {
    pub fn CPLPushErrorHandler(arg1: CPLErrorHandler);
}
extern "C" {
    pub fn CPLPushErrorHandlerEx(arg1: CPLErrorHandler, arg2: *mut ::std::ffi::c_void);
}
extern "C" {
    pub fn CPLSetCurrentErrorHandlerCatchDebug(bCatchDebug: ::std::ffi::c_int);
}
extern "C" {
    pub fn CPLPopErrorHandler();
}
extern "C" {
    pub fn CPLDebug(arg1: *const ::std::ffi::c_char, arg2: *const ::std::ffi::c_char, ...);
}
extern "C" {
    #[doc = " @cond Doxygen_Suppress"]
    pub fn CPLVerifyConfiguration();
}
extern "C" {
    #[doc = " @endcond"]
    pub fn CPLGetConfigOption(
        arg1: *const ::std::ffi::c_char,
        arg2: *const ::std::ffi::c_char,
    ) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn CPLGetThreadLocalConfigOption(
        arg1: *const ::std::ffi::c_char,
        arg2: *const ::std::ffi::c_char,
    ) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn CPLSetConfigOption(arg1: *const ::std::ffi::c_char, arg2: *const ::std::ffi::c_char);
}
extern "C" {
    pub fn CPLSetThreadLocalConfigOption(
        pszKey: *const ::std::ffi::c_char,
        pszValue: *const ::std::ffi::c_char,
    );
}
extern "C" {
    #[doc = " @cond Doxygen_Suppress"]
    pub fn CPLFreeConfig();
}
extern "C" {
    #[doc = " @endcond"]
    pub fn CPLGetConfigOptions() -> *mut *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn CPLSetConfigOptions(papszConfigOptions: *const *const ::std::ffi::c_char);
}
extern "C" {
    pub fn CPLGetThreadLocalConfigOptions() -> *mut *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn CPLSetThreadLocalConfigOptions(papszConfigOptions: *const *const ::std::ffi::c_char);
}
extern "C" {
    pub fn CPLLoadConfigOptionsFromFile(
        pszFilename: *const ::std::ffi::c_char,
        bOverrideEnvVars: ::std::ffi::c_int,
    );
}
extern "C" {
    pub fn CPLLoadConfigOptionsFromPredefinedFiles();
}
extern "C" {
    pub fn CPLMalloc(arg1: usize) -> *mut ::std::ffi::c_void;
}
extern "C" {
    pub fn CPLCalloc(arg1: usize, arg2: usize) -> *mut ::std::ffi::c_void;
}
extern "C" {
    pub fn CPLRealloc(arg1: *mut ::std::ffi::c_void, arg2: usize) -> *mut ::std::ffi::c_void;
}
extern "C" {
    pub fn CPLStrdup(arg1: *const ::std::ffi::c_char) -> *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn CPLStrlwr(arg1: *mut ::std::ffi::c_char) -> *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn CPLFGets(
        arg1: *mut ::std::ffi::c_char,
        arg2: ::std::ffi::c_int,
        arg3: *mut FILE,
    ) -> *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn CPLReadLine(arg1: *mut FILE) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn CPLReadLineL(arg1: *mut VSILFILE) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn CPLReadLine2L(
        arg1: *mut VSILFILE,
        arg2: ::std::ffi::c_int,
        arg3: CSLConstList,
    ) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn CPLReadLine3L(
        arg1: *mut VSILFILE,
        arg2: ::std::ffi::c_int,
        arg3: *mut ::std::ffi::c_int,
        arg4: CSLConstList,
    ) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn CPLAtof(arg1: *const ::std::ffi::c_char) -> f64;
}
extern "C" {
    pub fn CPLAtofDelim(arg1: *const ::std::ffi::c_char, arg2: ::std::ffi::c_char) -> f64;
}
extern "C" {
    pub fn CPLStrtod(arg1: *const ::std::ffi::c_char, arg2: *mut *mut ::std::ffi::c_char) -> f64;
}
extern "C" {
    pub fn CPLStrtodDelim(
        arg1: *const ::std::ffi::c_char,
        arg2: *mut *mut ::std::ffi::c_char,
        arg3: ::std::ffi::c_char,
    ) -> f64;
}
extern "C" {
    pub fn CPLStrtof(arg1: *const ::std::ffi::c_char, arg2: *mut *mut ::std::ffi::c_char) -> f32;
}
extern "C" {
    pub fn CPLStrtofDelim(
        arg1: *const ::std::ffi::c_char,
        arg2: *mut *mut ::std::ffi::c_char,
        arg3: ::std::ffi::c_char,
    ) -> f32;
}
extern "C" {
    pub fn CPLAtofM(arg1: *const ::std::ffi::c_char) -> f64;
}
extern "C" {
    pub fn CPLScanString(
        arg1: *const ::std::ffi::c_char,
        arg2: ::std::ffi::c_int,
        arg3: ::std::ffi::c_int,
        arg4: ::std::ffi::c_int,
    ) -> *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn CPLScanDouble(arg1: *const ::std::ffi::c_char, arg2: ::std::ffi::c_int) -> f64;
}
extern "C" {
    pub fn CPLScanLong(
        arg1: *const ::std::ffi::c_char,
        arg2: ::std::ffi::c_int,
    ) -> ::std::ffi::c_long;
}
extern "C" {
    pub fn CPLScanULong(
        arg1: *const ::std::ffi::c_char,
        arg2: ::std::ffi::c_int,
    ) -> ::std::ffi::c_ulong;
}
extern "C" {
    pub fn CPLScanUIntBig(arg1: *const ::std::ffi::c_char, arg2: ::std::ffi::c_int) -> GUIntBig;
}
extern "C" {
    pub fn CPLAtoGIntBig(pszString: *const ::std::ffi::c_char) -> GIntBig;
}
extern "C" {
    pub fn CPLAtoGIntBigEx(
        pszString: *const ::std::ffi::c_char,
        bWarn: ::std::ffi::c_int,
        pbOverflow: *mut ::std::ffi::c_int,
    ) -> GIntBig;
}
extern "C" {
    pub fn CPLScanPointer(
        arg1: *const ::std::ffi::c_char,
        arg2: ::std::ffi::c_int,
    ) -> *mut ::std::ffi::c_void;
}
extern "C" {
    pub fn CPLPrintString(
        arg1: *mut ::std::ffi::c_char,
        arg2: *const ::std::ffi::c_char,
        arg3: ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn CPLPrintStringFill(
        arg1: *mut ::std::ffi::c_char,
        arg2: *const ::std::ffi::c_char,
        arg3: ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn CPLPrintInt32(
        arg1: *mut ::std::ffi::c_char,
        arg2: GInt32,
        arg3: ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn CPLPrintUIntBig(
        arg1: *mut ::std::ffi::c_char,
        arg2: GUIntBig,
        arg3: ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn CPLPrintDouble(
        arg1: *mut ::std::ffi::c_char,
        arg2: *const ::std::ffi::c_char,
        arg3: f64,
        arg4: *const ::std::ffi::c_char,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn CPLPrintTime(
        arg1: *mut ::std::ffi::c_char,
        arg2: ::std::ffi::c_int,
        arg3: *const ::std::ffi::c_char,
        arg4: *const tm,
        arg5: *const ::std::ffi::c_char,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn CPLPrintPointer(
        arg1: *mut ::std::ffi::c_char,
        arg2: *mut ::std::ffi::c_void,
        arg3: ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn CPLGetSymbol(
        arg1: *const ::std::ffi::c_char,
        arg2: *const ::std::ffi::c_char,
    ) -> *mut ::std::ffi::c_void;
}
extern "C" {
    pub fn CPLGetExecPath(
        pszPathBuf: *mut ::std::ffi::c_char,
        nMaxLength: ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn CPLGetPath(arg1: *const ::std::ffi::c_char) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn CPLGetDirname(arg1: *const ::std::ffi::c_char) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn CPLGetFilename(arg1: *const ::std::ffi::c_char) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn CPLGetBasename(arg1: *const ::std::ffi::c_char) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn CPLGetExtension(arg1: *const ::std::ffi::c_char) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn CPLGetCurrentDir() -> *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn CPLFormFilename(
        pszPath: *const ::std::ffi::c_char,
        pszBasename: *const ::std::ffi::c_char,
        pszExtension: *const ::std::ffi::c_char,
    ) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn CPLFormCIFilename(
        pszPath: *const ::std::ffi::c_char,
        pszBasename: *const ::std::ffi::c_char,
        pszExtension: *const ::std::ffi::c_char,
    ) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn CPLResetExtension(
        arg1: *const ::std::ffi::c_char,
        arg2: *const ::std::ffi::c_char,
    ) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn CPLProjectRelativeFilename(
        pszProjectDir: *const ::std::ffi::c_char,
        pszSecondaryFilename: *const ::std::ffi::c_char,
    ) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn CPLIsFilenameRelative(pszFilename: *const ::std::ffi::c_char) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn CPLExtractRelativePath(
        arg1: *const ::std::ffi::c_char,
        arg2: *const ::std::ffi::c_char,
        arg3: *mut ::std::ffi::c_int,
    ) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn CPLCleanTrailingSlash(arg1: *const ::std::ffi::c_char) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn CPLCorrespondingPaths(
        pszOldFilename: *const ::std::ffi::c_char,
        pszNewFilename: *const ::std::ffi::c_char,
        papszFileList: *mut *mut ::std::ffi::c_char,
    ) -> *mut *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn CPLCheckForFile(
        pszFilename: *mut ::std::ffi::c_char,
        papszSiblingList: *mut *mut ::std::ffi::c_char,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn CPLGenerateTempFilename(pszStem: *const ::std::ffi::c_char)
        -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn CPLExpandTilde(pszFilename: *const ::std::ffi::c_char) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn CPLGetHomeDir() -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn CPLLaunderForFilename(
        pszName: *const ::std::ffi::c_char,
        pszOutputPath: *const ::std::ffi::c_char,
    ) -> *const ::std::ffi::c_char;
}
#[doc = " Callback for CPLPushFileFinder"]
pub type CPLFileFinder = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::ffi::c_char,
        arg2: *const ::std::ffi::c_char,
    ) -> *const ::std::ffi::c_char,
>;
extern "C" {
    pub fn CPLFindFile(
        pszClass: *const ::std::ffi::c_char,
        pszBasename: *const ::std::ffi::c_char,
    ) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn CPLDefaultFindFile(
        pszClass: *const ::std::ffi::c_char,
        pszBasename: *const ::std::ffi::c_char,
    ) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn CPLPushFileFinder(pfnFinder: CPLFileFinder);
}
extern "C" {
    pub fn CPLPopFileFinder() -> CPLFileFinder;
}
extern "C" {
    pub fn CPLPushFinderLocation(arg1: *const ::std::ffi::c_char);
}
extern "C" {
    pub fn CPLPopFinderLocation();
}
extern "C" {
    pub fn CPLFinderClean();
}
extern "C" {
    pub fn CPLStat(arg1: *const ::std::ffi::c_char, arg2: *mut VSIStatBuf) -> ::std::ffi::c_int;
}
#[doc = " Information on a shared file"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CPLSharedFileInfo {
    #[doc = "< File pointer"]
    pub fp: *mut FILE,
    #[doc = "< Reference counter"]
    pub nRefCount: ::std::ffi::c_int,
    #[doc = "< Whether fp must be interpreted as VSIFILE*"]
    pub bLarge: ::std::ffi::c_int,
    #[doc = "< Filename"]
    pub pszFilename: *mut ::std::ffi::c_char,
    #[doc = "< Access mode"]
    pub pszAccess: *mut ::std::ffi::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CPLSharedFileInfo"][::std::mem::size_of::<CPLSharedFileInfo>() - 20usize];
    ["Alignment of CPLSharedFileInfo"][::std::mem::align_of::<CPLSharedFileInfo>() - 4usize];
    ["Offset of field: CPLSharedFileInfo::fp"]
        [::std::mem::offset_of!(CPLSharedFileInfo, fp) - 0usize];
    ["Offset of field: CPLSharedFileInfo::nRefCount"]
        [::std::mem::offset_of!(CPLSharedFileInfo, nRefCount) - 4usize];
    ["Offset of field: CPLSharedFileInfo::bLarge"]
        [::std::mem::offset_of!(CPLSharedFileInfo, bLarge) - 8usize];
    ["Offset of field: CPLSharedFileInfo::pszFilename"]
        [::std::mem::offset_of!(CPLSharedFileInfo, pszFilename) - 12usize];
    ["Offset of field: CPLSharedFileInfo::pszAccess"]
        [::std::mem::offset_of!(CPLSharedFileInfo, pszAccess) - 16usize];
};
extern "C" {
    pub fn CPLOpenShared(
        arg1: *const ::std::ffi::c_char,
        arg2: *const ::std::ffi::c_char,
        arg3: ::std::ffi::c_int,
    ) -> *mut FILE;
}
extern "C" {
    pub fn CPLCloseShared(arg1: *mut FILE);
}
extern "C" {
    pub fn CPLGetSharedList(arg1: *mut ::std::ffi::c_int) -> *mut CPLSharedFileInfo;
}
extern "C" {
    pub fn CPLDumpSharedList(arg1: *mut FILE);
}
extern "C" {
    #[doc = " @cond Doxygen_Suppress"]
    pub fn CPLCleanupSharedFileMutex();
}
extern "C" {
    #[doc = " @endcond"]
    pub fn CPLDMSToDec(is: *const ::std::ffi::c_char) -> f64;
}
extern "C" {
    pub fn CPLDecToDMS(
        dfAngle: f64,
        pszAxis: *const ::std::ffi::c_char,
        nPrecision: ::std::ffi::c_int,
    ) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn CPLPackedDMSToDec(arg1: f64) -> f64;
}
extern "C" {
    pub fn CPLDecToPackedDMS(dfDec: f64) -> f64;
}
extern "C" {
    pub fn CPLStringToComplex(
        pszString: *const ::std::ffi::c_char,
        pdfReal: *mut f64,
        pdfImag: *mut f64,
    );
}
extern "C" {
    pub fn CPLUnlinkTree(arg1: *const ::std::ffi::c_char) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn CPLCopyFile(
        pszNewPath: *const ::std::ffi::c_char,
        pszOldPath: *const ::std::ffi::c_char,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn CPLCopyTree(
        pszNewPath: *const ::std::ffi::c_char,
        pszOldPath: *const ::std::ffi::c_char,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn CPLMoveFile(
        pszNewPath: *const ::std::ffi::c_char,
        pszOldPath: *const ::std::ffi::c_char,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn CPLSymlink(
        pszOldPath: *const ::std::ffi::c_char,
        pszNewPath: *const ::std::ffi::c_char,
        papszOptions: CSLConstList,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    #[doc = " @endcond"]
    pub fn CPLCreateZip(
        pszZipFilename: *const ::std::ffi::c_char,
        papszOptions: *mut *mut ::std::ffi::c_char,
    ) -> *mut ::std::ffi::c_void;
}
extern "C" {
    pub fn CPLCreateFileInZip(
        hZip: *mut ::std::ffi::c_void,
        pszFilename: *const ::std::ffi::c_char,
        papszOptions: *mut *mut ::std::ffi::c_char,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn CPLWriteFileInZip(
        hZip: *mut ::std::ffi::c_void,
        pBuffer: *const ::std::ffi::c_void,
        nBufferSize: ::std::ffi::c_int,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn CPLCloseFileInZip(hZip: *mut ::std::ffi::c_void) -> CPLErr::Type;
}
extern "C" {
    pub fn CPLCloseZip(hZip: *mut ::std::ffi::c_void) -> CPLErr::Type;
}
extern "C" {
    pub fn CPLZLibDeflate(
        ptr: *const ::std::ffi::c_void,
        nBytes: usize,
        nLevel: ::std::ffi::c_int,
        outptr: *mut ::std::ffi::c_void,
        nOutAvailableBytes: usize,
        pnOutBytes: *mut usize,
    ) -> *mut ::std::ffi::c_void;
}
extern "C" {
    pub fn CPLZLibInflate(
        ptr: *const ::std::ffi::c_void,
        nBytes: usize,
        outptr: *mut ::std::ffi::c_void,
        nOutAvailableBytes: usize,
        pnOutBytes: *mut usize,
    ) -> *mut ::std::ffi::c_void;
}
extern "C" {
    pub fn CPLValidateXML(
        pszXMLFilename: *const ::std::ffi::c_char,
        pszXSDFilename: *const ::std::ffi::c_char,
        papszOptions: CSLConstList,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn CPLsetlocale(
        category: ::std::ffi::c_int,
        locale: *const ::std::ffi::c_char,
    ) -> *mut ::std::ffi::c_char;
}
extern "C" {
    #[doc = " @cond Doxygen_Suppress"]
    pub fn CPLCleanupSetlocaleMutex();
}
extern "C" {
    #[doc = "CPLIsPowerOfTwo()\n@param i - tested number\n@return TRUE if i is power of two otherwise return FALSE"]
    pub fn CPLIsPowerOfTwo(i: ::std::ffi::c_uint) -> ::std::ffi::c_int;
}
extern "C" {
    #[doc = " \\file cpl_string.h\n\n Various convenience functions for working with strings and string lists.\n\n A StringList is just an array of strings with the last pointer being\n NULL.  An empty StringList may be either a NULL pointer, or a pointer to\n a pointer memory location with a NULL value.\n\n A common convention for StringLists is to use them to store name/value\n lists.  In this case the contents are treated like a dictionary of\n name/value pairs.  The actual data is formatted with each string having\n the format \"<name>:<value>\" (though \"=\" is also an acceptable separator).\n A number of the functions in the file operate on name/value style\n string lists (such as CSLSetNameValue(), and CSLFetchNameValue()).\n\n To some extent the CPLStringList C++ class can be used to abstract\n managing string lists a bit but still be able to return them from C\n functions.\n"]
    pub fn CSLAddString(
        papszStrList: *mut *mut ::std::ffi::c_char,
        pszNewString: *const ::std::ffi::c_char,
    ) -> *mut *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn CSLAddStringMayFail(
        papszStrList: *mut *mut ::std::ffi::c_char,
        pszNewString: *const ::std::ffi::c_char,
    ) -> *mut *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn CSLCount(papszStrList: CSLConstList) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn CSLGetField(arg1: CSLConstList, arg2: ::std::ffi::c_int) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn CSLDestroy(papszStrList: *mut *mut ::std::ffi::c_char);
}
extern "C" {
    pub fn CSLDuplicate(papszStrList: CSLConstList) -> *mut *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn CSLMerge(
        papszOrig: *mut *mut ::std::ffi::c_char,
        papszOverride: CSLConstList,
    ) -> *mut *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn CSLTokenizeString(pszString: *const ::std::ffi::c_char) -> *mut *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn CSLTokenizeStringComplex(
        pszString: *const ::std::ffi::c_char,
        pszDelimiter: *const ::std::ffi::c_char,
        bHonourStrings: ::std::ffi::c_int,
        bAllowEmptyTokens: ::std::ffi::c_int,
    ) -> *mut *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn CSLTokenizeString2(
        pszString: *const ::std::ffi::c_char,
        pszDelimiter: *const ::std::ffi::c_char,
        nCSLTFlags: ::std::ffi::c_int,
    ) -> *mut *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn CSLPrint(papszStrList: CSLConstList, fpOut: *mut FILE) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn CSLLoad(pszFname: *const ::std::ffi::c_char) -> *mut *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn CSLLoad2(
        pszFname: *const ::std::ffi::c_char,
        nMaxLines: ::std::ffi::c_int,
        nMaxCols: ::std::ffi::c_int,
        papszOptions: CSLConstList,
    ) -> *mut *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn CSLSave(
        papszStrList: CSLConstList,
        pszFname: *const ::std::ffi::c_char,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn CSLInsertStrings(
        papszStrList: *mut *mut ::std::ffi::c_char,
        nInsertAtLineNo: ::std::ffi::c_int,
        papszNewLines: CSLConstList,
    ) -> *mut *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn CSLInsertString(
        papszStrList: *mut *mut ::std::ffi::c_char,
        nInsertAtLineNo: ::std::ffi::c_int,
        pszNewLine: *const ::std::ffi::c_char,
    ) -> *mut *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn CSLRemoveStrings(
        papszStrList: *mut *mut ::std::ffi::c_char,
        nFirstLineToDelete: ::std::ffi::c_int,
        nNumToRemove: ::std::ffi::c_int,
        ppapszRetStrings: *mut *mut *mut ::std::ffi::c_char,
    ) -> *mut *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn CSLFindString(
        papszList: CSLConstList,
        pszTarget: *const ::std::ffi::c_char,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn CSLFindStringCaseSensitive(
        papszList: CSLConstList,
        pszTarget: *const ::std::ffi::c_char,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn CSLPartialFindString(
        papszHaystack: CSLConstList,
        pszNeedle: *const ::std::ffi::c_char,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn CSLFindName(
        papszStrList: CSLConstList,
        pszName: *const ::std::ffi::c_char,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn CSLFetchBoolean(
        papszStrList: CSLConstList,
        pszKey: *const ::std::ffi::c_char,
        bDefault: ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn CSLTestBoolean(pszValue: *const ::std::ffi::c_char) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn CPLTestBoolean(pszValue: *const ::std::ffi::c_char) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn CPLTestBool(pszValue: *const ::std::ffi::c_char) -> bool;
}
extern "C" {
    pub fn CPLFetchBool(
        papszStrList: CSLConstList,
        pszKey: *const ::std::ffi::c_char,
        bDefault: bool,
    ) -> bool;
}
extern "C" {
    pub fn CPLParseNameValue(
        pszNameValue: *const ::std::ffi::c_char,
        ppszKey: *mut *mut ::std::ffi::c_char,
    ) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn CSLFetchNameValue(
        papszStrList: CSLConstList,
        pszName: *const ::std::ffi::c_char,
    ) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn CSLFetchNameValueDef(
        papszStrList: CSLConstList,
        pszName: *const ::std::ffi::c_char,
        pszDefault: *const ::std::ffi::c_char,
    ) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn CSLFetchNameValueMultiple(
        papszStrList: CSLConstList,
        pszName: *const ::std::ffi::c_char,
    ) -> *mut *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn CSLAddNameValue(
        papszStrList: *mut *mut ::std::ffi::c_char,
        pszName: *const ::std::ffi::c_char,
        pszValue: *const ::std::ffi::c_char,
    ) -> *mut *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn CSLSetNameValue(
        papszStrList: *mut *mut ::std::ffi::c_char,
        pszName: *const ::std::ffi::c_char,
        pszValue: *const ::std::ffi::c_char,
    ) -> *mut *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn CSLSetNameValueSeparator(
        papszStrList: *mut *mut ::std::ffi::c_char,
        pszSeparator: *const ::std::ffi::c_char,
    );
}
extern "C" {
    pub fn CSLParseCommandLine(
        pszCommandLine: *const ::std::ffi::c_char,
    ) -> *mut *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn CPLEscapeString(
        pszString: *const ::std::ffi::c_char,
        nLength: ::std::ffi::c_int,
        nScheme: ::std::ffi::c_int,
    ) -> *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn CPLUnescapeString(
        pszString: *const ::std::ffi::c_char,
        pnLength: *mut ::std::ffi::c_int,
        nScheme: ::std::ffi::c_int,
    ) -> *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn CPLBinaryToHex(
        nBytes: ::std::ffi::c_int,
        pabyData: *const GByte,
    ) -> *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn CPLHexToBinary(
        pszHex: *const ::std::ffi::c_char,
        pnBytes: *mut ::std::ffi::c_int,
    ) -> *mut GByte;
}
extern "C" {
    pub fn CPLBase64Encode(
        nBytes: ::std::ffi::c_int,
        pabyData: *const GByte,
    ) -> *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn CPLBase64DecodeInPlace(pszBase64: *mut GByte) -> ::std::ffi::c_int;
}
pub mod CPLValueType {
    #[doc = " Type of value"]
    pub type Type = ::std::ffi::c_uint;
    #[doc = "< String"]
    pub const CPL_VALUE_STRING: Type = 0;
    #[doc = "< Real number"]
    pub const CPL_VALUE_REAL: Type = 1;
    #[doc = "< Integer"]
    pub const CPL_VALUE_INTEGER: Type = 2;
}
extern "C" {
    pub fn CPLGetValueType(pszValue: *const ::std::ffi::c_char) -> CPLValueType::Type;
}
extern "C" {
    pub fn CPLStrlcpy(
        pszDest: *mut ::std::ffi::c_char,
        pszSrc: *const ::std::ffi::c_char,
        nDestSize: usize,
    ) -> usize;
}
extern "C" {
    pub fn CPLStrlcat(
        pszDest: *mut ::std::ffi::c_char,
        pszSrc: *const ::std::ffi::c_char,
        nDestSize: usize,
    ) -> usize;
}
extern "C" {
    pub fn CPLStrnlen(pszStr: *const ::std::ffi::c_char, nMaxLen: usize) -> usize;
}
extern "C" {
    pub fn CPLvsnprintf(
        str_: *mut ::std::ffi::c_char,
        size: usize,
        fmt: *const ::std::ffi::c_char,
        args: va_list,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn CPLsnprintf(
        str_: *mut ::std::ffi::c_char,
        size: usize,
        fmt: *const ::std::ffi::c_char,
        ...
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn CPLsprintf(
        str_: *mut ::std::ffi::c_char,
        fmt: *const ::std::ffi::c_char,
        ...
    ) -> ::std::ffi::c_int;
}
extern "C" {
    #[doc = " @endcond"]
    pub fn CPLprintf(fmt: *const ::std::ffi::c_char, ...) -> ::std::ffi::c_int;
}
extern "C" {
    #[doc = " @cond Doxygen_Suppress"]
    pub fn CPLsscanf(
        str_: *const ::std::ffi::c_char,
        fmt: *const ::std::ffi::c_char,
        ...
    ) -> ::std::ffi::c_int;
}
extern "C" {
    #[doc = " @endcond"]
    pub fn CPLSPrintf(fmt: *const ::std::ffi::c_char, ...) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn CSLAppendPrintf(
        papszStrList: *mut *mut ::std::ffi::c_char,
        fmt: *const ::std::ffi::c_char,
        ...
    ) -> *mut *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn CPLVASPrintf(
        buf: *mut *mut ::std::ffi::c_char,
        fmt: *const ::std::ffi::c_char,
        args: va_list,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn CPLEncodingCharSize(pszEncoding: *const ::std::ffi::c_char) -> ::std::ffi::c_int;
}
extern "C" {
    #[doc = " @cond Doxygen_Suppress"]
    pub fn CPLClearRecodeWarningFlags();
}
extern "C" {
    #[doc = " @endcond"]
    pub fn CPLRecode(
        pszSource: *const ::std::ffi::c_char,
        pszSrcEncoding: *const ::std::ffi::c_char,
        pszDstEncoding: *const ::std::ffi::c_char,
    ) -> *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn CPLRecodeFromWChar(
        pwszSource: *const wchar_t,
        pszSrcEncoding: *const ::std::ffi::c_char,
        pszDstEncoding: *const ::std::ffi::c_char,
    ) -> *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn CPLRecodeToWChar(
        pszSource: *const ::std::ffi::c_char,
        pszSrcEncoding: *const ::std::ffi::c_char,
        pszDstEncoding: *const ::std::ffi::c_char,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn CPLIsUTF8(
        pabyData: *const ::std::ffi::c_char,
        nLen: ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn CPLForceToASCII(
        pabyData: *const ::std::ffi::c_char,
        nLen: ::std::ffi::c_int,
        chReplacementChar: ::std::ffi::c_char,
    ) -> *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn CPLStrlenUTF8(pszUTF8Str: *const ::std::ffi::c_char) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn CPLCanRecode(
        pszTestStr: *const ::std::ffi::c_char,
        pszSrcEncoding: *const ::std::ffi::c_char,
        pszDstEncoding: *const ::std::ffi::c_char,
    ) -> ::std::ffi::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CPLHashSet {
    _unused: [u8; 0],
}
#[doc = " Opaque type for a hash set"]
pub type CPLHashSet = _CPLHashSet;
#[doc = " CPLHashSetHashFunc"]
pub type CPLHashSetHashFunc = ::std::option::Option<
    unsafe extern "C" fn(elt: *const ::std::ffi::c_void) -> ::std::ffi::c_ulong,
>;
#[doc = " CPLHashSetEqualFunc"]
pub type CPLHashSetEqualFunc = ::std::option::Option<
    unsafe extern "C" fn(
        elt1: *const ::std::ffi::c_void,
        elt2: *const ::std::ffi::c_void,
    ) -> ::std::ffi::c_int,
>;
#[doc = " CPLHashSetFreeEltFunc"]
pub type CPLHashSetFreeEltFunc =
    ::std::option::Option<unsafe extern "C" fn(elt: *mut ::std::ffi::c_void)>;
#[doc = " CPLHashSetIterEltFunc"]
pub type CPLHashSetIterEltFunc = ::std::option::Option<
    unsafe extern "C" fn(
        elt: *mut ::std::ffi::c_void,
        user_data: *mut ::std::ffi::c_void,
    ) -> ::std::ffi::c_int,
>;
extern "C" {
    pub fn CPLHashSetNew(
        fnHashFunc: CPLHashSetHashFunc,
        fnEqualFunc: CPLHashSetEqualFunc,
        fnFreeEltFunc: CPLHashSetFreeEltFunc,
    ) -> *mut CPLHashSet;
}
extern "C" {
    pub fn CPLHashSetDestroy(set: *mut CPLHashSet);
}
extern "C" {
    pub fn CPLHashSetClear(set: *mut CPLHashSet);
}
extern "C" {
    pub fn CPLHashSetSize(set: *const CPLHashSet) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn CPLHashSetForeach(
        set: *mut CPLHashSet,
        fnIterFunc: CPLHashSetIterEltFunc,
        user_data: *mut ::std::ffi::c_void,
    );
}
extern "C" {
    pub fn CPLHashSetInsert(
        set: *mut CPLHashSet,
        elt: *mut ::std::ffi::c_void,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn CPLHashSetLookup(
        set: *mut CPLHashSet,
        elt: *const ::std::ffi::c_void,
    ) -> *mut ::std::ffi::c_void;
}
extern "C" {
    pub fn CPLHashSetRemove(
        set: *mut CPLHashSet,
        elt: *const ::std::ffi::c_void,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn CPLHashSetRemoveDeferRehash(
        set: *mut CPLHashSet,
        elt: *const ::std::ffi::c_void,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn CPLHashSetHashPointer(elt: *const ::std::ffi::c_void) -> ::std::ffi::c_ulong;
}
extern "C" {
    pub fn CPLHashSetEqualPointer(
        elt1: *const ::std::ffi::c_void,
        elt2: *const ::std::ffi::c_void,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn CPLHashSetHashStr(pszStr: *const ::std::ffi::c_void) -> ::std::ffi::c_ulong;
}
extern "C" {
    pub fn CPLHashSetEqualStr(
        pszStr1: *const ::std::ffi::c_void,
        pszStr2: *const ::std::ffi::c_void,
    ) -> ::std::ffi::c_int;
}
#[doc = " List element structure."]
pub type CPLList = _CPLList;
#[doc = " List element structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CPLList {
    #[doc = " Pointer to the data object. Should be allocated and freed by the\n caller."]
    pub pData: *mut ::std::ffi::c_void,
    #[doc = " Pointer to the next element in list. NULL, if current element is the\n last one."]
    pub psNext: *mut _CPLList,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _CPLList"][::std::mem::size_of::<_CPLList>() - 8usize];
    ["Alignment of _CPLList"][::std::mem::align_of::<_CPLList>() - 4usize];
    ["Offset of field: _CPLList::pData"][::std::mem::offset_of!(_CPLList, pData) - 0usize];
    ["Offset of field: _CPLList::psNext"][::std::mem::offset_of!(_CPLList, psNext) - 4usize];
};
extern "C" {
    pub fn CPLListAppend(psList: *mut CPLList, pData: *mut ::std::ffi::c_void) -> *mut CPLList;
}
extern "C" {
    pub fn CPLListInsert(
        psList: *mut CPLList,
        pData: *mut ::std::ffi::c_void,
        nPosition: ::std::ffi::c_int,
    ) -> *mut CPLList;
}
extern "C" {
    pub fn CPLListGetLast(psList: *mut CPLList) -> *mut CPLList;
}
extern "C" {
    pub fn CPLListGet(psList: *mut CPLList, nPosition: ::std::ffi::c_int) -> *mut CPLList;
}
extern "C" {
    pub fn CPLListCount(psList: *const CPLList) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn CPLListRemove(psList: *mut CPLList, nPosition: ::std::ffi::c_int) -> *mut CPLList;
}
extern "C" {
    pub fn CPLListDestroy(psList: *mut CPLList);
}
extern "C" {
    pub fn CPLListGetNext(psElement: *const CPLList) -> *mut CPLList;
}
extern "C" {
    pub fn CPLListGetData(psElement: *const CPLList) -> *mut ::std::ffi::c_void;
}
pub mod CPLXMLNodeType {
    #[doc = " XML node type"]
    pub type Type = ::std::ffi::c_uint;
    #[doc = " Node is an element"]
    pub const CXT_Element: Type = 0;
    #[doc = " Node is a raw text value"]
    pub const CXT_Text: Type = 1;
    #[doc = " Node is attribute"]
    pub const CXT_Attribute: Type = 2;
    #[doc = " Node is an XML comment."]
    pub const CXT_Comment: Type = 3;
    #[doc = " Node is a special literal"]
    pub const CXT_Literal: Type = 4;
}
#[doc = " Document node structure.\n\n This C structure is used to hold a single text fragment representing a\n component of the document when parsed.   It should be allocated with the\n appropriate CPL function, and freed with CPLDestroyXMLNode().  The structure\n contents should not normally be altered by application code, but may be\n freely examined by application code.\n\n Using the psChild and psNext pointers, a hierarchical tree structure\n for a document can be represented as a tree of CPLXMLNode structures."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CPLXMLNode {
    #[doc = " \\brief Node type\n\n One of CXT_Element, CXT_Text, CXT_Attribute, CXT_Comment,\n or CXT_Literal."]
    pub eType: CPLXMLNodeType::Type,
    #[doc = " \\brief Node value\n\n For CXT_Element this is the name of the element, without the angle\n brackets.  Note there is a single CXT_Element even when the document\n contains a start and end element tag.  The node represents the pair.\n All text or other elements between the start and end tag will appear\n as children nodes of this CXT_Element node.\n\n For CXT_Attribute the pszValue is the attribute name.  The value of\n the attribute will be a CXT_Text child.\n\n For CXT_Text this is the text itself (value of an attribute, or a\n text fragment between an element start and end tags.\n\n For CXT_Literal it is all the literal text.  Currently this is just\n used for !DOCTYPE lines, and the value would be the entire line.\n\n For CXT_Comment the value is all the literal text within the comment,\n but not including the comment start/end indicators (\"<--\" and \"-->\")."]
    pub pszValue: *mut ::std::ffi::c_char,
    #[doc = " \\brief Next sibling.\n\n Pointer to next sibling, that is the next node appearing after this\n one that has the same parent as this node.  NULL if this node is the\n last child of the parent element."]
    pub psNext: *mut CPLXMLNode,
    #[doc = " \\brief Child node.\n\n Pointer to first child node, if any.  Only CXT_Element and CXT_Attribute\n nodes should have children.  For CXT_Attribute it should be a single\n CXT_Text value node, while CXT_Element can have any kind of child.\n The full list of children for a node are identified by walking the\n psNext's starting with the psChild node."]
    pub psChild: *mut CPLXMLNode,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CPLXMLNode"][::std::mem::size_of::<CPLXMLNode>() - 16usize];
    ["Alignment of CPLXMLNode"][::std::mem::align_of::<CPLXMLNode>() - 4usize];
    ["Offset of field: CPLXMLNode::eType"][::std::mem::offset_of!(CPLXMLNode, eType) - 0usize];
    ["Offset of field: CPLXMLNode::pszValue"]
        [::std::mem::offset_of!(CPLXMLNode, pszValue) - 4usize];
    ["Offset of field: CPLXMLNode::psNext"][::std::mem::offset_of!(CPLXMLNode, psNext) - 8usize];
    ["Offset of field: CPLXMLNode::psChild"][::std::mem::offset_of!(CPLXMLNode, psChild) - 12usize];
};
extern "C" {
    pub fn CPLParseXMLString(arg1: *const ::std::ffi::c_char) -> *mut CPLXMLNode;
}
extern "C" {
    pub fn CPLDestroyXMLNode(arg1: *mut CPLXMLNode);
}
extern "C" {
    pub fn CPLGetXMLNode(
        poRoot: *mut CPLXMLNode,
        pszPath: *const ::std::ffi::c_char,
    ) -> *mut CPLXMLNode;
}
extern "C" {
    pub fn CPLSearchXMLNode(
        poRoot: *mut CPLXMLNode,
        pszTarget: *const ::std::ffi::c_char,
    ) -> *mut CPLXMLNode;
}
extern "C" {
    pub fn CPLGetXMLValue(
        poRoot: *const CPLXMLNode,
        pszPath: *const ::std::ffi::c_char,
        pszDefault: *const ::std::ffi::c_char,
    ) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn CPLCreateXMLNode(
        poParent: *mut CPLXMLNode,
        eType: CPLXMLNodeType::Type,
        pszText: *const ::std::ffi::c_char,
    ) -> *mut CPLXMLNode;
}
extern "C" {
    pub fn CPLSerializeXMLTree(psNode: *const CPLXMLNode) -> *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn CPLAddXMLChild(psParent: *mut CPLXMLNode, psChild: *mut CPLXMLNode);
}
extern "C" {
    pub fn CPLRemoveXMLChild(
        psParent: *mut CPLXMLNode,
        psChild: *mut CPLXMLNode,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn CPLAddXMLSibling(psOlderSibling: *mut CPLXMLNode, psNewSibling: *mut CPLXMLNode);
}
extern "C" {
    pub fn CPLCreateXMLElementAndValue(
        psParent: *mut CPLXMLNode,
        pszName: *const ::std::ffi::c_char,
        pszValue: *const ::std::ffi::c_char,
    ) -> *mut CPLXMLNode;
}
extern "C" {
    pub fn CPLAddXMLAttributeAndValue(
        psParent: *mut CPLXMLNode,
        pszName: *const ::std::ffi::c_char,
        pszValue: *const ::std::ffi::c_char,
    );
}
extern "C" {
    pub fn CPLCloneXMLTree(psTree: *const CPLXMLNode) -> *mut CPLXMLNode;
}
extern "C" {
    pub fn CPLSetXMLValue(
        psRoot: *mut CPLXMLNode,
        pszPath: *const ::std::ffi::c_char,
        pszValue: *const ::std::ffi::c_char,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn CPLStripXMLNamespace(
        psRoot: *mut CPLXMLNode,
        pszNameSpace: *const ::std::ffi::c_char,
        bRecurse: ::std::ffi::c_int,
    );
}
extern "C" {
    pub fn CPLCleanXMLElementName(arg1: *mut ::std::ffi::c_char);
}
extern "C" {
    pub fn CPLParseXMLFile(pszFilename: *const ::std::ffi::c_char) -> *mut CPLXMLNode;
}
extern "C" {
    pub fn CPLSerializeXMLTreeToFile(
        psTree: *const CPLXMLNode,
        pszFilename: *const ::std::ffi::c_char,
    ) -> ::std::ffi::c_int;
}
#[doc = " Describe a rectangle"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CPLRectObj {
    #[doc = "< Minimum x"]
    pub minx: f64,
    #[doc = "< Minimum y"]
    pub miny: f64,
    #[doc = "< Maximum x"]
    pub maxx: f64,
    #[doc = "< Maximum y"]
    pub maxy: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CPLRectObj"][::std::mem::size_of::<CPLRectObj>() - 32usize];
    ["Alignment of CPLRectObj"][::std::mem::align_of::<CPLRectObj>() - 4usize];
    ["Offset of field: CPLRectObj::minx"][::std::mem::offset_of!(CPLRectObj, minx) - 0usize];
    ["Offset of field: CPLRectObj::miny"][::std::mem::offset_of!(CPLRectObj, miny) - 8usize];
    ["Offset of field: CPLRectObj::maxx"][::std::mem::offset_of!(CPLRectObj, maxx) - 16usize];
    ["Offset of field: CPLRectObj::maxy"][::std::mem::offset_of!(CPLRectObj, maxy) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CPLQuadTree {
    _unused: [u8; 0],
}
#[doc = " Opaque type for a quad tree"]
pub type CPLQuadTree = _CPLQuadTree;
#[doc = " CPLQuadTreeGetBoundsFunc"]
pub type CPLQuadTreeGetBoundsFunc = ::std::option::Option<
    unsafe extern "C" fn(hFeature: *const ::std::ffi::c_void, pBounds: *mut CPLRectObj),
>;
#[doc = " CPLQuadTreeGetBoundsExFunc"]
pub type CPLQuadTreeGetBoundsExFunc = ::std::option::Option<
    unsafe extern "C" fn(
        hFeature: *const ::std::ffi::c_void,
        pUserData: *mut ::std::ffi::c_void,
        pBounds: *mut CPLRectObj,
    ),
>;
#[doc = " CPLQuadTreeForeachFunc"]
pub type CPLQuadTreeForeachFunc = ::std::option::Option<
    unsafe extern "C" fn(
        pElt: *mut ::std::ffi::c_void,
        pUserData: *mut ::std::ffi::c_void,
    ) -> ::std::ffi::c_int,
>;
#[doc = " CPLQuadTreeDumpFeatureFunc"]
pub type CPLQuadTreeDumpFeatureFunc = ::std::option::Option<
    unsafe extern "C" fn(
        hFeature: *const ::std::ffi::c_void,
        nIndentLevel: ::std::ffi::c_int,
        pUserData: *mut ::std::ffi::c_void,
    ),
>;
extern "C" {
    pub fn CPLQuadTreeCreate(
        pGlobalBounds: *const CPLRectObj,
        pfnGetBounds: CPLQuadTreeGetBoundsFunc,
    ) -> *mut CPLQuadTree;
}
extern "C" {
    pub fn CPLQuadTreeCreateEx(
        pGlobalBounds: *const CPLRectObj,
        pfnGetBounds: CPLQuadTreeGetBoundsExFunc,
        pUserData: *mut ::std::ffi::c_void,
    ) -> *mut CPLQuadTree;
}
extern "C" {
    pub fn CPLQuadTreeDestroy(hQuadtree: *mut CPLQuadTree);
}
extern "C" {
    pub fn CPLQuadTreeSetBucketCapacity(
        hQuadtree: *mut CPLQuadTree,
        nBucketCapacity: ::std::ffi::c_int,
    );
}
extern "C" {
    pub fn CPLQuadTreeForceUseOfSubNodes(hQuadTree: *mut CPLQuadTree);
}
extern "C" {
    pub fn CPLQuadTreeGetAdvisedMaxDepth(nExpectedFeatures: ::std::ffi::c_int)
        -> ::std::ffi::c_int;
}
extern "C" {
    pub fn CPLQuadTreeSetMaxDepth(hQuadtree: *mut CPLQuadTree, nMaxDepth: ::std::ffi::c_int);
}
extern "C" {
    pub fn CPLQuadTreeInsert(hQuadtree: *mut CPLQuadTree, hFeature: *mut ::std::ffi::c_void);
}
extern "C" {
    pub fn CPLQuadTreeInsertWithBounds(
        hQuadtree: *mut CPLQuadTree,
        hFeature: *mut ::std::ffi::c_void,
        psBounds: *const CPLRectObj,
    );
}
extern "C" {
    pub fn CPLQuadTreeRemove(
        hQuadtree: *mut CPLQuadTree,
        hFeature: *mut ::std::ffi::c_void,
        psBounds: *const CPLRectObj,
    );
}
extern "C" {
    pub fn CPLQuadTreeSearch(
        hQuadtree: *const CPLQuadTree,
        pAoi: *const CPLRectObj,
        pnFeatureCount: *mut ::std::ffi::c_int,
    ) -> *mut *mut ::std::ffi::c_void;
}
extern "C" {
    pub fn CPLQuadTreeForeach(
        hQuadtree: *const CPLQuadTree,
        pfnForeach: CPLQuadTreeForeachFunc,
        pUserData: *mut ::std::ffi::c_void,
    );
}
extern "C" {
    pub fn CPLQuadTreeDump(
        hQuadtree: *const CPLQuadTree,
        pfnDumpFeatureFunc: CPLQuadTreeDumpFeatureFunc,
        pUserData: *mut ::std::ffi::c_void,
    );
}
extern "C" {
    pub fn CPLQuadTreeGetStats(
        hQuadtree: *const CPLQuadTree,
        pnFeatureCount: *mut ::std::ffi::c_int,
        pnNodeCount: *mut ::std::ffi::c_int,
        pnMaxDepth: *mut ::std::ffi::c_int,
        pnMaxBucketCapacity: *mut ::std::ffi::c_int,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CPLVirtualMem {
    _unused: [u8; 0],
}
#[doc = " Callback triggered when a still unmapped page of virtual memory is accessed.\n The callback has the responsibility of filling the page with relevant values\n\n @param ctxt virtual memory handle.\n @param nOffset offset of the page in the memory mapping.\n @param pPageToFill address of the page to fill. Note that the address might\n                    be a temporary location, and not at CPLVirtualMemGetAddr() + nOffset.\n @param nToFill number of bytes of the page.\n @param pUserData user data that was passed to CPLVirtualMemNew()."]
pub type CPLVirtualMemCachePageCbk = ::std::option::Option<
    unsafe extern "C" fn(
        ctxt: *mut CPLVirtualMem,
        nOffset: usize,
        pPageToFill: *mut ::std::ffi::c_void,
        nToFill: usize,
        pUserData: *mut ::std::ffi::c_void,
    ),
>;
#[doc = " Callback triggered when a dirty mapped page is going to be freed.\n (saturation of cache, or termination of the virtual memory mapping).\n\n @param ctxt virtual memory handle.\n @param nOffset offset of the page in the memory mapping.\n @param pPageToBeEvicted address of the page that will be flushed. Note that the address might\n                    be a temporary location, and not at CPLVirtualMemGetAddr() + nOffset.\n @param nToBeEvicted number of bytes of the page.\n @param pUserData user data that was passed to CPLVirtualMemNew()."]
pub type CPLVirtualMemUnCachePageCbk = ::std::option::Option<
    unsafe extern "C" fn(
        ctxt: *mut CPLVirtualMem,
        nOffset: usize,
        pPageToBeEvicted: *const ::std::ffi::c_void,
        nToBeEvicted: usize,
        pUserData: *mut ::std::ffi::c_void,
    ),
>;
#[doc = " Callback triggered when a virtual memory mapping is destroyed.\n @param pUserData user data that was passed to CPLVirtualMemNew()."]
pub type CPLVirtualMemFreeUserData =
    ::std::option::Option<unsafe extern "C" fn(pUserData: *mut ::std::ffi::c_void)>;
pub mod CPLVirtualMemAccessMode {
    #[doc = " Access mode of a virtual memory mapping."]
    pub type Type = ::std::ffi::c_uint;
    #[doc = " The mapping is meant at being read-only, but writes will not be prevented.\nNote that any content written will be lost."]
    pub const VIRTUALMEM_READONLY: Type = 0;
    #[doc = " The mapping is meant at being read-only, and this will be enforced\nthrough the operating system page protection mechanism."]
    pub const VIRTUALMEM_READONLY_ENFORCED: Type = 1;
    #[doc = " The mapping is meant at being read-write, and modified pages can be saved\nthanks to the pfnUnCachePage callback"]
    pub const VIRTUALMEM_READWRITE: Type = 2;
}
extern "C" {
    #[doc = " Return the size of a page of virtual memory.\n\n @return the page size.\n\n @since GDAL 1.11"]
    pub fn CPLGetPageSize() -> usize;
}
extern "C" {
    #[doc = " Create a new virtual memory mapping.\n\n This will reserve an area of virtual memory of size nSize, whose size\n might be potentially much larger than the physical memory available. Initially,\n no physical memory will be allocated. As soon as memory pages will be accessed,\n they will be allocated transparently and filled with the pfnCachePage callback.\n When the allowed cache size is reached, the least recently used pages will\n be unallocated.\n\n On Linux AMD64 platforms, the maximum value for nSize is 128 TB.\n On Linux x86 platforms, the maximum value for nSize is 2 GB.\n\n Only supported on Linux for now.\n\n Note that on Linux, this function will install a SIGSEGV handler. The\n original handler will be restored by CPLVirtualMemManagerTerminate().\n\n @param nSize size in bytes of the virtual memory mapping.\n @param nCacheSize   size in bytes of the maximum memory that will be really\n                     allocated (must ideally fit into RAM).\n @param nPageSizeHint hint for the page size. Must be a multiple of the\n                      system page size, returned by CPLGetPageSize().\n                      Minimum value is generally 4096. Might be set to 0 to\n                      let the function determine a default page size.\n @param bSingleThreadUsage set to TRUE if there will be no concurrent threads\n                           that will access the virtual memory mapping. This can\n                           optimize performance a bit.\n @param eAccessMode permission to use for the virtual memory mapping.\n @param pfnCachePage callback triggered when a still unmapped page of virtual\n                     memory is accessed. The callback has the responsibility\n                     of filling the page with relevant values.\n @param pfnUnCachePage callback triggered when a dirty mapped page is going to\n                       be freed (saturation of cache, or termination of the\n                       virtual memory mapping). Might be NULL.\n @param pfnFreeUserData callback that can be used to free pCbkUserData. Might be\n                        NULL\n @param pCbkUserData user data passed to pfnCachePage and pfnUnCachePage.\n\n @return a virtual memory object that must be freed by CPLVirtualMemFree(),\n         or NULL in case of failure.\n\n @since GDAL 1.11"]
    pub fn CPLVirtualMemNew(
        nSize: usize,
        nCacheSize: usize,
        nPageSizeHint: usize,
        bSingleThreadUsage: ::std::ffi::c_int,
        eAccessMode: CPLVirtualMemAccessMode::Type,
        pfnCachePage: CPLVirtualMemCachePageCbk,
        pfnUnCachePage: CPLVirtualMemUnCachePageCbk,
        pfnFreeUserData: CPLVirtualMemFreeUserData,
        pCbkUserData: *mut ::std::ffi::c_void,
    ) -> *mut CPLVirtualMem;
}
extern "C" {
    #[doc = " Return if virtual memory mapping of a file is available.\n\n @return TRUE if virtual memory mapping of a file is available.\n @since GDAL 1.11"]
    pub fn CPLIsVirtualMemFileMapAvailable() -> ::std::ffi::c_int;
}
extern "C" {
    #[doc = " Create a new virtual memory mapping from a file.\n\n The file must be a \"real\" file recognized by the operating system, and not\n a VSI extended virtual file.\n\n In VIRTUALMEM_READWRITE mode, updates to the memory mapping will be written\n in the file.\n\n On Linux AMD64 platforms, the maximum value for nLength is 128 TB.\n On Linux x86 platforms, the maximum value for nLength is 2 GB.\n\n Supported on Linux only in GDAL <= 2.0, and all POSIX systems supporting\n mmap() in GDAL >= 2.1\n\n @param  fp       Virtual file handle.\n @param  nOffset  Offset in the file to start the mapping from.\n @param  nLength  Length of the portion of the file to map into memory.\n @param eAccessMode Permission to use for the virtual memory mapping. This must\n                    be consistent with how the file has been opened.\n @param pfnFreeUserData callback that is called when the object is destroyed.\n @param pCbkUserData user data passed to pfnFreeUserData.\n @return a virtual memory object that must be freed by CPLVirtualMemFree(),\n         or NULL in case of failure.\n\n @since GDAL 1.11"]
    pub fn CPLVirtualMemFileMapNew(
        fp: *mut VSILFILE,
        nOffset: vsi_l_offset,
        nLength: vsi_l_offset,
        eAccessMode: CPLVirtualMemAccessMode::Type,
        pfnFreeUserData: CPLVirtualMemFreeUserData,
        pCbkUserData: *mut ::std::ffi::c_void,
    ) -> *mut CPLVirtualMem;
}
extern "C" {
    #[doc = " Create a new virtual memory mapping derived from an other virtual memory\n  mapping.\n\n This may be useful in case of creating mapping for pixel interleaved data.\n\n The new mapping takes a reference on the base mapping.\n\n @param pVMemBase Base virtual memory mapping\n @param nOffset   Offset in the base virtual memory mapping from which to start\n                  the new mapping.\n @param nSize     Size of the base virtual memory mapping to expose in the\n                  the new mapping.\n @param pfnFreeUserData callback that is called when the object is destroyed.\n @param pCbkUserData user data passed to pfnFreeUserData.\n @return a virtual memory object that must be freed by CPLVirtualMemFree(),\n         or NULL in case of failure.\n\n @since GDAL 1.11"]
    pub fn CPLVirtualMemDerivedNew(
        pVMemBase: *mut CPLVirtualMem,
        nOffset: vsi_l_offset,
        nSize: vsi_l_offset,
        pfnFreeUserData: CPLVirtualMemFreeUserData,
        pCbkUserData: *mut ::std::ffi::c_void,
    ) -> *mut CPLVirtualMem;
}
extern "C" {
    #[doc = " Free a virtual memory mapping.\n\n The pointer returned by CPLVirtualMemGetAddr() will no longer be valid.\n If the virtual memory mapping was created with read/write permissions and that\n they are dirty (i.e. modified) pages, they will be flushed through the\n pfnUnCachePage callback before being freed.\n\n @param ctxt context returned by CPLVirtualMemNew().\n\n @since GDAL 1.11"]
    pub fn CPLVirtualMemFree(ctxt: *mut CPLVirtualMem);
}
extern "C" {
    #[doc = " Return the pointer to the start of a virtual memory mapping.\n\n The bytes in the range [p:p+CPLVirtualMemGetSize()-1] where p is the pointer\n returned by this function will be valid, until CPLVirtualMemFree() is called.\n\n Note that if a range of bytes used as an argument of a system call\n (such as read() or write()) contains pages that have not been \"realized\", the\n system call will fail with EFAULT. CPLVirtualMemPin() can be used to work\n around this issue.\n\n @param ctxt context returned by CPLVirtualMemNew().\n @return the pointer to the start of a virtual memory mapping.\n\n @since GDAL 1.11"]
    pub fn CPLVirtualMemGetAddr(ctxt: *mut CPLVirtualMem) -> *mut ::std::ffi::c_void;
}
extern "C" {
    #[doc = " Return the size of the virtual memory mapping.\n\n @param ctxt context returned by CPLVirtualMemNew().\n @return the size of the virtual memory mapping.\n\n @since GDAL 1.11"]
    pub fn CPLVirtualMemGetSize(ctxt: *mut CPLVirtualMem) -> usize;
}
extern "C" {
    #[doc = " Return if the virtual memory mapping is a direct file mapping.\n\n @param ctxt context returned by CPLVirtualMemNew().\n @return TRUE if the virtual memory mapping is a direct file mapping.\n\n @since GDAL 1.11"]
    pub fn CPLVirtualMemIsFileMapping(ctxt: *mut CPLVirtualMem) -> ::std::ffi::c_int;
}
extern "C" {
    #[doc = " Return the access mode of the virtual memory mapping.\n\n @param ctxt context returned by CPLVirtualMemNew().\n @return the access mode of the virtual memory mapping.\n\n @since GDAL 1.11"]
    pub fn CPLVirtualMemGetAccessMode(ctxt: *mut CPLVirtualMem) -> CPLVirtualMemAccessMode::Type;
}
extern "C" {
    #[doc = " Return the page size associated to a virtual memory mapping.\n\n The value returned will be at least CPLGetPageSize(), but potentially\n larger.\n\n @param ctxt context returned by CPLVirtualMemNew().\n @return the page size\n\n @since GDAL 1.11"]
    pub fn CPLVirtualMemGetPageSize(ctxt: *mut CPLVirtualMem) -> usize;
}
extern "C" {
    #[doc = " Return TRUE if this memory mapping can be accessed safely from concurrent\n  threads.\n\n The situation that can cause problems is when several threads try to access\n a page of the mapping that is not yet mapped.\n\n The return value of this function depends on whether bSingleThreadUsage has\n been set of not in CPLVirtualMemNew() and/or the implementation.\n\n On Linux, this will always return TRUE if bSingleThreadUsage = FALSE.\n\n @param ctxt context returned by CPLVirtualMemNew().\n @return TRUE if this memory mapping can be accessed safely from concurrent\n         threads.\n\n @since GDAL 1.11"]
    pub fn CPLVirtualMemIsAccessThreadSafe(ctxt: *mut CPLVirtualMem) -> ::std::ffi::c_int;
}
extern "C" {
    #[doc = " Declare that a thread will access a virtual memory mapping.\n\n This function must be called by a thread that wants to access the\n content of a virtual memory mapping, except if the virtual memory mapping has\n been created with bSingleThreadUsage = TRUE.\n\n This function must be paired with CPLVirtualMemUnDeclareThread().\n\n @param ctxt context returned by CPLVirtualMemNew().\n\n @since GDAL 1.11"]
    pub fn CPLVirtualMemDeclareThread(ctxt: *mut CPLVirtualMem);
}
extern "C" {
    #[doc = " Declare that a thread will stop accessing a virtual memory mapping.\n\n This function must be called by a thread that will no longer access the\n content of a virtual memory mapping, except if the virtual memory mapping has\n been created with bSingleThreadUsage = TRUE.\n\n This function must be paired with CPLVirtualMemDeclareThread().\n\n @param ctxt context returned by CPLVirtualMemNew().\n\n @since GDAL 1.11"]
    pub fn CPLVirtualMemUnDeclareThread(ctxt: *mut CPLVirtualMem);
}
extern "C" {
    #[doc = " Make sure that a region of virtual memory will be realized.\n\n Calling this function is not required, but might be useful when debugging\n a process with tools like gdb or valgrind that do not naturally like\n segmentation fault signals.\n\n It is also needed when wanting to provide part of virtual memory mapping\n to a system call such as read() or write(). If read() or write() is called\n on a memory region not yet realized, the call will fail with EFAULT.\n\n @param ctxt context returned by CPLVirtualMemNew().\n @param pAddr the memory region to pin.\n @param nSize the size of the memory region.\n @param bWriteOp set to TRUE if the memory are will be accessed in write mode.\n\n @since GDAL 1.11"]
    pub fn CPLVirtualMemPin(
        ctxt: *mut CPLVirtualMem,
        pAddr: *mut ::std::ffi::c_void,
        nSize: usize,
        bWriteOp: ::std::ffi::c_int,
    );
}
extern "C" {
    #[doc = " Cleanup any resource and handlers related to virtual memory.\n\n This function must be called after the last CPLVirtualMem object has\n been freed.\n\n @since GDAL 2.0"]
    pub fn CPLVirtualMemManagerTerminate();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OGREnvelope {
    pub MinX: f64,
    pub MaxX: f64,
    pub MinY: f64,
    pub MaxY: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of OGREnvelope"][::std::mem::size_of::<OGREnvelope>() - 32usize];
    ["Alignment of OGREnvelope"][::std::mem::align_of::<OGREnvelope>() - 4usize];
    ["Offset of field: OGREnvelope::MinX"][::std::mem::offset_of!(OGREnvelope, MinX) - 0usize];
    ["Offset of field: OGREnvelope::MaxX"][::std::mem::offset_of!(OGREnvelope, MaxX) - 8usize];
    ["Offset of field: OGREnvelope::MinY"][::std::mem::offset_of!(OGREnvelope, MinY) - 16usize];
    ["Offset of field: OGREnvelope::MaxY"][::std::mem::offset_of!(OGREnvelope, MaxY) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OGREnvelope3D {
    pub MinX: f64,
    pub MaxX: f64,
    pub MinY: f64,
    pub MaxY: f64,
    pub MinZ: f64,
    pub MaxZ: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of OGREnvelope3D"][::std::mem::size_of::<OGREnvelope3D>() - 48usize];
    ["Alignment of OGREnvelope3D"][::std::mem::align_of::<OGREnvelope3D>() - 4usize];
    ["Offset of field: OGREnvelope3D::MinX"][::std::mem::offset_of!(OGREnvelope3D, MinX) - 0usize];
    ["Offset of field: OGREnvelope3D::MaxX"][::std::mem::offset_of!(OGREnvelope3D, MaxX) - 8usize];
    ["Offset of field: OGREnvelope3D::MinY"][::std::mem::offset_of!(OGREnvelope3D, MinY) - 16usize];
    ["Offset of field: OGREnvelope3D::MaxY"][::std::mem::offset_of!(OGREnvelope3D, MaxY) - 24usize];
    ["Offset of field: OGREnvelope3D::MinZ"][::std::mem::offset_of!(OGREnvelope3D, MinZ) - 32usize];
    ["Offset of field: OGREnvelope3D::MaxZ"][::std::mem::offset_of!(OGREnvelope3D, MaxZ) - 40usize];
};
extern "C" {
    #[doc = " @cond Doxygen_Suppress"]
    pub fn OGRMalloc(arg1: usize) -> *mut ::std::ffi::c_void;
}
extern "C" {
    pub fn OGRCalloc(arg1: usize, arg2: usize) -> *mut ::std::ffi::c_void;
}
extern "C" {
    pub fn OGRRealloc(arg1: *mut ::std::ffi::c_void, arg2: usize) -> *mut ::std::ffi::c_void;
}
extern "C" {
    pub fn OGRStrdup(arg1: *const ::std::ffi::c_char) -> *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn OGRFree(arg1: *mut ::std::ffi::c_void);
}
pub mod OGRwkbGeometryType {
    #[doc = " List of well known binary geometry types.  These are used within the BLOBs\n but are also returned from OGRGeometry::getGeometryType() to identify the\n type of a geometry object."]
    pub type Type = ::std::ffi::c_uint;
    #[doc = "< unknown type, non-standard"]
    pub const wkbUnknown: Type = 0;
    #[doc = "< 0-dimensional geometric object, standard WKB"]
    pub const wkbPoint: Type = 1;
    #[doc = "< 1-dimensional geometric object with linear\n   interpolation between Points, standard WKB"]
    pub const wkbLineString: Type = 2;
    #[doc = "< planar 2-dimensional geometric object defined\n   by 1 exterior boundary and 0 or more interior\n   boundaries, standard WKB"]
    pub const wkbPolygon: Type = 3;
    #[doc = "< GeometryCollection of Points, standard WKB"]
    pub const wkbMultiPoint: Type = 4;
    #[doc = "< GeometryCollection of LineStrings, standard WKB"]
    pub const wkbMultiLineString: Type = 5;
    #[doc = "< GeometryCollection of Polygons, standard WKB"]
    pub const wkbMultiPolygon: Type = 6;
    #[doc = "< geometric object that is a collection of 1\nor more geometric objects, standard WKB"]
    pub const wkbGeometryCollection: Type = 7;
    #[doc = "< one or more circular arc segments connected end to end,\n   ISO SQL/MM Part 3. GDAL &gt;= 2.0"]
    pub const wkbCircularString: Type = 8;
    #[doc = "< sequence of contiguous curves, ISO SQL/MM Part 3. GDAL &gt;= 2.0"]
    pub const wkbCompoundCurve: Type = 9;
    #[doc = "< planar surface, defined by 1 exterior boundary\n   and zero or more interior boundaries, that are curves.\n    ISO SQL/MM Part 3. GDAL &gt;= 2.0"]
    pub const wkbCurvePolygon: Type = 10;
    #[doc = "< GeometryCollection of Curves, ISO SQL/MM Part 3. GDAL &gt;= 2.0"]
    pub const wkbMultiCurve: Type = 11;
    #[doc = "< GeometryCollection of Surfaces, ISO SQL/MM Part 3. GDAL &gt;= 2.0"]
    pub const wkbMultiSurface: Type = 12;
    #[doc = "< Curve (abstract type). ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbCurve: Type = 13;
    #[doc = "< Surface (abstract type). ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbSurface: Type = 14;
    #[doc = "< a contiguous collection of polygons, which share common boundary segments,\n   ISO SQL/MM Part 3. GDAL &gt;= 2.3"]
    pub const wkbPolyhedralSurface: Type = 15;
    #[doc = "< a PolyhedralSurface consisting only of Triangle patches\n    ISO SQL/MM Part 3. GDAL &gt;= 2.3"]
    pub const wkbTIN: Type = 16;
    #[doc = "< a Triangle. ISO SQL/MM Part 3. GDAL &gt;= 2.3"]
    pub const wkbTriangle: Type = 17;
    #[doc = "< non-standard, for pure attribute records"]
    pub const wkbNone: Type = 100;
    #[doc = "< non-standard, just for createGeometry()"]
    pub const wkbLinearRing: Type = 101;
    #[doc = "< wkbCircularString with Z component. ISO SQL/MM Part 3. GDAL &gt;= 2.0"]
    pub const wkbCircularStringZ: Type = 1008;
    #[doc = "< wkbCompoundCurve with Z component. ISO SQL/MM Part 3. GDAL &gt;= 2.0"]
    pub const wkbCompoundCurveZ: Type = 1009;
    #[doc = "< wkbCurvePolygon with Z component. ISO SQL/MM Part 3. GDAL &gt;= 2.0"]
    pub const wkbCurvePolygonZ: Type = 1010;
    #[doc = "< wkbMultiCurve with Z component. ISO SQL/MM Part 3. GDAL &gt;= 2.0"]
    pub const wkbMultiCurveZ: Type = 1011;
    #[doc = "< wkbMultiSurface with Z component. ISO SQL/MM Part 3. GDAL &gt;= 2.0"]
    pub const wkbMultiSurfaceZ: Type = 1012;
    #[doc = "< wkbCurve with Z component. ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbCurveZ: Type = 1013;
    #[doc = "< wkbSurface with Z component. ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbSurfaceZ: Type = 1014;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.3"]
    pub const wkbPolyhedralSurfaceZ: Type = 1015;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.3"]
    pub const wkbTINZ: Type = 1016;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.3"]
    pub const wkbTriangleZ: Type = 1017;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbPointM: Type = 2001;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbLineStringM: Type = 2002;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbPolygonM: Type = 2003;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbMultiPointM: Type = 2004;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbMultiLineStringM: Type = 2005;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbMultiPolygonM: Type = 2006;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbGeometryCollectionM: Type = 2007;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbCircularStringM: Type = 2008;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbCompoundCurveM: Type = 2009;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbCurvePolygonM: Type = 2010;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbMultiCurveM: Type = 2011;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbMultiSurfaceM: Type = 2012;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbCurveM: Type = 2013;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbSurfaceM: Type = 2014;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.3"]
    pub const wkbPolyhedralSurfaceM: Type = 2015;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.3"]
    pub const wkbTINM: Type = 2016;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.3"]
    pub const wkbTriangleM: Type = 2017;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbPointZM: Type = 3001;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbLineStringZM: Type = 3002;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbPolygonZM: Type = 3003;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbMultiPointZM: Type = 3004;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbMultiLineStringZM: Type = 3005;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbMultiPolygonZM: Type = 3006;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbGeometryCollectionZM: Type = 3007;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbCircularStringZM: Type = 3008;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbCompoundCurveZM: Type = 3009;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbCurvePolygonZM: Type = 3010;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbMultiCurveZM: Type = 3011;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbMultiSurfaceZM: Type = 3012;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbCurveZM: Type = 3013;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbSurfaceZM: Type = 3014;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.3"]
    pub const wkbPolyhedralSurfaceZM: Type = 3015;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.3"]
    pub const wkbTINZM: Type = 3016;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.3"]
    pub const wkbTriangleZM: Type = 3017;
    #[doc = "< 2.5D extension as per 99-402"]
    pub const wkbPoint25D: Type = 2147483649;
    #[doc = "< 2.5D extension as per 99-402"]
    pub const wkbLineString25D: Type = 2147483650;
    #[doc = "< 2.5D extension as per 99-402"]
    pub const wkbPolygon25D: Type = 2147483651;
    #[doc = "< 2.5D extension as per 99-402"]
    pub const wkbMultiPoint25D: Type = 2147483652;
    #[doc = "< 2.5D extension as per 99-402"]
    pub const wkbMultiLineString25D: Type = 2147483653;
    #[doc = "< 2.5D extension as per 99-402"]
    pub const wkbMultiPolygon25D: Type = 2147483654;
    #[doc = "< 2.5D extension as per 99-402"]
    pub const wkbGeometryCollection25D: Type = 2147483655;
}
extern "C" {
    pub fn OGRGeometryTypeToName(eType: OGRwkbGeometryType::Type) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn OGRMergeGeometryTypes(
        eMain: OGRwkbGeometryType::Type,
        eExtra: OGRwkbGeometryType::Type,
    ) -> OGRwkbGeometryType::Type;
}
extern "C" {
    pub fn OGRMergeGeometryTypesEx(
        eMain: OGRwkbGeometryType::Type,
        eExtra: OGRwkbGeometryType::Type,
        bAllowPromotingToCurves: ::std::ffi::c_int,
    ) -> OGRwkbGeometryType::Type;
}
extern "C" {
    pub fn OGR_GT_Flatten(eType: OGRwkbGeometryType::Type) -> OGRwkbGeometryType::Type;
}
extern "C" {
    pub fn OGR_GT_SetZ(eType: OGRwkbGeometryType::Type) -> OGRwkbGeometryType::Type;
}
extern "C" {
    pub fn OGR_GT_SetM(eType: OGRwkbGeometryType::Type) -> OGRwkbGeometryType::Type;
}
extern "C" {
    pub fn OGR_GT_SetModifier(
        eType: OGRwkbGeometryType::Type,
        bSetZ: ::std::ffi::c_int,
        bSetM: ::std::ffi::c_int,
    ) -> OGRwkbGeometryType::Type;
}
extern "C" {
    pub fn OGR_GT_HasZ(eType: OGRwkbGeometryType::Type) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_GT_HasM(eType: OGRwkbGeometryType::Type) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_GT_IsSubClassOf(
        eType: OGRwkbGeometryType::Type,
        eSuperType: OGRwkbGeometryType::Type,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_GT_IsCurve(arg1: OGRwkbGeometryType::Type) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_GT_IsSurface(arg1: OGRwkbGeometryType::Type) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_GT_IsNonLinear(arg1: OGRwkbGeometryType::Type) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_GT_GetCollection(eType: OGRwkbGeometryType::Type) -> OGRwkbGeometryType::Type;
}
extern "C" {
    pub fn OGR_GT_GetCurve(eType: OGRwkbGeometryType::Type) -> OGRwkbGeometryType::Type;
}
extern "C" {
    pub fn OGR_GT_GetLinear(eType: OGRwkbGeometryType::Type) -> OGRwkbGeometryType::Type;
}
pub mod OGRwkbByteOrder {
    #[doc = " Enumeration to describe byte order"]
    pub type Type = ::std::ffi::c_uint;
    #[doc = "< MSB/Sun/Motorola: Most Significant Byte First"]
    pub const wkbXDR: Type = 0;
    #[doc = "< LSB/Intel/Vax: Least Significant Byte First"]
    pub const wkbNDR: Type = 1;
}
pub mod OGRFieldType {
    #[doc = " List of feature field types.  This list is likely to be extended in the\n future ... avoid coding applications based on the assumption that all\n field types can be known."]
    pub type Type = ::std::ffi::c_uint;
    #[doc = " Simple 32bit integer"]
    pub const OFTInteger: Type = 0;
    #[doc = " List of 32bit integers"]
    pub const OFTIntegerList: Type = 1;
    #[doc = " Double Precision floating point"]
    pub const OFTReal: Type = 2;
    #[doc = " List of doubles"]
    pub const OFTRealList: Type = 3;
    #[doc = " String of ASCII chars"]
    pub const OFTString: Type = 4;
    #[doc = " Array of strings"]
    pub const OFTStringList: Type = 5;
    #[doc = " deprecated"]
    pub const OFTWideString: Type = 6;
    #[doc = " deprecated"]
    pub const OFTWideStringList: Type = 7;
    #[doc = " Raw Binary data"]
    pub const OFTBinary: Type = 8;
    #[doc = " Date"]
    pub const OFTDate: Type = 9;
    #[doc = " Time"]
    pub const OFTTime: Type = 10;
    #[doc = " Date and Time"]
    pub const OFTDateTime: Type = 11;
    #[doc = " Single 64bit integer"]
    pub const OFTInteger64: Type = 12;
    #[doc = " List of 64bit integers"]
    pub const OFTInteger64List: Type = 13;
    #[doc = " List of 64bit integers"]
    pub const OFTMaxType: Type = 13;
}
pub mod OGRFieldSubType {
    #[doc = " List of field subtypes. A subtype represents a hint, a restriction of the\n main type, that is not strictly necessary to consult.\n This list is likely to be extended in the\n future ... avoid coding applications based on the assumption that all\n field types can be known.\n Most subtypes only make sense for a restricted set of main types.\n @since GDAL 2.0"]
    pub type Type = ::std::ffi::c_uint;
    #[doc = " No subtype. This is the default value"]
    pub const OFSTNone: Type = 0;
    #[doc = " Boolean integer. Only valid for OFTInteger and OFTIntegerList."]
    pub const OFSTBoolean: Type = 1;
    #[doc = " Signed 16-bit integer. Only valid for OFTInteger and OFTIntegerList."]
    pub const OFSTInt16: Type = 2;
    #[doc = " Single precision (32 bit) floating point. Only valid for OFTReal and OFTRealList."]
    pub const OFSTFloat32: Type = 3;
    #[doc = " JSON content. Only valid for OFTString.\n @since GDAL 2.4"]
    pub const OFSTJSON: Type = 4;
    #[doc = " UUID string representation. Only valid for OFTString.\n @since GDAL 3.3"]
    pub const OFSTUUID: Type = 5;
    #[doc = " UUID string representation. Only valid for OFTString.\n @since GDAL 3.3"]
    pub const OFSTMaxSubType: Type = 5;
}
pub mod OGRJustification {
    #[doc = " Display justification for field values."]
    pub type Type = ::std::ffi::c_uint;
    pub const OJUndefined: Type = 0;
    pub const OJLeft: Type = 1;
    pub const OJRight: Type = 2;
}
#[doc = " OGRFeature field attribute value union."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union OGRField {
    #[doc = " @cond Doxygen_Suppress"]
    pub Integer: ::std::ffi::c_int,
    pub Integer64: GIntBig,
    pub Real: f64,
    pub String: *mut ::std::ffi::c_char,
    pub IntegerList: OGRField__bindgen_ty_1,
    pub Integer64List: OGRField__bindgen_ty_2,
    pub RealList: OGRField__bindgen_ty_3,
    pub StringList: OGRField__bindgen_ty_4,
    pub Binary: OGRField__bindgen_ty_5,
    pub Set: OGRField__bindgen_ty_6,
    pub Date: OGRField__bindgen_ty_7,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OGRField__bindgen_ty_1 {
    pub nCount: ::std::ffi::c_int,
    pub paList: *mut ::std::ffi::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of OGRField__bindgen_ty_1"][::std::mem::size_of::<OGRField__bindgen_ty_1>() - 8usize];
    ["Alignment of OGRField__bindgen_ty_1"]
        [::std::mem::align_of::<OGRField__bindgen_ty_1>() - 4usize];
    ["Offset of field: OGRField__bindgen_ty_1::nCount"]
        [::std::mem::offset_of!(OGRField__bindgen_ty_1, nCount) - 0usize];
    ["Offset of field: OGRField__bindgen_ty_1::paList"]
        [::std::mem::offset_of!(OGRField__bindgen_ty_1, paList) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OGRField__bindgen_ty_2 {
    pub nCount: ::std::ffi::c_int,
    pub paList: *mut GIntBig,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of OGRField__bindgen_ty_2"][::std::mem::size_of::<OGRField__bindgen_ty_2>() - 8usize];
    ["Alignment of OGRField__bindgen_ty_2"]
        [::std::mem::align_of::<OGRField__bindgen_ty_2>() - 4usize];
    ["Offset of field: OGRField__bindgen_ty_2::nCount"]
        [::std::mem::offset_of!(OGRField__bindgen_ty_2, nCount) - 0usize];
    ["Offset of field: OGRField__bindgen_ty_2::paList"]
        [::std::mem::offset_of!(OGRField__bindgen_ty_2, paList) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OGRField__bindgen_ty_3 {
    pub nCount: ::std::ffi::c_int,
    pub paList: *mut f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of OGRField__bindgen_ty_3"][::std::mem::size_of::<OGRField__bindgen_ty_3>() - 8usize];
    ["Alignment of OGRField__bindgen_ty_3"]
        [::std::mem::align_of::<OGRField__bindgen_ty_3>() - 4usize];
    ["Offset of field: OGRField__bindgen_ty_3::nCount"]
        [::std::mem::offset_of!(OGRField__bindgen_ty_3, nCount) - 0usize];
    ["Offset of field: OGRField__bindgen_ty_3::paList"]
        [::std::mem::offset_of!(OGRField__bindgen_ty_3, paList) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OGRField__bindgen_ty_4 {
    pub nCount: ::std::ffi::c_int,
    pub paList: *mut *mut ::std::ffi::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of OGRField__bindgen_ty_4"][::std::mem::size_of::<OGRField__bindgen_ty_4>() - 8usize];
    ["Alignment of OGRField__bindgen_ty_4"]
        [::std::mem::align_of::<OGRField__bindgen_ty_4>() - 4usize];
    ["Offset of field: OGRField__bindgen_ty_4::nCount"]
        [::std::mem::offset_of!(OGRField__bindgen_ty_4, nCount) - 0usize];
    ["Offset of field: OGRField__bindgen_ty_4::paList"]
        [::std::mem::offset_of!(OGRField__bindgen_ty_4, paList) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OGRField__bindgen_ty_5 {
    pub nCount: ::std::ffi::c_int,
    pub paData: *mut GByte,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of OGRField__bindgen_ty_5"][::std::mem::size_of::<OGRField__bindgen_ty_5>() - 8usize];
    ["Alignment of OGRField__bindgen_ty_5"]
        [::std::mem::align_of::<OGRField__bindgen_ty_5>() - 4usize];
    ["Offset of field: OGRField__bindgen_ty_5::nCount"]
        [::std::mem::offset_of!(OGRField__bindgen_ty_5, nCount) - 0usize];
    ["Offset of field: OGRField__bindgen_ty_5::paData"]
        [::std::mem::offset_of!(OGRField__bindgen_ty_5, paData) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OGRField__bindgen_ty_6 {
    pub nMarker1: ::std::ffi::c_int,
    pub nMarker2: ::std::ffi::c_int,
    pub nMarker3: ::std::ffi::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of OGRField__bindgen_ty_6"][::std::mem::size_of::<OGRField__bindgen_ty_6>() - 12usize];
    ["Alignment of OGRField__bindgen_ty_6"]
        [::std::mem::align_of::<OGRField__bindgen_ty_6>() - 4usize];
    ["Offset of field: OGRField__bindgen_ty_6::nMarker1"]
        [::std::mem::offset_of!(OGRField__bindgen_ty_6, nMarker1) - 0usize];
    ["Offset of field: OGRField__bindgen_ty_6::nMarker2"]
        [::std::mem::offset_of!(OGRField__bindgen_ty_6, nMarker2) - 4usize];
    ["Offset of field: OGRField__bindgen_ty_6::nMarker3"]
        [::std::mem::offset_of!(OGRField__bindgen_ty_6, nMarker3) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OGRField__bindgen_ty_7 {
    pub Year: GInt16,
    pub Month: GByte,
    pub Day: GByte,
    pub Hour: GByte,
    pub Minute: GByte,
    pub TZFlag: GByte,
    pub Reserved: GByte,
    pub Second: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of OGRField__bindgen_ty_7"][::std::mem::size_of::<OGRField__bindgen_ty_7>() - 12usize];
    ["Alignment of OGRField__bindgen_ty_7"]
        [::std::mem::align_of::<OGRField__bindgen_ty_7>() - 4usize];
    ["Offset of field: OGRField__bindgen_ty_7::Year"]
        [::std::mem::offset_of!(OGRField__bindgen_ty_7, Year) - 0usize];
    ["Offset of field: OGRField__bindgen_ty_7::Month"]
        [::std::mem::offset_of!(OGRField__bindgen_ty_7, Month) - 2usize];
    ["Offset of field: OGRField__bindgen_ty_7::Day"]
        [::std::mem::offset_of!(OGRField__bindgen_ty_7, Day) - 3usize];
    ["Offset of field: OGRField__bindgen_ty_7::Hour"]
        [::std::mem::offset_of!(OGRField__bindgen_ty_7, Hour) - 4usize];
    ["Offset of field: OGRField__bindgen_ty_7::Minute"]
        [::std::mem::offset_of!(OGRField__bindgen_ty_7, Minute) - 5usize];
    ["Offset of field: OGRField__bindgen_ty_7::TZFlag"]
        [::std::mem::offset_of!(OGRField__bindgen_ty_7, TZFlag) - 6usize];
    ["Offset of field: OGRField__bindgen_ty_7::Reserved"]
        [::std::mem::offset_of!(OGRField__bindgen_ty_7, Reserved) - 7usize];
    ["Offset of field: OGRField__bindgen_ty_7::Second"]
        [::std::mem::offset_of!(OGRField__bindgen_ty_7, Second) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of OGRField"][::std::mem::size_of::<OGRField>() - 12usize];
    ["Alignment of OGRField"][::std::mem::align_of::<OGRField>() - 4usize];
    ["Offset of field: OGRField::Integer"][::std::mem::offset_of!(OGRField, Integer) - 0usize];
    ["Offset of field: OGRField::Integer64"][::std::mem::offset_of!(OGRField, Integer64) - 0usize];
    ["Offset of field: OGRField::Real"][::std::mem::offset_of!(OGRField, Real) - 0usize];
    ["Offset of field: OGRField::String"][::std::mem::offset_of!(OGRField, String) - 0usize];
    ["Offset of field: OGRField::IntegerList"]
        [::std::mem::offset_of!(OGRField, IntegerList) - 0usize];
    ["Offset of field: OGRField::Integer64List"]
        [::std::mem::offset_of!(OGRField, Integer64List) - 0usize];
    ["Offset of field: OGRField::RealList"][::std::mem::offset_of!(OGRField, RealList) - 0usize];
    ["Offset of field: OGRField::StringList"]
        [::std::mem::offset_of!(OGRField, StringList) - 0usize];
    ["Offset of field: OGRField::Binary"][::std::mem::offset_of!(OGRField, Binary) - 0usize];
    ["Offset of field: OGRField::Set"][::std::mem::offset_of!(OGRField, Set) - 0usize];
    ["Offset of field: OGRField::Date"][::std::mem::offset_of!(OGRField, Date) - 0usize];
};
extern "C" {
    pub fn OGRParseDate(
        pszInput: *const ::std::ffi::c_char,
        psOutput: *mut OGRField,
        nOptions: ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
pub mod ogr_style_tool_class_id {
    #[doc = " OGRStyleTool derived class types (returned by GetType())."]
    pub type Type = ::std::ffi::c_uint;
    #[doc = "< None"]
    pub const OGRSTCNone: Type = 0;
    #[doc = "< Pen"]
    pub const OGRSTCPen: Type = 1;
    #[doc = "< Brush"]
    pub const OGRSTCBrush: Type = 2;
    #[doc = "< Symbol"]
    pub const OGRSTCSymbol: Type = 3;
    #[doc = "< Label"]
    pub const OGRSTCLabel: Type = 4;
    #[doc = "< Vector"]
    pub const OGRSTCVector: Type = 5;
}
#[doc = " OGRStyleTool derived class types (returned by GetType())."]
pub use self::ogr_style_tool_class_id::Type as OGRSTClassId;
pub mod ogr_style_tool_units_id {
    #[doc = " List of units supported by OGRStyleTools."]
    pub type Type = ::std::ffi::c_uint;
    #[doc = "< Ground unit"]
    pub const OGRSTUGround: Type = 0;
    #[doc = "< Pixel"]
    pub const OGRSTUPixel: Type = 1;
    #[doc = "< Points"]
    pub const OGRSTUPoints: Type = 2;
    #[doc = "< Millimeter"]
    pub const OGRSTUMM: Type = 3;
    #[doc = "< Centimeter"]
    pub const OGRSTUCM: Type = 4;
    #[doc = "< Inch"]
    pub const OGRSTUInches: Type = 5;
}
#[doc = " List of units supported by OGRStyleTools."]
pub use self::ogr_style_tool_units_id::Type as OGRSTUnitId;
#[doc = " Associates a code and a value\n\n @since GDAL 3.3"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OGRCodedValue {
    #[doc = " Code. Content should be of the type of the OGRFieldDomain"]
    pub pszCode: *mut ::std::ffi::c_char,
    #[doc = " Value. Might be NULL"]
    pub pszValue: *mut ::std::ffi::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of OGRCodedValue"][::std::mem::size_of::<OGRCodedValue>() - 8usize];
    ["Alignment of OGRCodedValue"][::std::mem::align_of::<OGRCodedValue>() - 4usize];
    ["Offset of field: OGRCodedValue::pszCode"]
        [::std::mem::offset_of!(OGRCodedValue, pszCode) - 0usize];
    ["Offset of field: OGRCodedValue::pszValue"]
        [::std::mem::offset_of!(OGRCodedValue, pszValue) - 4usize];
};
pub mod OGRFieldDomainType {
    #[doc = " Type of field domain.\n\n @since GDAL 3.3"]
    pub type Type = ::std::ffi::c_uint;
    #[doc = " Coded"]
    pub const OFDT_CODED: Type = 0;
    #[doc = " Range (min/max)"]
    pub const OFDT_RANGE: Type = 1;
    #[doc = " Glob (used by GeoPackage)"]
    pub const OFDT_GLOB: Type = 2;
}
pub mod OGRFieldDomainSplitPolicy {
    #[doc = " Split policy for field domains.\n\n When a feature is split in two, defines how the value of attributes\n following the domain are computed.\n\n @since GDAL 3.3"]
    pub type Type = ::std::ffi::c_uint;
    #[doc = " Default value"]
    pub const OFDSP_DEFAULT_VALUE: Type = 0;
    #[doc = " Duplicate"]
    pub const OFDSP_DUPLICATE: Type = 1;
    #[doc = " New values are computed by the ratio of their area/length compared to the area/length of the original feature"]
    pub const OFDSP_GEOMETRY_RATIO: Type = 2;
}
pub mod OGRFieldDomainMergePolicy {
    #[doc = " Merge policy for field domains.\n\n When a feature is built by merging two features, defines how the value of\n attributes following the domain are computed.\n\n @since GDAL 3.3"]
    pub type Type = ::std::ffi::c_uint;
    #[doc = " Default value"]
    pub const OFDMP_DEFAULT_VALUE: Type = 0;
    #[doc = " Sum"]
    pub const OFDMP_SUM: Type = 1;
    #[doc = " New values are computed as the weighted average of the source values."]
    pub const OFDMP_GEOMETRY_WEIGHTED: Type = 2;
}
extern "C" {
    pub fn GDALVersionInfo(arg1: *const ::std::ffi::c_char) -> *const ::std::ffi::c_char;
}
extern "C" {
    #[doc = " Return TRUE if GDAL library version at runtime matches nVersionMajor.nVersionMinor.\n\nThe purpose of this method is to ensure that calling code will run with the GDAL\nversion it is compiled for. It is primarily indented for external plugins.\n\n@param nVersionMajor Major version to be tested against\n@param nVersionMinor Minor version to be tested against\n@param pszCallingComponentName If not NULL, in case of version mismatch, the method\nwill issue a failure mentioning the name of\nthe calling component."]
    pub fn GDALCheckVersion(
        nVersionMajor: ::std::ffi::c_int,
        nVersionMinor: ::std::ffi::c_int,
        pszCallingComponentName: *const ::std::ffi::c_char,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGRGetGEOSVersion(
        pnMajor: *mut ::std::ffi::c_int,
        pnMinor: *mut ::std::ffi::c_int,
        pnPatch: *mut ::std::ffi::c_int,
    ) -> bool;
}
#[doc = " Opaque type for a geometry"]
pub type OGRGeometryH = *mut ::std::ffi::c_void;
#[doc = " Opaque type for a spatial reference system"]
pub type OGRSpatialReferenceH = *mut ::std::ffi::c_void;
#[doc = " Opaque type for a coordinate transformation object"]
pub type OGRCoordinateTransformationH = *mut ::std::ffi::c_void;
extern "C" {
    pub fn OGR_G_CreateFromWkb(
        arg1: *const ::std::ffi::c_void,
        arg2: OGRSpatialReferenceH,
        arg3: *mut OGRGeometryH,
        arg4: ::std::ffi::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_G_CreateFromWkbEx(
        arg1: *const ::std::ffi::c_void,
        arg2: OGRSpatialReferenceH,
        arg3: *mut OGRGeometryH,
        arg4: usize,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_G_CreateFromWkt(
        arg1: *mut *mut ::std::ffi::c_char,
        arg2: OGRSpatialReferenceH,
        arg3: *mut OGRGeometryH,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_G_CreateFromFgf(
        arg1: *const ::std::ffi::c_void,
        arg2: OGRSpatialReferenceH,
        arg3: *mut OGRGeometryH,
        arg4: ::std::ffi::c_int,
        arg5: *mut ::std::ffi::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_G_DestroyGeometry(arg1: OGRGeometryH);
}
extern "C" {
    pub fn OGR_G_CreateGeometry(arg1: OGRwkbGeometryType::Type) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_ApproximateArcAngles(
        dfCenterX: f64,
        dfCenterY: f64,
        dfZ: f64,
        dfPrimaryRadius: f64,
        dfSecondaryAxis: f64,
        dfRotation: f64,
        dfStartAngle: f64,
        dfEndAngle: f64,
        dfMaxAngleStepSizeDegrees: f64,
    ) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_ForceToPolygon(arg1: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_ForceToLineString(arg1: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_ForceToMultiPolygon(arg1: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_ForceToMultiPoint(arg1: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_ForceToMultiLineString(arg1: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_ForceTo(
        hGeom: OGRGeometryH,
        eTargetType: OGRwkbGeometryType::Type,
        papszOptions: *mut *mut ::std::ffi::c_char,
    ) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_RemoveLowerDimensionSubGeoms(hGeom: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_GetDimension(arg1: OGRGeometryH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_G_GetCoordinateDimension(arg1: OGRGeometryH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_G_CoordinateDimension(arg1: OGRGeometryH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_G_SetCoordinateDimension(arg1: OGRGeometryH, arg2: ::std::ffi::c_int);
}
extern "C" {
    pub fn OGR_G_Is3D(arg1: OGRGeometryH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_G_IsMeasured(arg1: OGRGeometryH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_G_Set3D(arg1: OGRGeometryH, arg2: ::std::ffi::c_int);
}
extern "C" {
    pub fn OGR_G_SetMeasured(arg1: OGRGeometryH, arg2: ::std::ffi::c_int);
}
extern "C" {
    pub fn OGR_G_Clone(arg1: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_GetEnvelope(arg1: OGRGeometryH, arg2: *mut OGREnvelope);
}
extern "C" {
    pub fn OGR_G_GetEnvelope3D(arg1: OGRGeometryH, arg2: *mut OGREnvelope3D);
}
extern "C" {
    pub fn OGR_G_ImportFromWkb(
        arg1: OGRGeometryH,
        arg2: *const ::std::ffi::c_void,
        arg3: ::std::ffi::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_G_ExportToWkb(
        arg1: OGRGeometryH,
        arg2: OGRwkbByteOrder::Type,
        arg3: *mut ::std::ffi::c_uchar,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_G_ExportToIsoWkb(
        arg1: OGRGeometryH,
        arg2: OGRwkbByteOrder::Type,
        arg3: *mut ::std::ffi::c_uchar,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_G_WkbSize(hGeom: OGRGeometryH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_G_WkbSizeEx(hGeom: OGRGeometryH) -> usize;
}
extern "C" {
    pub fn OGR_G_ImportFromWkt(
        arg1: OGRGeometryH,
        arg2: *mut *mut ::std::ffi::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_G_ExportToWkt(
        arg1: OGRGeometryH,
        arg2: *mut *mut ::std::ffi::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_G_ExportToIsoWkt(
        arg1: OGRGeometryH,
        arg2: *mut *mut ::std::ffi::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_G_GetGeometryType(arg1: OGRGeometryH) -> OGRwkbGeometryType::Type;
}
extern "C" {
    pub fn OGR_G_GetGeometryName(arg1: OGRGeometryH) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn OGR_G_DumpReadable(arg1: OGRGeometryH, arg2: *mut FILE, arg3: *const ::std::ffi::c_char);
}
extern "C" {
    pub fn OGR_G_FlattenTo2D(arg1: OGRGeometryH);
}
extern "C" {
    pub fn OGR_G_CloseRings(arg1: OGRGeometryH);
}
extern "C" {
    pub fn OGR_G_CreateFromGML(arg1: *const ::std::ffi::c_char) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_ExportToGML(arg1: OGRGeometryH) -> *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn OGR_G_ExportToGMLEx(
        arg1: OGRGeometryH,
        papszOptions: *mut *mut ::std::ffi::c_char,
    ) -> *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn OGR_G_CreateFromGMLTree(arg1: *const CPLXMLNode) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_ExportToGMLTree(arg1: OGRGeometryH) -> *mut CPLXMLNode;
}
extern "C" {
    pub fn OGR_G_ExportEnvelopeToGMLTree(arg1: OGRGeometryH) -> *mut CPLXMLNode;
}
extern "C" {
    pub fn OGR_G_ExportToKML(
        arg1: OGRGeometryH,
        pszAltitudeMode: *const ::std::ffi::c_char,
    ) -> *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn OGR_G_ExportToJson(arg1: OGRGeometryH) -> *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn OGR_G_ExportToJsonEx(
        arg1: OGRGeometryH,
        papszOptions: *mut *mut ::std::ffi::c_char,
    ) -> *mut ::std::ffi::c_char;
}
extern "C" {
    #[doc = " Create a OGR geometry from a GeoJSON geometry object"]
    pub fn OGR_G_CreateGeometryFromJson(arg1: *const ::std::ffi::c_char) -> OGRGeometryH;
}
extern "C" {
    #[doc = " Create a OGR geometry from a ESRI JSON geometry object"]
    pub fn OGR_G_CreateGeometryFromEsriJson(arg1: *const ::std::ffi::c_char) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_AssignSpatialReference(arg1: OGRGeometryH, arg2: OGRSpatialReferenceH);
}
extern "C" {
    pub fn OGR_G_GetSpatialReference(arg1: OGRGeometryH) -> OGRSpatialReferenceH;
}
extern "C" {
    pub fn OGR_G_Transform(arg1: OGRGeometryH, arg2: OGRCoordinateTransformationH) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_G_TransformTo(arg1: OGRGeometryH, arg2: OGRSpatialReferenceH) -> OGRErr::Type;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OGRGeomTransformer {
    _unused: [u8; 0],
}
#[doc = " Opaque type for a geometry transformer."]
pub type OGRGeomTransformerH = *mut OGRGeomTransformer;
extern "C" {
    pub fn OGR_GeomTransformer_Create(
        arg1: OGRCoordinateTransformationH,
        papszOptions: CSLConstList,
    ) -> OGRGeomTransformerH;
}
extern "C" {
    pub fn OGR_GeomTransformer_Transform(
        hTransformer: OGRGeomTransformerH,
        hGeom: OGRGeometryH,
    ) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_GeomTransformer_Destroy(hTransformer: OGRGeomTransformerH);
}
extern "C" {
    pub fn OGR_G_Simplify(hThis: OGRGeometryH, tolerance: f64) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_SimplifyPreserveTopology(hThis: OGRGeometryH, tolerance: f64) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_DelaunayTriangulation(
        hThis: OGRGeometryH,
        dfTolerance: f64,
        bOnlyEdges: ::std::ffi::c_int,
    ) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_Segmentize(hGeom: OGRGeometryH, dfMaxLength: f64);
}
extern "C" {
    pub fn OGR_G_Intersects(arg1: OGRGeometryH, arg2: OGRGeometryH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_G_Equals(arg1: OGRGeometryH, arg2: OGRGeometryH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_G_Disjoint(arg1: OGRGeometryH, arg2: OGRGeometryH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_G_Touches(arg1: OGRGeometryH, arg2: OGRGeometryH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_G_Crosses(arg1: OGRGeometryH, arg2: OGRGeometryH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_G_Within(arg1: OGRGeometryH, arg2: OGRGeometryH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_G_Contains(arg1: OGRGeometryH, arg2: OGRGeometryH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_G_Overlaps(arg1: OGRGeometryH, arg2: OGRGeometryH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_G_Boundary(arg1: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_ConvexHull(arg1: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_Buffer(arg1: OGRGeometryH, arg2: f64, arg3: ::std::ffi::c_int) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_Intersection(arg1: OGRGeometryH, arg2: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_Union(arg1: OGRGeometryH, arg2: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_UnionCascaded(arg1: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_PointOnSurface(arg1: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_Difference(arg1: OGRGeometryH, arg2: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_SymDifference(arg1: OGRGeometryH, arg2: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_Distance(arg1: OGRGeometryH, arg2: OGRGeometryH) -> f64;
}
extern "C" {
    pub fn OGR_G_Distance3D(arg1: OGRGeometryH, arg2: OGRGeometryH) -> f64;
}
extern "C" {
    pub fn OGR_G_Length(arg1: OGRGeometryH) -> f64;
}
extern "C" {
    pub fn OGR_G_Area(arg1: OGRGeometryH) -> f64;
}
extern "C" {
    pub fn OGR_G_Centroid(arg1: OGRGeometryH, arg2: OGRGeometryH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_G_Value(arg1: OGRGeometryH, dfDistance: f64) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_Empty(arg1: OGRGeometryH);
}
extern "C" {
    pub fn OGR_G_IsEmpty(arg1: OGRGeometryH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_G_IsValid(arg1: OGRGeometryH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_G_MakeValid(arg1: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_MakeValidEx(arg1: OGRGeometryH, arg2: CSLConstList) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_Normalize(arg1: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_IsSimple(arg1: OGRGeometryH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_G_IsRing(arg1: OGRGeometryH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_G_Polygonize(arg1: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    #[doc = " @cond Doxygen_Suppress"]
    pub fn OGR_G_Intersect(arg1: OGRGeometryH, arg2: OGRGeometryH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_G_Equal(arg1: OGRGeometryH, arg2: OGRGeometryH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_G_SymmetricDifference(arg1: OGRGeometryH, arg2: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_GetArea(arg1: OGRGeometryH) -> f64;
}
extern "C" {
    pub fn OGR_G_GetBoundary(arg1: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    #[doc = " @endcond"]
    pub fn OGR_G_GetPointCount(arg1: OGRGeometryH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_G_GetPoints(
        hGeom: OGRGeometryH,
        pabyX: *mut ::std::ffi::c_void,
        nXStride: ::std::ffi::c_int,
        pabyY: *mut ::std::ffi::c_void,
        nYStride: ::std::ffi::c_int,
        pabyZ: *mut ::std::ffi::c_void,
        nZStride: ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_G_GetPointsZM(
        hGeom: OGRGeometryH,
        pabyX: *mut ::std::ffi::c_void,
        nXStride: ::std::ffi::c_int,
        pabyY: *mut ::std::ffi::c_void,
        nYStride: ::std::ffi::c_int,
        pabyZ: *mut ::std::ffi::c_void,
        nZStride: ::std::ffi::c_int,
        pabyM: *mut ::std::ffi::c_void,
        nMStride: ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_G_GetX(arg1: OGRGeometryH, arg2: ::std::ffi::c_int) -> f64;
}
extern "C" {
    pub fn OGR_G_GetY(arg1: OGRGeometryH, arg2: ::std::ffi::c_int) -> f64;
}
extern "C" {
    pub fn OGR_G_GetZ(arg1: OGRGeometryH, arg2: ::std::ffi::c_int) -> f64;
}
extern "C" {
    pub fn OGR_G_GetM(arg1: OGRGeometryH, arg2: ::std::ffi::c_int) -> f64;
}
extern "C" {
    pub fn OGR_G_GetPoint(
        arg1: OGRGeometryH,
        iPoint: ::std::ffi::c_int,
        arg2: *mut f64,
        arg3: *mut f64,
        arg4: *mut f64,
    );
}
extern "C" {
    pub fn OGR_G_GetPointZM(
        arg1: OGRGeometryH,
        iPoint: ::std::ffi::c_int,
        arg2: *mut f64,
        arg3: *mut f64,
        arg4: *mut f64,
        arg5: *mut f64,
    );
}
extern "C" {
    pub fn OGR_G_SetPointCount(hGeom: OGRGeometryH, nNewPointCount: ::std::ffi::c_int);
}
extern "C" {
    pub fn OGR_G_SetPoint(
        arg1: OGRGeometryH,
        iPoint: ::std::ffi::c_int,
        arg2: f64,
        arg3: f64,
        arg4: f64,
    );
}
extern "C" {
    pub fn OGR_G_SetPoint_2D(arg1: OGRGeometryH, iPoint: ::std::ffi::c_int, arg2: f64, arg3: f64);
}
extern "C" {
    pub fn OGR_G_SetPointM(
        arg1: OGRGeometryH,
        iPoint: ::std::ffi::c_int,
        arg2: f64,
        arg3: f64,
        arg4: f64,
    );
}
extern "C" {
    pub fn OGR_G_SetPointZM(
        arg1: OGRGeometryH,
        iPoint: ::std::ffi::c_int,
        arg2: f64,
        arg3: f64,
        arg4: f64,
        arg5: f64,
    );
}
extern "C" {
    pub fn OGR_G_AddPoint(arg1: OGRGeometryH, arg2: f64, arg3: f64, arg4: f64);
}
extern "C" {
    pub fn OGR_G_AddPoint_2D(arg1: OGRGeometryH, arg2: f64, arg3: f64);
}
extern "C" {
    pub fn OGR_G_AddPointM(arg1: OGRGeometryH, arg2: f64, arg3: f64, arg4: f64);
}
extern "C" {
    pub fn OGR_G_AddPointZM(arg1: OGRGeometryH, arg2: f64, arg3: f64, arg4: f64, arg5: f64);
}
extern "C" {
    pub fn OGR_G_SetPoints(
        hGeom: OGRGeometryH,
        nPointsIn: ::std::ffi::c_int,
        pabyX: *const ::std::ffi::c_void,
        nXStride: ::std::ffi::c_int,
        pabyY: *const ::std::ffi::c_void,
        nYStride: ::std::ffi::c_int,
        pabyZ: *const ::std::ffi::c_void,
        nZStride: ::std::ffi::c_int,
    );
}
extern "C" {
    pub fn OGR_G_SetPointsZM(
        hGeom: OGRGeometryH,
        nPointsIn: ::std::ffi::c_int,
        pabyX: *const ::std::ffi::c_void,
        nXStride: ::std::ffi::c_int,
        pabyY: *const ::std::ffi::c_void,
        nYStride: ::std::ffi::c_int,
        pabyZ: *const ::std::ffi::c_void,
        nZStride: ::std::ffi::c_int,
        pabyM: *const ::std::ffi::c_void,
        nMStride: ::std::ffi::c_int,
    );
}
extern "C" {
    pub fn OGR_G_SwapXY(hGeom: OGRGeometryH);
}
extern "C" {
    pub fn OGR_G_GetGeometryCount(arg1: OGRGeometryH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_G_GetGeometryRef(arg1: OGRGeometryH, arg2: ::std::ffi::c_int) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_AddGeometry(arg1: OGRGeometryH, arg2: OGRGeometryH) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_G_AddGeometryDirectly(arg1: OGRGeometryH, arg2: OGRGeometryH) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_G_RemoveGeometry(
        arg1: OGRGeometryH,
        arg2: ::std::ffi::c_int,
        arg3: ::std::ffi::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_G_HasCurveGeometry(
        arg1: OGRGeometryH,
        bLookForNonLinear: ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_G_GetLinearGeometry(
        hGeom: OGRGeometryH,
        dfMaxAngleStepSizeDegrees: f64,
        papszOptions: *mut *mut ::std::ffi::c_char,
    ) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_GetCurveGeometry(
        hGeom: OGRGeometryH,
        papszOptions: *mut *mut ::std::ffi::c_char,
    ) -> OGRGeometryH;
}
extern "C" {
    pub fn OGRBuildPolygonFromEdges(
        hLinesAsCollection: OGRGeometryH,
        bBestEffort: ::std::ffi::c_int,
        bAutoClose: ::std::ffi::c_int,
        dfTolerance: f64,
        peErr: *mut OGRErr::Type,
    ) -> OGRGeometryH;
}
extern "C" {
    #[doc = " @cond Doxygen_Suppress"]
    pub fn OGRSetGenerate_DB2_V72_BYTE_ORDER(
        bGenerate_DB2_V72_BYTE_ORDER: ::std::ffi::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGRGetGenerate_DB2_V72_BYTE_ORDER() -> ::std::ffi::c_int;
}
extern "C" {
    #[doc = " @endcond"]
    pub fn OGRSetNonLinearGeometriesEnabledFlag(bFlag: ::std::ffi::c_int);
}
extern "C" {
    pub fn OGRGetNonLinearGeometriesEnabledFlag() -> ::std::ffi::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OGRPreparedGeometry {
    _unused: [u8; 0],
}
#[doc = " Opaque type for a prepared geometry"]
pub type OGRPreparedGeometryH = *mut _OGRPreparedGeometry;
extern "C" {
    pub fn OGRHasPreparedGeometrySupport() -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGRCreatePreparedGeometry(hGeom: OGRGeometryH) -> OGRPreparedGeometryH;
}
extern "C" {
    pub fn OGRDestroyPreparedGeometry(hPreparedGeom: OGRPreparedGeometryH);
}
extern "C" {
    pub fn OGRPreparedGeometryIntersects(
        hPreparedGeom: OGRPreparedGeometryH,
        hOtherGeom: OGRGeometryH,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGRPreparedGeometryContains(
        hPreparedGeom: OGRPreparedGeometryH,
        hOtherGeom: OGRGeometryH,
    ) -> ::std::ffi::c_int;
}
#[doc = " Opaque type for a field definition (OGRFieldDefn)"]
pub type OGRFieldDefnH = *mut ::std::ffi::c_void;
#[doc = " Opaque type for a feature definition (OGRFeatureDefn)"]
pub type OGRFeatureDefnH = *mut ::std::ffi::c_void;
#[doc = " Opaque type for a feature (OGRFeature)"]
pub type OGRFeatureH = *mut ::std::ffi::c_void;
#[doc = " Opaque type for a style table (OGRStyleTable)"]
pub type OGRStyleTableH = *mut ::std::ffi::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OGRGeomFieldDefnHS {
    _unused: [u8; 0],
}
#[doc = " Opaque type for a geometry field definition (OGRGeomFieldDefn)"]
pub type OGRGeomFieldDefnH = *mut OGRGeomFieldDefnHS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OGRFieldDomainHS {
    _unused: [u8; 0],
}
#[doc = " Opaque type for a field domain definition (OGRFieldDomain)"]
pub type OGRFieldDomainH = *mut OGRFieldDomainHS;
extern "C" {
    pub fn OGR_Fld_Create(
        arg1: *const ::std::ffi::c_char,
        arg2: OGRFieldType::Type,
    ) -> OGRFieldDefnH;
}
extern "C" {
    pub fn OGR_Fld_Destroy(arg1: OGRFieldDefnH);
}
extern "C" {
    pub fn OGR_Fld_SetName(arg1: OGRFieldDefnH, arg2: *const ::std::ffi::c_char);
}
extern "C" {
    pub fn OGR_Fld_GetNameRef(arg1: OGRFieldDefnH) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn OGR_Fld_SetAlternativeName(arg1: OGRFieldDefnH, arg2: *const ::std::ffi::c_char);
}
extern "C" {
    pub fn OGR_Fld_GetAlternativeNameRef(arg1: OGRFieldDefnH) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn OGR_Fld_GetType(arg1: OGRFieldDefnH) -> OGRFieldType::Type;
}
extern "C" {
    pub fn OGR_Fld_SetType(arg1: OGRFieldDefnH, arg2: OGRFieldType::Type);
}
extern "C" {
    pub fn OGR_Fld_GetSubType(arg1: OGRFieldDefnH) -> OGRFieldSubType::Type;
}
extern "C" {
    pub fn OGR_Fld_SetSubType(arg1: OGRFieldDefnH, arg2: OGRFieldSubType::Type);
}
extern "C" {
    pub fn OGR_Fld_GetJustify(arg1: OGRFieldDefnH) -> OGRJustification::Type;
}
extern "C" {
    pub fn OGR_Fld_SetJustify(arg1: OGRFieldDefnH, arg2: OGRJustification::Type);
}
extern "C" {
    pub fn OGR_Fld_GetWidth(arg1: OGRFieldDefnH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_Fld_SetWidth(arg1: OGRFieldDefnH, arg2: ::std::ffi::c_int);
}
extern "C" {
    pub fn OGR_Fld_GetPrecision(arg1: OGRFieldDefnH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_Fld_SetPrecision(arg1: OGRFieldDefnH, arg2: ::std::ffi::c_int);
}
extern "C" {
    pub fn OGR_Fld_Set(
        arg1: OGRFieldDefnH,
        arg2: *const ::std::ffi::c_char,
        arg3: OGRFieldType::Type,
        arg4: ::std::ffi::c_int,
        arg5: ::std::ffi::c_int,
        arg6: OGRJustification::Type,
    );
}
extern "C" {
    pub fn OGR_Fld_IsIgnored(hDefn: OGRFieldDefnH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_Fld_SetIgnored(hDefn: OGRFieldDefnH, arg1: ::std::ffi::c_int);
}
extern "C" {
    pub fn OGR_Fld_IsNullable(hDefn: OGRFieldDefnH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_Fld_SetNullable(hDefn: OGRFieldDefnH, arg1: ::std::ffi::c_int);
}
extern "C" {
    pub fn OGR_Fld_IsUnique(hDefn: OGRFieldDefnH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_Fld_SetUnique(hDefn: OGRFieldDefnH, arg1: ::std::ffi::c_int);
}
extern "C" {
    pub fn OGR_Fld_GetDefault(hDefn: OGRFieldDefnH) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn OGR_Fld_SetDefault(hDefn: OGRFieldDefnH, arg1: *const ::std::ffi::c_char);
}
extern "C" {
    pub fn OGR_Fld_IsDefaultDriverSpecific(hDefn: OGRFieldDefnH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_Fld_GetDomainName(hDefn: OGRFieldDefnH) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn OGR_Fld_SetDomainName(hDefn: OGRFieldDefnH, arg1: *const ::std::ffi::c_char);
}
extern "C" {
    pub fn OGR_GetFieldTypeName(arg1: OGRFieldType::Type) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn OGR_GetFieldSubTypeName(arg1: OGRFieldSubType::Type) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn OGR_AreTypeSubTypeCompatible(
        eType: OGRFieldType::Type,
        eSubType: OGRFieldSubType::Type,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_GFld_Create(
        arg1: *const ::std::ffi::c_char,
        arg2: OGRwkbGeometryType::Type,
    ) -> OGRGeomFieldDefnH;
}
extern "C" {
    pub fn OGR_GFld_Destroy(arg1: OGRGeomFieldDefnH);
}
extern "C" {
    pub fn OGR_GFld_SetName(arg1: OGRGeomFieldDefnH, arg2: *const ::std::ffi::c_char);
}
extern "C" {
    pub fn OGR_GFld_GetNameRef(arg1: OGRGeomFieldDefnH) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn OGR_GFld_GetType(arg1: OGRGeomFieldDefnH) -> OGRwkbGeometryType::Type;
}
extern "C" {
    pub fn OGR_GFld_SetType(arg1: OGRGeomFieldDefnH, arg2: OGRwkbGeometryType::Type);
}
extern "C" {
    pub fn OGR_GFld_GetSpatialRef(arg1: OGRGeomFieldDefnH) -> OGRSpatialReferenceH;
}
extern "C" {
    pub fn OGR_GFld_SetSpatialRef(arg1: OGRGeomFieldDefnH, hSRS: OGRSpatialReferenceH);
}
extern "C" {
    pub fn OGR_GFld_IsNullable(hDefn: OGRGeomFieldDefnH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_GFld_SetNullable(hDefn: OGRGeomFieldDefnH, arg1: ::std::ffi::c_int);
}
extern "C" {
    pub fn OGR_GFld_IsIgnored(hDefn: OGRGeomFieldDefnH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_GFld_SetIgnored(hDefn: OGRGeomFieldDefnH, arg1: ::std::ffi::c_int);
}
extern "C" {
    pub fn OGR_FD_Create(arg1: *const ::std::ffi::c_char) -> OGRFeatureDefnH;
}
extern "C" {
    pub fn OGR_FD_Destroy(arg1: OGRFeatureDefnH);
}
extern "C" {
    pub fn OGR_FD_Release(arg1: OGRFeatureDefnH);
}
extern "C" {
    pub fn OGR_FD_GetName(arg1: OGRFeatureDefnH) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn OGR_FD_GetFieldCount(arg1: OGRFeatureDefnH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_FD_GetFieldDefn(arg1: OGRFeatureDefnH, arg2: ::std::ffi::c_int) -> OGRFieldDefnH;
}
extern "C" {
    pub fn OGR_FD_GetFieldIndex(
        arg1: OGRFeatureDefnH,
        arg2: *const ::std::ffi::c_char,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_FD_AddFieldDefn(arg1: OGRFeatureDefnH, arg2: OGRFieldDefnH);
}
extern "C" {
    pub fn OGR_FD_DeleteFieldDefn(
        hDefn: OGRFeatureDefnH,
        iField: ::std::ffi::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_FD_ReorderFieldDefns(
        hDefn: OGRFeatureDefnH,
        panMap: *const ::std::ffi::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_FD_GetGeomType(arg1: OGRFeatureDefnH) -> OGRwkbGeometryType::Type;
}
extern "C" {
    pub fn OGR_FD_SetGeomType(arg1: OGRFeatureDefnH, arg2: OGRwkbGeometryType::Type);
}
extern "C" {
    pub fn OGR_FD_IsGeometryIgnored(arg1: OGRFeatureDefnH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_FD_SetGeometryIgnored(arg1: OGRFeatureDefnH, arg2: ::std::ffi::c_int);
}
extern "C" {
    pub fn OGR_FD_IsStyleIgnored(arg1: OGRFeatureDefnH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_FD_SetStyleIgnored(arg1: OGRFeatureDefnH, arg2: ::std::ffi::c_int);
}
extern "C" {
    pub fn OGR_FD_Reference(arg1: OGRFeatureDefnH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_FD_Dereference(arg1: OGRFeatureDefnH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_FD_GetReferenceCount(arg1: OGRFeatureDefnH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_FD_GetGeomFieldCount(hFDefn: OGRFeatureDefnH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_FD_GetGeomFieldDefn(
        hFDefn: OGRFeatureDefnH,
        i: ::std::ffi::c_int,
    ) -> OGRGeomFieldDefnH;
}
extern "C" {
    pub fn OGR_FD_GetGeomFieldIndex(
        hFDefn: OGRFeatureDefnH,
        pszName: *const ::std::ffi::c_char,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_FD_AddGeomFieldDefn(hFDefn: OGRFeatureDefnH, hGFldDefn: OGRGeomFieldDefnH);
}
extern "C" {
    pub fn OGR_FD_DeleteGeomFieldDefn(
        hFDefn: OGRFeatureDefnH,
        iGeomField: ::std::ffi::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_FD_IsSame(
        hFDefn: OGRFeatureDefnH,
        hOtherFDefn: OGRFeatureDefnH,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_F_Create(arg1: OGRFeatureDefnH) -> OGRFeatureH;
}
extern "C" {
    pub fn OGR_F_Destroy(arg1: OGRFeatureH);
}
extern "C" {
    pub fn OGR_F_GetDefnRef(arg1: OGRFeatureH) -> OGRFeatureDefnH;
}
extern "C" {
    pub fn OGR_F_SetGeometryDirectly(arg1: OGRFeatureH, arg2: OGRGeometryH) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_F_SetGeometry(arg1: OGRFeatureH, arg2: OGRGeometryH) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_F_GetGeometryRef(arg1: OGRFeatureH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_F_StealGeometry(arg1: OGRFeatureH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_F_StealGeometryEx(arg1: OGRFeatureH, iGeomField: ::std::ffi::c_int) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_F_Clone(arg1: OGRFeatureH) -> OGRFeatureH;
}
extern "C" {
    pub fn OGR_F_Equal(arg1: OGRFeatureH, arg2: OGRFeatureH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_F_GetFieldCount(arg1: OGRFeatureH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_F_GetFieldDefnRef(arg1: OGRFeatureH, arg2: ::std::ffi::c_int) -> OGRFieldDefnH;
}
extern "C" {
    pub fn OGR_F_GetFieldIndex(
        arg1: OGRFeatureH,
        arg2: *const ::std::ffi::c_char,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_F_IsFieldSet(arg1: OGRFeatureH, arg2: ::std::ffi::c_int) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_F_UnsetField(arg1: OGRFeatureH, arg2: ::std::ffi::c_int);
}
extern "C" {
    pub fn OGR_F_IsFieldNull(arg1: OGRFeatureH, arg2: ::std::ffi::c_int) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_F_IsFieldSetAndNotNull(
        arg1: OGRFeatureH,
        arg2: ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_F_SetFieldNull(arg1: OGRFeatureH, arg2: ::std::ffi::c_int);
}
extern "C" {
    pub fn OGR_F_GetRawFieldRef(arg1: OGRFeatureH, arg2: ::std::ffi::c_int) -> *mut OGRField;
}
extern "C" {
    pub fn OGR_RawField_IsUnset(arg1: *const OGRField) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_RawField_IsNull(arg1: *const OGRField) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_RawField_SetUnset(arg1: *mut OGRField);
}
extern "C" {
    pub fn OGR_RawField_SetNull(arg1: *mut OGRField);
}
extern "C" {
    pub fn OGR_F_GetFieldAsInteger(arg1: OGRFeatureH, arg2: ::std::ffi::c_int)
        -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_F_GetFieldAsInteger64(arg1: OGRFeatureH, arg2: ::std::ffi::c_int) -> GIntBig;
}
extern "C" {
    pub fn OGR_F_GetFieldAsDouble(arg1: OGRFeatureH, arg2: ::std::ffi::c_int) -> f64;
}
extern "C" {
    pub fn OGR_F_GetFieldAsString(
        arg1: OGRFeatureH,
        arg2: ::std::ffi::c_int,
    ) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn OGR_F_GetFieldAsIntegerList(
        arg1: OGRFeatureH,
        arg2: ::std::ffi::c_int,
        arg3: *mut ::std::ffi::c_int,
    ) -> *const ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_F_GetFieldAsInteger64List(
        arg1: OGRFeatureH,
        arg2: ::std::ffi::c_int,
        arg3: *mut ::std::ffi::c_int,
    ) -> *const GIntBig;
}
extern "C" {
    pub fn OGR_F_GetFieldAsDoubleList(
        arg1: OGRFeatureH,
        arg2: ::std::ffi::c_int,
        arg3: *mut ::std::ffi::c_int,
    ) -> *const f64;
}
extern "C" {
    pub fn OGR_F_GetFieldAsStringList(
        arg1: OGRFeatureH,
        arg2: ::std::ffi::c_int,
    ) -> *mut *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn OGR_F_GetFieldAsBinary(
        arg1: OGRFeatureH,
        arg2: ::std::ffi::c_int,
        arg3: *mut ::std::ffi::c_int,
    ) -> *mut GByte;
}
extern "C" {
    pub fn OGR_F_GetFieldAsDateTime(
        arg1: OGRFeatureH,
        arg2: ::std::ffi::c_int,
        arg3: *mut ::std::ffi::c_int,
        arg4: *mut ::std::ffi::c_int,
        arg5: *mut ::std::ffi::c_int,
        arg6: *mut ::std::ffi::c_int,
        arg7: *mut ::std::ffi::c_int,
        arg8: *mut ::std::ffi::c_int,
        arg9: *mut ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_F_GetFieldAsDateTimeEx(
        hFeat: OGRFeatureH,
        iField: ::std::ffi::c_int,
        pnYear: *mut ::std::ffi::c_int,
        pnMonth: *mut ::std::ffi::c_int,
        pnDay: *mut ::std::ffi::c_int,
        pnHour: *mut ::std::ffi::c_int,
        pnMinute: *mut ::std::ffi::c_int,
        pfSecond: *mut f32,
        pnTZFlag: *mut ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_F_SetFieldInteger(
        arg1: OGRFeatureH,
        arg2: ::std::ffi::c_int,
        arg3: ::std::ffi::c_int,
    );
}
extern "C" {
    pub fn OGR_F_SetFieldInteger64(arg1: OGRFeatureH, arg2: ::std::ffi::c_int, arg3: GIntBig);
}
extern "C" {
    pub fn OGR_F_SetFieldDouble(arg1: OGRFeatureH, arg2: ::std::ffi::c_int, arg3: f64);
}
extern "C" {
    pub fn OGR_F_SetFieldString(
        arg1: OGRFeatureH,
        arg2: ::std::ffi::c_int,
        arg3: *const ::std::ffi::c_char,
    );
}
extern "C" {
    pub fn OGR_F_SetFieldIntegerList(
        arg1: OGRFeatureH,
        arg2: ::std::ffi::c_int,
        arg3: ::std::ffi::c_int,
        arg4: *const ::std::ffi::c_int,
    );
}
extern "C" {
    pub fn OGR_F_SetFieldInteger64List(
        arg1: OGRFeatureH,
        arg2: ::std::ffi::c_int,
        arg3: ::std::ffi::c_int,
        arg4: *const GIntBig,
    );
}
extern "C" {
    pub fn OGR_F_SetFieldDoubleList(
        arg1: OGRFeatureH,
        arg2: ::std::ffi::c_int,
        arg3: ::std::ffi::c_int,
        arg4: *const f64,
    );
}
extern "C" {
    pub fn OGR_F_SetFieldStringList(arg1: OGRFeatureH, arg2: ::std::ffi::c_int, arg3: CSLConstList);
}
extern "C" {
    pub fn OGR_F_SetFieldRaw(arg1: OGRFeatureH, arg2: ::std::ffi::c_int, arg3: *const OGRField);
}
extern "C" {
    pub fn OGR_F_SetFieldBinary(
        arg1: OGRFeatureH,
        arg2: ::std::ffi::c_int,
        arg3: ::std::ffi::c_int,
        arg4: *const ::std::ffi::c_void,
    );
}
extern "C" {
    pub fn OGR_F_SetFieldDateTime(
        arg1: OGRFeatureH,
        arg2: ::std::ffi::c_int,
        arg3: ::std::ffi::c_int,
        arg4: ::std::ffi::c_int,
        arg5: ::std::ffi::c_int,
        arg6: ::std::ffi::c_int,
        arg7: ::std::ffi::c_int,
        arg8: ::std::ffi::c_int,
        arg9: ::std::ffi::c_int,
    );
}
extern "C" {
    pub fn OGR_F_SetFieldDateTimeEx(
        arg1: OGRFeatureH,
        arg2: ::std::ffi::c_int,
        arg3: ::std::ffi::c_int,
        arg4: ::std::ffi::c_int,
        arg5: ::std::ffi::c_int,
        arg6: ::std::ffi::c_int,
        arg7: ::std::ffi::c_int,
        arg8: f32,
        arg9: ::std::ffi::c_int,
    );
}
extern "C" {
    pub fn OGR_F_GetGeomFieldCount(hFeat: OGRFeatureH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_F_GetGeomFieldDefnRef(
        hFeat: OGRFeatureH,
        iField: ::std::ffi::c_int,
    ) -> OGRGeomFieldDefnH;
}
extern "C" {
    pub fn OGR_F_GetGeomFieldIndex(
        hFeat: OGRFeatureH,
        pszName: *const ::std::ffi::c_char,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_F_GetGeomFieldRef(hFeat: OGRFeatureH, iField: ::std::ffi::c_int) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_F_SetGeomFieldDirectly(
        hFeat: OGRFeatureH,
        iField: ::std::ffi::c_int,
        hGeom: OGRGeometryH,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_F_SetGeomField(
        hFeat: OGRFeatureH,
        iField: ::std::ffi::c_int,
        hGeom: OGRGeometryH,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_F_GetFID(arg1: OGRFeatureH) -> GIntBig;
}
extern "C" {
    pub fn OGR_F_SetFID(arg1: OGRFeatureH, arg2: GIntBig) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_F_DumpReadable(arg1: OGRFeatureH, arg2: *mut FILE);
}
extern "C" {
    pub fn OGR_F_SetFrom(
        arg1: OGRFeatureH,
        arg2: OGRFeatureH,
        arg3: ::std::ffi::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_F_SetFromWithMap(
        arg1: OGRFeatureH,
        arg2: OGRFeatureH,
        arg3: ::std::ffi::c_int,
        arg4: *const ::std::ffi::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_F_GetStyleString(arg1: OGRFeatureH) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn OGR_F_SetStyleString(arg1: OGRFeatureH, arg2: *const ::std::ffi::c_char);
}
extern "C" {
    pub fn OGR_F_SetStyleStringDirectly(arg1: OGRFeatureH, arg2: *mut ::std::ffi::c_char);
}
extern "C" {
    #[doc = " Return style table"]
    pub fn OGR_F_GetStyleTable(arg1: OGRFeatureH) -> OGRStyleTableH;
}
extern "C" {
    #[doc = " Set style table and take ownership"]
    pub fn OGR_F_SetStyleTableDirectly(arg1: OGRFeatureH, arg2: OGRStyleTableH);
}
extern "C" {
    #[doc = " Set style table"]
    pub fn OGR_F_SetStyleTable(arg1: OGRFeatureH, arg2: OGRStyleTableH);
}
extern "C" {
    pub fn OGR_F_GetNativeData(arg1: OGRFeatureH) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn OGR_F_SetNativeData(arg1: OGRFeatureH, arg2: *const ::std::ffi::c_char);
}
extern "C" {
    pub fn OGR_F_GetNativeMediaType(arg1: OGRFeatureH) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn OGR_F_SetNativeMediaType(arg1: OGRFeatureH, arg2: *const ::std::ffi::c_char);
}
extern "C" {
    pub fn OGR_F_FillUnsetWithDefault(
        hFeat: OGRFeatureH,
        bNotNullableOnly: ::std::ffi::c_int,
        papszOptions: *mut *mut ::std::ffi::c_char,
    );
}
extern "C" {
    pub fn OGR_F_Validate(
        arg1: OGRFeatureH,
        nValidateFlags: ::std::ffi::c_int,
        bEmitError: ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_FldDomain_Destroy(arg1: OGRFieldDomainH);
}
extern "C" {
    pub fn OGR_FldDomain_GetName(arg1: OGRFieldDomainH) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn OGR_FldDomain_GetDescription(arg1: OGRFieldDomainH) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn OGR_FldDomain_GetDomainType(arg1: OGRFieldDomainH) -> OGRFieldDomainType::Type;
}
extern "C" {
    pub fn OGR_FldDomain_GetFieldType(arg1: OGRFieldDomainH) -> OGRFieldType::Type;
}
extern "C" {
    pub fn OGR_FldDomain_GetFieldSubType(arg1: OGRFieldDomainH) -> OGRFieldSubType::Type;
}
extern "C" {
    pub fn OGR_FldDomain_GetSplitPolicy(arg1: OGRFieldDomainH) -> OGRFieldDomainSplitPolicy::Type;
}
extern "C" {
    pub fn OGR_FldDomain_SetSplitPolicy(
        arg1: OGRFieldDomainH,
        arg2: OGRFieldDomainSplitPolicy::Type,
    );
}
extern "C" {
    pub fn OGR_FldDomain_GetMergePolicy(arg1: OGRFieldDomainH) -> OGRFieldDomainMergePolicy::Type;
}
extern "C" {
    pub fn OGR_FldDomain_SetMergePolicy(
        arg1: OGRFieldDomainH,
        arg2: OGRFieldDomainMergePolicy::Type,
    );
}
extern "C" {
    pub fn OGR_CodedFldDomain_Create(
        pszName: *const ::std::ffi::c_char,
        pszDescription: *const ::std::ffi::c_char,
        eFieldType: OGRFieldType::Type,
        eFieldSubType: OGRFieldSubType::Type,
        enumeration: *const OGRCodedValue,
    ) -> OGRFieldDomainH;
}
extern "C" {
    pub fn OGR_CodedFldDomain_GetEnumeration(arg1: OGRFieldDomainH) -> *const OGRCodedValue;
}
extern "C" {
    pub fn OGR_RangeFldDomain_Create(
        pszName: *const ::std::ffi::c_char,
        pszDescription: *const ::std::ffi::c_char,
        eFieldType: OGRFieldType::Type,
        eFieldSubType: OGRFieldSubType::Type,
        psMin: *const OGRField,
        bMinIsInclusive: bool,
        psMax: *const OGRField,
        bMaxIsInclusive: bool,
    ) -> OGRFieldDomainH;
}
extern "C" {
    pub fn OGR_RangeFldDomain_GetMin(
        arg1: OGRFieldDomainH,
        pbIsInclusiveOut: *mut bool,
    ) -> *const OGRField;
}
extern "C" {
    pub fn OGR_RangeFldDomain_GetMax(
        arg1: OGRFieldDomainH,
        pbIsInclusiveOut: *mut bool,
    ) -> *const OGRField;
}
extern "C" {
    pub fn OGR_GlobFldDomain_Create(
        pszName: *const ::std::ffi::c_char,
        pszDescription: *const ::std::ffi::c_char,
        eFieldType: OGRFieldType::Type,
        eFieldSubType: OGRFieldSubType::Type,
        pszGlob: *const ::std::ffi::c_char,
    ) -> OGRFieldDomainH;
}
extern "C" {
    pub fn OGR_GlobFldDomain_GetGlob(arg1: OGRFieldDomainH) -> *const ::std::ffi::c_char;
}
#[doc = " Opaque type for a layer (OGRLayer)"]
pub type OGRLayerH = *mut ::std::ffi::c_void;
#[doc = " Opaque type for a OGR datasource (OGRDataSource)"]
pub type OGRDataSourceH = *mut ::std::ffi::c_void;
#[doc = " Opaque type for a OGR driver (OGRSFDriver)"]
pub type OGRSFDriverH = *mut ::std::ffi::c_void;
extern "C" {
    pub fn OGR_L_GetName(arg1: OGRLayerH) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn OGR_L_GetGeomType(arg1: OGRLayerH) -> OGRwkbGeometryType::Type;
}
extern "C" {
    pub fn OGR_L_GetSpatialFilter(arg1: OGRLayerH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_L_SetSpatialFilter(arg1: OGRLayerH, arg2: OGRGeometryH);
}
extern "C" {
    pub fn OGR_L_SetSpatialFilterRect(arg1: OGRLayerH, arg2: f64, arg3: f64, arg4: f64, arg5: f64);
}
extern "C" {
    pub fn OGR_L_SetSpatialFilterEx(
        arg1: OGRLayerH,
        iGeomField: ::std::ffi::c_int,
        hGeom: OGRGeometryH,
    );
}
extern "C" {
    pub fn OGR_L_SetSpatialFilterRectEx(
        arg1: OGRLayerH,
        iGeomField: ::std::ffi::c_int,
        dfMinX: f64,
        dfMinY: f64,
        dfMaxX: f64,
        dfMaxY: f64,
    );
}
extern "C" {
    pub fn OGR_L_SetAttributeFilter(
        arg1: OGRLayerH,
        arg2: *const ::std::ffi::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_ResetReading(arg1: OGRLayerH);
}
extern "C" {
    pub fn OGR_L_GetNextFeature(arg1: OGRLayerH) -> OGRFeatureH;
}
extern "C" {
    pub fn OGR_L_SetNextByIndex(arg1: OGRLayerH, arg2: GIntBig) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_GetFeature(arg1: OGRLayerH, arg2: GIntBig) -> OGRFeatureH;
}
extern "C" {
    pub fn OGR_L_SetFeature(arg1: OGRLayerH, arg2: OGRFeatureH) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_CreateFeature(arg1: OGRLayerH, arg2: OGRFeatureH) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_DeleteFeature(arg1: OGRLayerH, arg2: GIntBig) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_GetLayerDefn(arg1: OGRLayerH) -> OGRFeatureDefnH;
}
extern "C" {
    pub fn OGR_L_GetSpatialRef(arg1: OGRLayerH) -> OGRSpatialReferenceH;
}
extern "C" {
    pub fn OGR_L_FindFieldIndex(
        arg1: OGRLayerH,
        arg2: *const ::std::ffi::c_char,
        bExactMatch: ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_L_GetFeatureCount(arg1: OGRLayerH, arg2: ::std::ffi::c_int) -> GIntBig;
}
extern "C" {
    pub fn OGR_L_GetExtent(
        arg1: OGRLayerH,
        arg2: *mut OGREnvelope,
        arg3: ::std::ffi::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_GetExtentEx(
        arg1: OGRLayerH,
        iGeomField: ::std::ffi::c_int,
        psExtent: *mut OGREnvelope,
        bForce: ::std::ffi::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_TestCapability(
        arg1: OGRLayerH,
        arg2: *const ::std::ffi::c_char,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_L_CreateField(
        arg1: OGRLayerH,
        arg2: OGRFieldDefnH,
        arg3: ::std::ffi::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_CreateGeomField(
        hLayer: OGRLayerH,
        hFieldDefn: OGRGeomFieldDefnH,
        bForce: ::std::ffi::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_DeleteField(arg1: OGRLayerH, iField: ::std::ffi::c_int) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_ReorderFields(arg1: OGRLayerH, panMap: *mut ::std::ffi::c_int) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_ReorderField(
        arg1: OGRLayerH,
        iOldFieldPos: ::std::ffi::c_int,
        iNewFieldPos: ::std::ffi::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_AlterFieldDefn(
        arg1: OGRLayerH,
        iField: ::std::ffi::c_int,
        hNewFieldDefn: OGRFieldDefnH,
        nFlags: ::std::ffi::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_StartTransaction(arg1: OGRLayerH) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_CommitTransaction(arg1: OGRLayerH) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_RollbackTransaction(arg1: OGRLayerH) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_Rename(hLayer: OGRLayerH, pszNewName: *const ::std::ffi::c_char) -> OGRErr::Type;
}
extern "C" {
    #[doc = " @cond Doxygen_Suppress"]
    pub fn OGR_L_Reference(arg1: OGRLayerH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_L_Dereference(arg1: OGRLayerH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_L_GetRefCount(arg1: OGRLayerH) -> ::std::ffi::c_int;
}
extern "C" {
    #[doc = " @endcond"]
    pub fn OGR_L_SyncToDisk(arg1: OGRLayerH) -> OGRErr::Type;
}
extern "C" {
    #[doc = " @cond Doxygen_Suppress"]
    pub fn OGR_L_GetFeaturesRead(arg1: OGRLayerH) -> GIntBig;
}
extern "C" {
    #[doc = " @endcond"]
    pub fn OGR_L_GetFIDColumn(arg1: OGRLayerH) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn OGR_L_GetGeometryColumn(arg1: OGRLayerH) -> *const ::std::ffi::c_char;
}
extern "C" {
    #[doc = " Get style table"]
    pub fn OGR_L_GetStyleTable(arg1: OGRLayerH) -> OGRStyleTableH;
}
extern "C" {
    #[doc = " Set style table (and take ownership)"]
    pub fn OGR_L_SetStyleTableDirectly(arg1: OGRLayerH, arg2: OGRStyleTableH);
}
extern "C" {
    #[doc = " Set style table"]
    pub fn OGR_L_SetStyleTable(arg1: OGRLayerH, arg2: OGRStyleTableH);
}
extern "C" {
    pub fn OGR_L_SetIgnoredFields(
        arg1: OGRLayerH,
        arg2: *mut *const ::std::ffi::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_Intersection(
        arg1: OGRLayerH,
        arg2: OGRLayerH,
        arg3: OGRLayerH,
        arg4: *mut *mut ::std::ffi::c_char,
        arg5: GDALProgressFunc,
        arg6: *mut ::std::ffi::c_void,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_Union(
        arg1: OGRLayerH,
        arg2: OGRLayerH,
        arg3: OGRLayerH,
        arg4: *mut *mut ::std::ffi::c_char,
        arg5: GDALProgressFunc,
        arg6: *mut ::std::ffi::c_void,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_SymDifference(
        arg1: OGRLayerH,
        arg2: OGRLayerH,
        arg3: OGRLayerH,
        arg4: *mut *mut ::std::ffi::c_char,
        arg5: GDALProgressFunc,
        arg6: *mut ::std::ffi::c_void,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_Identity(
        arg1: OGRLayerH,
        arg2: OGRLayerH,
        arg3: OGRLayerH,
        arg4: *mut *mut ::std::ffi::c_char,
        arg5: GDALProgressFunc,
        arg6: *mut ::std::ffi::c_void,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_Update(
        arg1: OGRLayerH,
        arg2: OGRLayerH,
        arg3: OGRLayerH,
        arg4: *mut *mut ::std::ffi::c_char,
        arg5: GDALProgressFunc,
        arg6: *mut ::std::ffi::c_void,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_Clip(
        arg1: OGRLayerH,
        arg2: OGRLayerH,
        arg3: OGRLayerH,
        arg4: *mut *mut ::std::ffi::c_char,
        arg5: GDALProgressFunc,
        arg6: *mut ::std::ffi::c_void,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_Erase(
        arg1: OGRLayerH,
        arg2: OGRLayerH,
        arg3: OGRLayerH,
        arg4: *mut *mut ::std::ffi::c_char,
        arg5: GDALProgressFunc,
        arg6: *mut ::std::ffi::c_void,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_DS_Destroy(arg1: OGRDataSourceH);
}
extern "C" {
    pub fn OGR_DS_GetName(arg1: OGRDataSourceH) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn OGR_DS_GetLayerCount(arg1: OGRDataSourceH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_DS_GetLayer(arg1: OGRDataSourceH, arg2: ::std::ffi::c_int) -> OGRLayerH;
}
extern "C" {
    pub fn OGR_DS_GetLayerByName(
        arg1: OGRDataSourceH,
        arg2: *const ::std::ffi::c_char,
    ) -> OGRLayerH;
}
extern "C" {
    pub fn OGR_DS_DeleteLayer(arg1: OGRDataSourceH, arg2: ::std::ffi::c_int) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_DS_GetDriver(arg1: OGRDataSourceH) -> OGRSFDriverH;
}
extern "C" {
    pub fn OGR_DS_CreateLayer(
        arg1: OGRDataSourceH,
        arg2: *const ::std::ffi::c_char,
        arg3: OGRSpatialReferenceH,
        arg4: OGRwkbGeometryType::Type,
        arg5: *mut *mut ::std::ffi::c_char,
    ) -> OGRLayerH;
}
extern "C" {
    pub fn OGR_DS_CopyLayer(
        arg1: OGRDataSourceH,
        arg2: OGRLayerH,
        arg3: *const ::std::ffi::c_char,
        arg4: *mut *mut ::std::ffi::c_char,
    ) -> OGRLayerH;
}
extern "C" {
    pub fn OGR_DS_TestCapability(
        arg1: OGRDataSourceH,
        arg2: *const ::std::ffi::c_char,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_DS_ExecuteSQL(
        arg1: OGRDataSourceH,
        arg2: *const ::std::ffi::c_char,
        arg3: OGRGeometryH,
        arg4: *const ::std::ffi::c_char,
    ) -> OGRLayerH;
}
extern "C" {
    pub fn OGR_DS_ReleaseResultSet(arg1: OGRDataSourceH, arg2: OGRLayerH);
}
extern "C" {
    #[doc = " @cond Doxygen_Suppress"]
    pub fn OGR_DS_Reference(arg1: OGRDataSourceH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_DS_Dereference(arg1: OGRDataSourceH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_DS_GetRefCount(arg1: OGRDataSourceH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_DS_GetSummaryRefCount(arg1: OGRDataSourceH) -> ::std::ffi::c_int;
}
extern "C" {
    #[doc = " @endcond */\n/** Flush pending changes to disk. See GDALDataset::FlushCache()"]
    pub fn OGR_DS_SyncToDisk(arg1: OGRDataSourceH) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Get style table"]
    pub fn OGR_DS_GetStyleTable(arg1: OGRDataSourceH) -> OGRStyleTableH;
}
extern "C" {
    #[doc = " Set style table (and take ownership)"]
    pub fn OGR_DS_SetStyleTableDirectly(arg1: OGRDataSourceH, arg2: OGRStyleTableH);
}
extern "C" {
    #[doc = " Set style table"]
    pub fn OGR_DS_SetStyleTable(arg1: OGRDataSourceH, arg2: OGRStyleTableH);
}
extern "C" {
    pub fn OGR_Dr_GetName(arg1: OGRSFDriverH) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn OGR_Dr_Open(
        arg1: OGRSFDriverH,
        arg2: *const ::std::ffi::c_char,
        arg3: ::std::ffi::c_int,
    ) -> OGRDataSourceH;
}
extern "C" {
    pub fn OGR_Dr_TestCapability(
        arg1: OGRSFDriverH,
        arg2: *const ::std::ffi::c_char,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_Dr_CreateDataSource(
        arg1: OGRSFDriverH,
        arg2: *const ::std::ffi::c_char,
        arg3: *mut *mut ::std::ffi::c_char,
    ) -> OGRDataSourceH;
}
extern "C" {
    pub fn OGR_Dr_CopyDataSource(
        arg1: OGRSFDriverH,
        arg2: OGRDataSourceH,
        arg3: *const ::std::ffi::c_char,
        arg4: *mut *mut ::std::ffi::c_char,
    ) -> OGRDataSourceH;
}
extern "C" {
    pub fn OGR_Dr_DeleteDataSource(
        arg1: OGRSFDriverH,
        arg2: *const ::std::ffi::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGROpen(
        arg1: *const ::std::ffi::c_char,
        arg2: ::std::ffi::c_int,
        arg3: *mut OGRSFDriverH,
    ) -> OGRDataSourceH;
}
extern "C" {
    pub fn OGROpenShared(
        arg1: *const ::std::ffi::c_char,
        arg2: ::std::ffi::c_int,
        arg3: *mut OGRSFDriverH,
    ) -> OGRDataSourceH;
}
extern "C" {
    pub fn OGRReleaseDataSource(arg1: OGRDataSourceH) -> OGRErr::Type;
}
extern "C" {
    #[doc = " @cond Doxygen_Suppress"]
    pub fn OGRRegisterDriver(arg1: OGRSFDriverH);
}
extern "C" {
    pub fn OGRDeregisterDriver(arg1: OGRSFDriverH);
}
extern "C" {
    #[doc = " @endcond"]
    pub fn OGRGetDriverCount() -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGRGetDriver(arg1: ::std::ffi::c_int) -> OGRSFDriverH;
}
extern "C" {
    pub fn OGRGetDriverByName(arg1: *const ::std::ffi::c_char) -> OGRSFDriverH;
}
extern "C" {
    #[doc = " @cond Doxygen_Suppress"]
    pub fn OGRGetOpenDSCount() -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGRGetOpenDS(iDS: ::std::ffi::c_int) -> OGRDataSourceH;
}
extern "C" {
    #[doc = " @endcond"]
    pub fn OGRRegisterAll();
}
extern "C" {
    #[doc = " Clean-up all drivers (including raster ones starting with GDAL 2.0.\n See GDALDestroyDriverManager()"]
    pub fn OGRCleanupAll();
}
#[doc = " Style manager opaque type"]
pub type OGRStyleMgrH = *mut ::std::ffi::c_void;
#[doc = " Style tool opaque type"]
pub type OGRStyleToolH = *mut ::std::ffi::c_void;
extern "C" {
    pub fn OGR_SM_Create(hStyleTable: OGRStyleTableH) -> OGRStyleMgrH;
}
extern "C" {
    pub fn OGR_SM_Destroy(hSM: OGRStyleMgrH);
}
extern "C" {
    pub fn OGR_SM_InitFromFeature(
        hSM: OGRStyleMgrH,
        hFeat: OGRFeatureH,
    ) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn OGR_SM_InitStyleString(
        hSM: OGRStyleMgrH,
        pszStyleString: *const ::std::ffi::c_char,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_SM_GetPartCount(
        hSM: OGRStyleMgrH,
        pszStyleString: *const ::std::ffi::c_char,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_SM_GetPart(
        hSM: OGRStyleMgrH,
        nPartId: ::std::ffi::c_int,
        pszStyleString: *const ::std::ffi::c_char,
    ) -> OGRStyleToolH;
}
extern "C" {
    pub fn OGR_SM_AddPart(hSM: OGRStyleMgrH, hST: OGRStyleToolH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_SM_AddStyle(
        hSM: OGRStyleMgrH,
        pszStyleName: *const ::std::ffi::c_char,
        pszStyleString: *const ::std::ffi::c_char,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_ST_Create(eClassId: OGRSTClassId) -> OGRStyleToolH;
}
extern "C" {
    pub fn OGR_ST_Destroy(hST: OGRStyleToolH);
}
extern "C" {
    pub fn OGR_ST_GetType(hST: OGRStyleToolH) -> OGRSTClassId;
}
extern "C" {
    pub fn OGR_ST_GetUnit(hST: OGRStyleToolH) -> OGRSTUnitId;
}
extern "C" {
    pub fn OGR_ST_SetUnit(hST: OGRStyleToolH, eUnit: OGRSTUnitId, dfGroundPaperScale: f64);
}
extern "C" {
    pub fn OGR_ST_GetParamStr(
        hST: OGRStyleToolH,
        eParam: ::std::ffi::c_int,
        bValueIsNull: *mut ::std::ffi::c_int,
    ) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn OGR_ST_GetParamNum(
        hST: OGRStyleToolH,
        eParam: ::std::ffi::c_int,
        bValueIsNull: *mut ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_ST_GetParamDbl(
        hST: OGRStyleToolH,
        eParam: ::std::ffi::c_int,
        bValueIsNull: *mut ::std::ffi::c_int,
    ) -> f64;
}
extern "C" {
    pub fn OGR_ST_SetParamStr(
        hST: OGRStyleToolH,
        eParam: ::std::ffi::c_int,
        pszValue: *const ::std::ffi::c_char,
    );
}
extern "C" {
    pub fn OGR_ST_SetParamNum(
        hST: OGRStyleToolH,
        eParam: ::std::ffi::c_int,
        nValue: ::std::ffi::c_int,
    );
}
extern "C" {
    pub fn OGR_ST_SetParamDbl(hST: OGRStyleToolH, eParam: ::std::ffi::c_int, dfValue: f64);
}
extern "C" {
    pub fn OGR_ST_GetStyleString(hST: OGRStyleToolH) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn OGR_ST_GetRGBFromString(
        hST: OGRStyleToolH,
        pszColor: *const ::std::ffi::c_char,
        pnRed: *mut ::std::ffi::c_int,
        pnGreen: *mut ::std::ffi::c_int,
        pnBlue: *mut ::std::ffi::c_int,
        pnAlpha: *mut ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_STBL_Create() -> OGRStyleTableH;
}
extern "C" {
    pub fn OGR_STBL_Destroy(hSTBL: OGRStyleTableH);
}
extern "C" {
    pub fn OGR_STBL_AddStyle(
        hStyleTable: OGRStyleTableH,
        pszName: *const ::std::ffi::c_char,
        pszStyleString: *const ::std::ffi::c_char,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_STBL_SaveStyleTable(
        hStyleTable: OGRStyleTableH,
        pszFilename: *const ::std::ffi::c_char,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_STBL_LoadStyleTable(
        hStyleTable: OGRStyleTableH,
        pszFilename: *const ::std::ffi::c_char,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OGR_STBL_Find(
        hStyleTable: OGRStyleTableH,
        pszName: *const ::std::ffi::c_char,
    ) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn OGR_STBL_ResetStyleStringReading(hStyleTable: OGRStyleTableH);
}
extern "C" {
    pub fn OGR_STBL_GetNextStyle(hStyleTable: OGRStyleTableH) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn OGR_STBL_GetLastStyleName(hStyleTable: OGRStyleTableH) -> *const ::std::ffi::c_char;
}
pub mod GDALDataType {
    #[doc = " Pixel data types"]
    pub type Type = ::std::ffi::c_uint;
    #[doc = " Unknown or unspecified type"]
    pub const GDT_Unknown: Type = 0;
    #[doc = " Eight bit unsigned integer"]
    pub const GDT_Byte: Type = 1;
    #[doc = " Sixteen bit unsigned integer"]
    pub const GDT_UInt16: Type = 2;
    #[doc = " Sixteen bit signed integer"]
    pub const GDT_Int16: Type = 3;
    #[doc = " Thirty two bit unsigned integer"]
    pub const GDT_UInt32: Type = 4;
    #[doc = " Thirty two bit signed integer"]
    pub const GDT_Int32: Type = 5;
    #[doc = " 64 bit unsigned integer (GDAL >= 3.5)"]
    pub const GDT_UInt64: Type = 12;
    #[doc = " 64 bit signed integer  (GDAL >= 3.5)"]
    pub const GDT_Int64: Type = 13;
    #[doc = " Thirty two bit floating point"]
    pub const GDT_Float32: Type = 6;
    #[doc = " Sixty four bit floating point"]
    pub const GDT_Float64: Type = 7;
    #[doc = " Complex Int16"]
    pub const GDT_CInt16: Type = 8;
    #[doc = " Complex Int32"]
    pub const GDT_CInt32: Type = 9;
    #[doc = " Complex Float32"]
    pub const GDT_CFloat32: Type = 10;
    #[doc = " Complex Float64"]
    pub const GDT_CFloat64: Type = 11;
    #[doc = " Complex Float64"]
    pub const GDT_TypeCount: Type = 14;
}
extern "C" {
    pub fn GDALGetDataTypeSize(arg1: GDALDataType::Type) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALGetDataTypeSizeBits(eDataType: GDALDataType::Type) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALGetDataTypeSizeBytes(arg1: GDALDataType::Type) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALDataTypeIsComplex(arg1: GDALDataType::Type) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALDataTypeIsInteger(arg1: GDALDataType::Type) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALDataTypeIsFloating(arg1: GDALDataType::Type) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALDataTypeIsSigned(arg1: GDALDataType::Type) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALGetDataTypeName(arg1: GDALDataType::Type) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn GDALGetDataTypeByName(arg1: *const ::std::ffi::c_char) -> GDALDataType::Type;
}
extern "C" {
    pub fn GDALDataTypeUnion(
        arg1: GDALDataType::Type,
        arg2: GDALDataType::Type,
    ) -> GDALDataType::Type;
}
extern "C" {
    pub fn GDALDataTypeUnionWithValue(
        eDT: GDALDataType::Type,
        dValue: f64,
        bComplex: ::std::ffi::c_int,
    ) -> GDALDataType::Type;
}
extern "C" {
    pub fn GDALFindDataType(
        nBits: ::std::ffi::c_int,
        bSigned: ::std::ffi::c_int,
        bFloating: ::std::ffi::c_int,
        bComplex: ::std::ffi::c_int,
    ) -> GDALDataType::Type;
}
extern "C" {
    pub fn GDALFindDataTypeForValue(dValue: f64, bComplex: ::std::ffi::c_int)
        -> GDALDataType::Type;
}
extern "C" {
    pub fn GDALAdjustValueToDataType(
        eDT: GDALDataType::Type,
        dfValue: f64,
        pbClamped: *mut ::std::ffi::c_int,
        pbRounded: *mut ::std::ffi::c_int,
    ) -> f64;
}
extern "C" {
    pub fn GDALGetNonComplexDataType(arg1: GDALDataType::Type) -> GDALDataType::Type;
}
extern "C" {
    pub fn GDALDataTypeIsConversionLossy(
        eTypeFrom: GDALDataType::Type,
        eTypeTo: GDALDataType::Type,
    ) -> ::std::ffi::c_int;
}
pub mod GDALAsyncStatusType {
    #[doc = " status of the asynchronous stream"]
    pub type Type = ::std::ffi::c_uint;
    pub const GARIO_PENDING: Type = 0;
    pub const GARIO_UPDATE: Type = 1;
    pub const GARIO_ERROR: Type = 2;
    pub const GARIO_COMPLETE: Type = 3;
    pub const GARIO_TypeCount: Type = 4;
}
extern "C" {
    pub fn GDALGetAsyncStatusTypeName(arg1: GDALAsyncStatusType::Type)
        -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn GDALGetAsyncStatusTypeByName(
        arg1: *const ::std::ffi::c_char,
    ) -> GDALAsyncStatusType::Type;
}
pub mod GDALAccess {
    #[doc = " Flag indicating read/write, or read-only access to data."]
    pub type Type = ::std::ffi::c_uint;
    #[doc = " Read only (no update) access"]
    pub const GA_ReadOnly: Type = 0;
    #[doc = " Read/write access."]
    pub const GA_Update: Type = 1;
}
pub mod GDALRWFlag {
    #[doc = " Read/Write flag for RasterIO() method"]
    pub type Type = ::std::ffi::c_uint;
    #[doc = " Read data"]
    pub const GF_Read: Type = 0;
    #[doc = " Write data"]
    pub const GF_Write: Type = 1;
}
pub mod GDALRIOResampleAlg {
    #[doc = " RasterIO() resampling method.\n @since GDAL 2.0"]
    pub type Type = ::std::ffi::c_uint;
    #[doc = " Nearest neighbour"]
    pub const GRIORA_NearestNeighbour: Type = 0;
    #[doc = " Bilinear (2x2 kernel)"]
    pub const GRIORA_Bilinear: Type = 1;
    #[doc = " Cubic Convolution Approximation (4x4 kernel)"]
    pub const GRIORA_Cubic: Type = 2;
    #[doc = " Cubic B-Spline Approximation (4x4 kernel)"]
    pub const GRIORA_CubicSpline: Type = 3;
    #[doc = " Lanczos windowed sinc interpolation (6x6 kernel)"]
    pub const GRIORA_Lanczos: Type = 4;
    #[doc = " Average"]
    pub const GRIORA_Average: Type = 5;
    #[doc = " Mode (selects the value which appears most often of all the sampled points)"]
    pub const GRIORA_Mode: Type = 6;
    #[doc = " Gauss blurring"]
    pub const GRIORA_Gauss: Type = 7;
    #[doc = " @cond Doxygen_Suppress"]
    pub const GRIORA_RESERVED_START: Type = 8;
    #[doc = " @cond Doxygen_Suppress"]
    pub const GRIORA_RESERVED_END: Type = 13;
    #[doc = " @endcond */\n/** RMS: Root Mean Square / Quadratic Mean.\n For complex numbers, applies on the real and imaginary part independently."]
    pub const GRIORA_RMS: Type = 14;
    #[doc = " @cond Doxygen_Suppress"]
    pub const GRIORA_LAST: Type = 14;
}
#[doc = " Structure to pass extra arguments to RasterIO() method,\n must be initialized with INIT_RASTERIO_EXTRA_ARG\n @since GDAL 2.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALRasterIOExtraArg {
    #[doc = " Version of structure (to allow future extensions of the structure)"]
    pub nVersion: ::std::ffi::c_int,
    #[doc = " Resampling algorithm"]
    pub eResampleAlg: GDALRIOResampleAlg::Type,
    #[doc = " Progress callback"]
    pub pfnProgress: GDALProgressFunc,
    #[doc = " Progress callback user data"]
    pub pProgressData: *mut ::std::ffi::c_void,
    #[doc = " Indicate if dfXOff, dfYOff, dfXSize and dfYSize are set.\nMostly reserved from the VRT driver to communicate a more precise\nsource window. Must be such that dfXOff - nXOff < 1.0 and\ndfYOff - nYOff < 1.0 and nXSize - dfXSize < 1.0 and nYSize - dfYSize < 1.0"]
    pub bFloatingPointWindowValidity: ::std::ffi::c_int,
    #[doc = " Pixel offset to the top left corner. Only valid if bFloatingPointWindowValidity = TRUE"]
    pub dfXOff: f64,
    #[doc = " Line offset to the top left corner. Only valid if bFloatingPointWindowValidity = TRUE"]
    pub dfYOff: f64,
    #[doc = " Width in pixels of the area of interest. Only valid if bFloatingPointWindowValidity = TRUE"]
    pub dfXSize: f64,
    #[doc = " Height in pixels of the area of interest. Only valid if bFloatingPointWindowValidity = TRUE"]
    pub dfYSize: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GDALRasterIOExtraArg"][::std::mem::size_of::<GDALRasterIOExtraArg>() - 52usize];
    ["Alignment of GDALRasterIOExtraArg"][::std::mem::align_of::<GDALRasterIOExtraArg>() - 4usize];
    ["Offset of field: GDALRasterIOExtraArg::nVersion"]
        [::std::mem::offset_of!(GDALRasterIOExtraArg, nVersion) - 0usize];
    ["Offset of field: GDALRasterIOExtraArg::eResampleAlg"]
        [::std::mem::offset_of!(GDALRasterIOExtraArg, eResampleAlg) - 4usize];
    ["Offset of field: GDALRasterIOExtraArg::pfnProgress"]
        [::std::mem::offset_of!(GDALRasterIOExtraArg, pfnProgress) - 8usize];
    ["Offset of field: GDALRasterIOExtraArg::pProgressData"]
        [::std::mem::offset_of!(GDALRasterIOExtraArg, pProgressData) - 12usize];
    ["Offset of field: GDALRasterIOExtraArg::bFloatingPointWindowValidity"]
        [::std::mem::offset_of!(GDALRasterIOExtraArg, bFloatingPointWindowValidity) - 16usize];
    ["Offset of field: GDALRasterIOExtraArg::dfXOff"]
        [::std::mem::offset_of!(GDALRasterIOExtraArg, dfXOff) - 20usize];
    ["Offset of field: GDALRasterIOExtraArg::dfYOff"]
        [::std::mem::offset_of!(GDALRasterIOExtraArg, dfYOff) - 28usize];
    ["Offset of field: GDALRasterIOExtraArg::dfXSize"]
        [::std::mem::offset_of!(GDALRasterIOExtraArg, dfXSize) - 36usize];
    ["Offset of field: GDALRasterIOExtraArg::dfYSize"]
        [::std::mem::offset_of!(GDALRasterIOExtraArg, dfYSize) - 44usize];
};
pub mod GDALColorInterp {
    #[doc = " Types of color interpretation for raster bands."]
    pub type Type = ::std::ffi::c_uint;
    #[doc = " Undefined"]
    pub const GCI_Undefined: Type = 0;
    #[doc = " Greyscale"]
    pub const GCI_GrayIndex: Type = 1;
    #[doc = " Paletted (see associated color table)"]
    pub const GCI_PaletteIndex: Type = 2;
    #[doc = " Red band of RGBA image"]
    pub const GCI_RedBand: Type = 3;
    #[doc = " Green band of RGBA image"]
    pub const GCI_GreenBand: Type = 4;
    #[doc = " Blue band of RGBA image"]
    pub const GCI_BlueBand: Type = 5;
    #[doc = " Alpha (0=transparent, 255=opaque)"]
    pub const GCI_AlphaBand: Type = 6;
    #[doc = " Hue band of HLS image"]
    pub const GCI_HueBand: Type = 7;
    #[doc = " Saturation band of HLS image"]
    pub const GCI_SaturationBand: Type = 8;
    #[doc = " Lightness band of HLS image"]
    pub const GCI_LightnessBand: Type = 9;
    #[doc = " Cyan band of CMYK image"]
    pub const GCI_CyanBand: Type = 10;
    #[doc = " Magenta band of CMYK image"]
    pub const GCI_MagentaBand: Type = 11;
    #[doc = " Yellow band of CMYK image"]
    pub const GCI_YellowBand: Type = 12;
    #[doc = " Black band of CMYK image"]
    pub const GCI_BlackBand: Type = 13;
    #[doc = " Y Luminance"]
    pub const GCI_YCbCr_YBand: Type = 14;
    #[doc = " Cb Chroma"]
    pub const GCI_YCbCr_CbBand: Type = 15;
    #[doc = " Cr Chroma"]
    pub const GCI_YCbCr_CrBand: Type = 16;
    #[doc = " Max current value (equals to GCI_YCbCr_CrBand currently)"]
    pub const GCI_Max: Type = 16;
}
extern "C" {
    pub fn GDALGetColorInterpretationName(arg1: GDALColorInterp::Type)
        -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn GDALGetColorInterpretationByName(
        pszName: *const ::std::ffi::c_char,
    ) -> GDALColorInterp::Type;
}
pub mod GDALPaletteInterp {
    #[doc = " Types of color interpretations for a GDALColorTable."]
    pub type Type = ::std::ffi::c_uint;
    #[doc = " Grayscale (in GDALColorEntry.c1)"]
    pub const GPI_Gray: Type = 0;
    #[doc = " Red, Green, Blue and Alpha in (in c1, c2, c3 and c4)"]
    pub const GPI_RGB: Type = 1;
    #[doc = " Cyan, Magenta, Yellow and Black (in c1, c2, c3 and c4)"]
    pub const GPI_CMYK: Type = 2;
    #[doc = " Hue, Lightness and Saturation (in c1, c2, and c3)"]
    pub const GPI_HLS: Type = 3;
}
extern "C" {
    pub fn GDALGetPaletteInterpretationName(
        arg1: GDALPaletteInterp::Type,
    ) -> *const ::std::ffi::c_char;
}
#[doc = " Opaque type used for the C bindings of the C++ GDALMajorObject class"]
pub type GDALMajorObjectH = *mut ::std::ffi::c_void;
#[doc = " Opaque type used for the C bindings of the C++ GDALDataset class"]
pub type GDALDatasetH = *mut ::std::ffi::c_void;
#[doc = " Opaque type used for the C bindings of the C++ GDALRasterBand class"]
pub type GDALRasterBandH = *mut ::std::ffi::c_void;
#[doc = " Opaque type used for the C bindings of the C++ GDALDriver class"]
pub type GDALDriverH = *mut ::std::ffi::c_void;
#[doc = " Opaque type used for the C bindings of the C++ GDALColorTable class"]
pub type GDALColorTableH = *mut ::std::ffi::c_void;
#[doc = " Opaque type used for the C bindings of the C++ GDALRasterAttributeTable class"]
pub type GDALRasterAttributeTableH = *mut ::std::ffi::c_void;
#[doc = " Opaque type used for the C bindings of the C++ GDALAsyncReader class"]
pub type GDALAsyncReaderH = *mut ::std::ffi::c_void;
#[doc = " Type to express pixel, line or band spacing. Signed 64 bit integer."]
pub type GSpacing = GIntBig;
pub mod GDALExtendedDataTypeClass {
    #[doc = " Enumeration giving the class of a GDALExtendedDataType.\n @since GDAL 3.1"]
    pub type Type = ::std::ffi::c_uint;
    #[doc = " Numeric value. Based on GDALDataType enumeration"]
    pub const GEDTC_NUMERIC: Type = 0;
    #[doc = " String value."]
    pub const GEDTC_STRING: Type = 1;
    #[doc = " Compound data type."]
    pub const GEDTC_COMPOUND: Type = 2;
}
pub mod GDALExtendedDataTypeSubType {
    #[doc = " Enumeration giving the subtype of a GDALExtendedDataType.\n @since GDAL 3.4"]
    pub type Type = ::std::ffi::c_uint;
    #[doc = " None."]
    pub const GEDTST_NONE: Type = 0;
    #[doc = " JSon. Only applies to GEDTC_STRING"]
    pub const GEDTST_JSON: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALExtendedDataTypeHS {
    _unused: [u8; 0],
}
#[doc = " Opaque type for C++ GDALExtendedDataType"]
pub type GDALExtendedDataTypeH = *mut GDALExtendedDataTypeHS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALEDTComponentHS {
    _unused: [u8; 0],
}
#[doc = " Opaque type for C++ GDALEDTComponent"]
pub type GDALEDTComponentH = *mut GDALEDTComponentHS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALGroupHS {
    _unused: [u8; 0],
}
#[doc = " Opaque type for C++ GDALGroup"]
pub type GDALGroupH = *mut GDALGroupHS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALMDArrayHS {
    _unused: [u8; 0],
}
#[doc = " Opaque type for C++ GDALMDArray"]
pub type GDALMDArrayH = *mut GDALMDArrayHS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALAttributeHS {
    _unused: [u8; 0],
}
#[doc = " Opaque type for C++ GDALAttribute"]
pub type GDALAttributeH = *mut GDALAttributeHS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALDimensionHS {
    _unused: [u8; 0],
}
#[doc = " Opaque type for C++ GDALDimension"]
pub type GDALDimensionH = *mut GDALDimensionHS;
extern "C" {
    pub fn GDALAllRegister();
}
extern "C" {
    pub fn GDALCreate(
        hDriver: GDALDriverH,
        arg1: *const ::std::ffi::c_char,
        arg2: ::std::ffi::c_int,
        arg3: ::std::ffi::c_int,
        arg4: ::std::ffi::c_int,
        arg5: GDALDataType::Type,
        arg6: CSLConstList,
    ) -> GDALDatasetH;
}
extern "C" {
    pub fn GDALCreateCopy(
        arg1: GDALDriverH,
        arg2: *const ::std::ffi::c_char,
        arg3: GDALDatasetH,
        arg4: ::std::ffi::c_int,
        arg5: CSLConstList,
        arg6: GDALProgressFunc,
        arg7: *mut ::std::ffi::c_void,
    ) -> GDALDatasetH;
}
extern "C" {
    pub fn GDALIdentifyDriver(
        pszFilename: *const ::std::ffi::c_char,
        papszFileList: CSLConstList,
    ) -> GDALDriverH;
}
extern "C" {
    pub fn GDALIdentifyDriverEx(
        pszFilename: *const ::std::ffi::c_char,
        nIdentifyFlags: ::std::ffi::c_uint,
        papszAllowedDrivers: *const *const ::std::ffi::c_char,
        papszFileList: *const *const ::std::ffi::c_char,
    ) -> GDALDriverH;
}
extern "C" {
    pub fn GDALOpen(
        pszFilename: *const ::std::ffi::c_char,
        eAccess: GDALAccess::Type,
    ) -> GDALDatasetH;
}
extern "C" {
    pub fn GDALOpenShared(arg1: *const ::std::ffi::c_char, arg2: GDALAccess::Type) -> GDALDatasetH;
}
extern "C" {
    pub fn GDALOpenEx(
        pszFilename: *const ::std::ffi::c_char,
        nOpenFlags: ::std::ffi::c_uint,
        papszAllowedDrivers: *const *const ::std::ffi::c_char,
        papszOpenOptions: *const *const ::std::ffi::c_char,
        papszSiblingFiles: *const *const ::std::ffi::c_char,
    ) -> GDALDatasetH;
}
extern "C" {
    pub fn GDALDumpOpenDatasets(arg1: *mut FILE) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALGetDriverByName(arg1: *const ::std::ffi::c_char) -> GDALDriverH;
}
extern "C" {
    pub fn GDALGetDriverCount() -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALGetDriver(arg1: ::std::ffi::c_int) -> GDALDriverH;
}
extern "C" {
    pub fn GDALCreateDriver() -> GDALDriverH;
}
extern "C" {
    pub fn GDALDestroyDriver(arg1: GDALDriverH);
}
extern "C" {
    pub fn GDALRegisterDriver(arg1: GDALDriverH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALDeregisterDriver(arg1: GDALDriverH);
}
extern "C" {
    pub fn GDALDestroyDriverManager();
}
extern "C" {
    pub fn GDALDestroy();
}
extern "C" {
    pub fn GDALDeleteDataset(arg1: GDALDriverH, arg2: *const ::std::ffi::c_char) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRenameDataset(
        arg1: GDALDriverH,
        pszNewName: *const ::std::ffi::c_char,
        pszOldName: *const ::std::ffi::c_char,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALCopyDatasetFiles(
        arg1: GDALDriverH,
        pszNewName: *const ::std::ffi::c_char,
        pszOldName: *const ::std::ffi::c_char,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALValidateCreationOptions(
        arg1: GDALDriverH,
        papszCreationOptions: CSLConstList,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALGetDriverShortName(arg1: GDALDriverH) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn GDALGetDriverLongName(arg1: GDALDriverH) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn GDALGetDriverHelpTopic(arg1: GDALDriverH) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn GDALGetDriverCreationOptionList(arg1: GDALDriverH) -> *const ::std::ffi::c_char;
}
#[doc = " Ground Control Point"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDAL_GCP {
    #[doc = " Unique identifier, often numeric"]
    pub pszId: *mut ::std::ffi::c_char,
    #[doc = " Informational message or \"\""]
    pub pszInfo: *mut ::std::ffi::c_char,
    #[doc = " Pixel (x) location of GCP on raster"]
    pub dfGCPPixel: f64,
    #[doc = " Line (y) location of GCP on raster"]
    pub dfGCPLine: f64,
    #[doc = " X position of GCP in georeferenced space"]
    pub dfGCPX: f64,
    #[doc = " Y position of GCP in georeferenced space"]
    pub dfGCPY: f64,
    #[doc = " Elevation of GCP, or zero if not known"]
    pub dfGCPZ: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GDAL_GCP"][::std::mem::size_of::<GDAL_GCP>() - 48usize];
    ["Alignment of GDAL_GCP"][::std::mem::align_of::<GDAL_GCP>() - 4usize];
    ["Offset of field: GDAL_GCP::pszId"][::std::mem::offset_of!(GDAL_GCP, pszId) - 0usize];
    ["Offset of field: GDAL_GCP::pszInfo"][::std::mem::offset_of!(GDAL_GCP, pszInfo) - 4usize];
    ["Offset of field: GDAL_GCP::dfGCPPixel"]
        [::std::mem::offset_of!(GDAL_GCP, dfGCPPixel) - 8usize];
    ["Offset of field: GDAL_GCP::dfGCPLine"][::std::mem::offset_of!(GDAL_GCP, dfGCPLine) - 16usize];
    ["Offset of field: GDAL_GCP::dfGCPX"][::std::mem::offset_of!(GDAL_GCP, dfGCPX) - 24usize];
    ["Offset of field: GDAL_GCP::dfGCPY"][::std::mem::offset_of!(GDAL_GCP, dfGCPY) - 32usize];
    ["Offset of field: GDAL_GCP::dfGCPZ"][::std::mem::offset_of!(GDAL_GCP, dfGCPZ) - 40usize];
};
extern "C" {
    pub fn GDALInitGCPs(arg1: ::std::ffi::c_int, arg2: *mut GDAL_GCP);
}
extern "C" {
    pub fn GDALDeinitGCPs(arg1: ::std::ffi::c_int, arg2: *mut GDAL_GCP);
}
extern "C" {
    pub fn GDALDuplicateGCPs(arg1: ::std::ffi::c_int, arg2: *const GDAL_GCP) -> *mut GDAL_GCP;
}
extern "C" {
    pub fn GDALGCPsToGeoTransform(
        nGCPCount: ::std::ffi::c_int,
        pasGCPs: *const GDAL_GCP,
        padfGeoTransform: *mut f64,
        bApproxOK: ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALInvGeoTransform(
        padfGeoTransformIn: *mut f64,
        padfInvGeoTransformOut: *mut f64,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALApplyGeoTransform(
        arg1: *mut f64,
        arg2: f64,
        arg3: f64,
        arg4: *mut f64,
        arg5: *mut f64,
    );
}
extern "C" {
    pub fn GDALComposeGeoTransforms(
        padfGeoTransform1: *const f64,
        padfGeoTransform2: *const f64,
        padfGeoTransformOut: *mut f64,
    );
}
extern "C" {
    pub fn GDALGetMetadataDomainList(hObject: GDALMajorObjectH) -> *mut *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn GDALGetMetadata(
        arg1: GDALMajorObjectH,
        arg2: *const ::std::ffi::c_char,
    ) -> *mut *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn GDALSetMetadata(
        arg1: GDALMajorObjectH,
        arg2: CSLConstList,
        arg3: *const ::std::ffi::c_char,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetMetadataItem(
        arg1: GDALMajorObjectH,
        arg2: *const ::std::ffi::c_char,
        arg3: *const ::std::ffi::c_char,
    ) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn GDALSetMetadataItem(
        arg1: GDALMajorObjectH,
        arg2: *const ::std::ffi::c_char,
        arg3: *const ::std::ffi::c_char,
        arg4: *const ::std::ffi::c_char,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetDescription(arg1: GDALMajorObjectH) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn GDALSetDescription(arg1: GDALMajorObjectH, arg2: *const ::std::ffi::c_char);
}
extern "C" {
    pub fn GDALGetDatasetDriver(arg1: GDALDatasetH) -> GDALDriverH;
}
extern "C" {
    pub fn GDALGetFileList(arg1: GDALDatasetH) -> *mut *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn GDALClose(arg1: GDALDatasetH);
}
extern "C" {
    pub fn GDALGetRasterXSize(arg1: GDALDatasetH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALGetRasterYSize(arg1: GDALDatasetH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALGetRasterCount(arg1: GDALDatasetH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALGetRasterBand(arg1: GDALDatasetH, arg2: ::std::ffi::c_int) -> GDALRasterBandH;
}
extern "C" {
    pub fn GDALAddBand(
        hDS: GDALDatasetH,
        eType: GDALDataType::Type,
        papszOptions: CSLConstList,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALBeginAsyncReader(
        hDS: GDALDatasetH,
        nXOff: ::std::ffi::c_int,
        nYOff: ::std::ffi::c_int,
        nXSize: ::std::ffi::c_int,
        nYSize: ::std::ffi::c_int,
        pBuf: *mut ::std::ffi::c_void,
        nBufXSize: ::std::ffi::c_int,
        nBufYSize: ::std::ffi::c_int,
        eBufType: GDALDataType::Type,
        nBandCount: ::std::ffi::c_int,
        panBandMap: *mut ::std::ffi::c_int,
        nPixelSpace: ::std::ffi::c_int,
        nLineSpace: ::std::ffi::c_int,
        nBandSpace: ::std::ffi::c_int,
        papszOptions: CSLConstList,
    ) -> GDALAsyncReaderH;
}
extern "C" {
    pub fn GDALEndAsyncReader(hDS: GDALDatasetH, hAsynchReaderH: GDALAsyncReaderH);
}
extern "C" {
    pub fn GDALDatasetRasterIO(
        hDS: GDALDatasetH,
        eRWFlag: GDALRWFlag::Type,
        nDSXOff: ::std::ffi::c_int,
        nDSYOff: ::std::ffi::c_int,
        nDSXSize: ::std::ffi::c_int,
        nDSYSize: ::std::ffi::c_int,
        pBuffer: *mut ::std::ffi::c_void,
        nBXSize: ::std::ffi::c_int,
        nBYSize: ::std::ffi::c_int,
        eBDataType: GDALDataType::Type,
        nBandCount: ::std::ffi::c_int,
        panBandCount: *mut ::std::ffi::c_int,
        nPixelSpace: ::std::ffi::c_int,
        nLineSpace: ::std::ffi::c_int,
        nBandSpace: ::std::ffi::c_int,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALDatasetRasterIOEx(
        hDS: GDALDatasetH,
        eRWFlag: GDALRWFlag::Type,
        nDSXOff: ::std::ffi::c_int,
        nDSYOff: ::std::ffi::c_int,
        nDSXSize: ::std::ffi::c_int,
        nDSYSize: ::std::ffi::c_int,
        pBuffer: *mut ::std::ffi::c_void,
        nBXSize: ::std::ffi::c_int,
        nBYSize: ::std::ffi::c_int,
        eBDataType: GDALDataType::Type,
        nBandCount: ::std::ffi::c_int,
        panBandCount: *mut ::std::ffi::c_int,
        nPixelSpace: GSpacing,
        nLineSpace: GSpacing,
        nBandSpace: GSpacing,
        psExtraArg: *mut GDALRasterIOExtraArg,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALDatasetAdviseRead(
        hDS: GDALDatasetH,
        nDSXOff: ::std::ffi::c_int,
        nDSYOff: ::std::ffi::c_int,
        nDSXSize: ::std::ffi::c_int,
        nDSYSize: ::std::ffi::c_int,
        nBXSize: ::std::ffi::c_int,
        nBYSize: ::std::ffi::c_int,
        eBDataType: GDALDataType::Type,
        nBandCount: ::std::ffi::c_int,
        panBandCount: *mut ::std::ffi::c_int,
        papszOptions: CSLConstList,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetProjectionRef(arg1: GDALDatasetH) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn GDALGetSpatialRef(arg1: GDALDatasetH) -> OGRSpatialReferenceH;
}
extern "C" {
    pub fn GDALSetProjection(arg1: GDALDatasetH, arg2: *const ::std::ffi::c_char) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALSetSpatialRef(arg1: GDALDatasetH, arg2: OGRSpatialReferenceH) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetGeoTransform(arg1: GDALDatasetH, arg2: *mut f64) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALSetGeoTransform(arg1: GDALDatasetH, arg2: *mut f64) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetGCPCount(arg1: GDALDatasetH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALGetGCPProjection(arg1: GDALDatasetH) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn GDALGetGCPSpatialRef(arg1: GDALDatasetH) -> OGRSpatialReferenceH;
}
extern "C" {
    pub fn GDALGetGCPs(arg1: GDALDatasetH) -> *const GDAL_GCP;
}
extern "C" {
    pub fn GDALSetGCPs(
        arg1: GDALDatasetH,
        arg2: ::std::ffi::c_int,
        arg3: *const GDAL_GCP,
        arg4: *const ::std::ffi::c_char,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALSetGCPs2(
        arg1: GDALDatasetH,
        arg2: ::std::ffi::c_int,
        arg3: *const GDAL_GCP,
        arg4: OGRSpatialReferenceH,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetInternalHandle(
        arg1: GDALDatasetH,
        arg2: *const ::std::ffi::c_char,
    ) -> *mut ::std::ffi::c_void;
}
extern "C" {
    pub fn GDALReferenceDataset(arg1: GDALDatasetH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALDereferenceDataset(arg1: GDALDatasetH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALReleaseDataset(arg1: GDALDatasetH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALBuildOverviews(
        arg1: GDALDatasetH,
        arg2: *const ::std::ffi::c_char,
        arg3: ::std::ffi::c_int,
        arg4: *mut ::std::ffi::c_int,
        arg5: ::std::ffi::c_int,
        arg6: *mut ::std::ffi::c_int,
        arg7: GDALProgressFunc,
        arg8: *mut ::std::ffi::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetOpenDatasets(hDS: *mut *mut GDALDatasetH, pnCount: *mut ::std::ffi::c_int);
}
extern "C" {
    pub fn GDALGetAccess(hDS: GDALDatasetH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALFlushCache(hDS: GDALDatasetH);
}
extern "C" {
    pub fn GDALCreateDatasetMaskBand(hDS: GDALDatasetH, nFlags: ::std::ffi::c_int) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALDatasetCopyWholeRaster(
        hSrcDS: GDALDatasetH,
        hDstDS: GDALDatasetH,
        papszOptions: CSLConstList,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut ::std::ffi::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRasterBandCopyWholeRaster(
        hSrcBand: GDALRasterBandH,
        hDstBand: GDALRasterBandH,
        constpapszOptions: *const *const ::std::ffi::c_char,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut ::std::ffi::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRegenerateOverviews(
        hSrcBand: GDALRasterBandH,
        nOverviewCount: ::std::ffi::c_int,
        pahOverviewBands: *mut GDALRasterBandH,
        pszResampling: *const ::std::ffi::c_char,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut ::std::ffi::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALDatasetGetLayerCount(arg1: GDALDatasetH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALDatasetGetLayer(arg1: GDALDatasetH, arg2: ::std::ffi::c_int) -> OGRLayerH;
}
extern "C" {
    pub fn GDALDatasetGetLayerByName(
        arg1: GDALDatasetH,
        arg2: *const ::std::ffi::c_char,
    ) -> OGRLayerH;
}
extern "C" {
    pub fn GDALDatasetIsLayerPrivate(
        arg1: GDALDatasetH,
        arg2: ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALDatasetDeleteLayer(arg1: GDALDatasetH, arg2: ::std::ffi::c_int) -> OGRErr::Type;
}
extern "C" {
    pub fn GDALDatasetCreateLayer(
        arg1: GDALDatasetH,
        arg2: *const ::std::ffi::c_char,
        arg3: OGRSpatialReferenceH,
        arg4: OGRwkbGeometryType::Type,
        arg5: CSLConstList,
    ) -> OGRLayerH;
}
extern "C" {
    pub fn GDALDatasetCopyLayer(
        arg1: GDALDatasetH,
        arg2: OGRLayerH,
        arg3: *const ::std::ffi::c_char,
        arg4: CSLConstList,
    ) -> OGRLayerH;
}
extern "C" {
    pub fn GDALDatasetResetReading(arg1: GDALDatasetH);
}
extern "C" {
    pub fn GDALDatasetGetNextFeature(
        hDS: GDALDatasetH,
        phBelongingLayer: *mut OGRLayerH,
        pdfProgressPct: *mut f64,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut ::std::ffi::c_void,
    ) -> OGRFeatureH;
}
extern "C" {
    pub fn GDALDatasetTestCapability(
        arg1: GDALDatasetH,
        arg2: *const ::std::ffi::c_char,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALDatasetExecuteSQL(
        arg1: GDALDatasetH,
        arg2: *const ::std::ffi::c_char,
        arg3: OGRGeometryH,
        arg4: *const ::std::ffi::c_char,
    ) -> OGRLayerH;
}
extern "C" {
    pub fn GDALDatasetAbortSQL(arg1: GDALDatasetH) -> OGRErr::Type;
}
extern "C" {
    pub fn GDALDatasetReleaseResultSet(arg1: GDALDatasetH, arg2: OGRLayerH);
}
extern "C" {
    pub fn GDALDatasetGetStyleTable(arg1: GDALDatasetH) -> OGRStyleTableH;
}
extern "C" {
    pub fn GDALDatasetSetStyleTableDirectly(arg1: GDALDatasetH, arg2: OGRStyleTableH);
}
extern "C" {
    pub fn GDALDatasetSetStyleTable(arg1: GDALDatasetH, arg2: OGRStyleTableH);
}
extern "C" {
    pub fn GDALDatasetStartTransaction(
        hDS: GDALDatasetH,
        bForce: ::std::ffi::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn GDALDatasetCommitTransaction(hDS: GDALDatasetH) -> OGRErr::Type;
}
extern "C" {
    pub fn GDALDatasetRollbackTransaction(hDS: GDALDatasetH) -> OGRErr::Type;
}
extern "C" {
    pub fn GDALDatasetClearStatistics(hDS: GDALDatasetH);
}
extern "C" {
    pub fn GDALDatasetGetFieldDomainNames(
        arg1: GDALDatasetH,
        arg2: CSLConstList,
    ) -> *mut *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn GDALDatasetGetFieldDomain(
        hDS: GDALDatasetH,
        pszName: *const ::std::ffi::c_char,
    ) -> OGRFieldDomainH;
}
extern "C" {
    pub fn GDALDatasetAddFieldDomain(
        hDS: GDALDatasetH,
        hFieldDomain: OGRFieldDomainH,
        ppszFailureReason: *mut *mut ::std::ffi::c_char,
    ) -> bool;
}
extern "C" {
    pub fn GDALDatasetDeleteFieldDomain(
        hDS: GDALDatasetH,
        pszName: *const ::std::ffi::c_char,
        ppszFailureReason: *mut *mut ::std::ffi::c_char,
    ) -> bool;
}
extern "C" {
    pub fn GDALDatasetUpdateFieldDomain(
        hDS: GDALDatasetH,
        hFieldDomain: OGRFieldDomainH,
        ppszFailureReason: *mut *mut ::std::ffi::c_char,
    ) -> bool;
}
#[doc = " Type of functions to pass to GDALAddDerivedBandPixelFunc.\n @since GDAL 2.2"]
pub type GDALDerivedPixelFunc = ::std::option::Option<
    unsafe extern "C" fn(
        papoSources: *mut *mut ::std::ffi::c_void,
        nSources: ::std::ffi::c_int,
        pData: *mut ::std::ffi::c_void,
        nBufXSize: ::std::ffi::c_int,
        nBufYSize: ::std::ffi::c_int,
        eSrcType: GDALDataType::Type,
        eBufType: GDALDataType::Type,
        nPixelSpace: ::std::ffi::c_int,
        nLineSpace: ::std::ffi::c_int,
    ) -> CPLErr::Type,
>;
#[doc = " Type of functions to pass to GDALAddDerivedBandPixelFuncWithArgs.\n @since GDAL 3.4"]
pub type GDALDerivedPixelFuncWithArgs = ::std::option::Option<
    unsafe extern "C" fn(
        papoSources: *mut *mut ::std::ffi::c_void,
        nSources: ::std::ffi::c_int,
        pData: *mut ::std::ffi::c_void,
        nBufXSize: ::std::ffi::c_int,
        nBufYSize: ::std::ffi::c_int,
        eSrcType: GDALDataType::Type,
        eBufType: GDALDataType::Type,
        nPixelSpace: ::std::ffi::c_int,
        nLineSpace: ::std::ffi::c_int,
        papszFunctionArgs: CSLConstList,
    ) -> CPLErr::Type,
>;
extern "C" {
    pub fn GDALGetRasterDataType(arg1: GDALRasterBandH) -> GDALDataType::Type;
}
extern "C" {
    pub fn GDALGetBlockSize(
        arg1: GDALRasterBandH,
        pnXSize: *mut ::std::ffi::c_int,
        pnYSize: *mut ::std::ffi::c_int,
    );
}
extern "C" {
    pub fn GDALGetActualBlockSize(
        arg1: GDALRasterBandH,
        nXBlockOff: ::std::ffi::c_int,
        nYBlockOff: ::std::ffi::c_int,
        pnXValid: *mut ::std::ffi::c_int,
        pnYValid: *mut ::std::ffi::c_int,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRasterAdviseRead(
        hRB: GDALRasterBandH,
        nDSXOff: ::std::ffi::c_int,
        nDSYOff: ::std::ffi::c_int,
        nDSXSize: ::std::ffi::c_int,
        nDSYSize: ::std::ffi::c_int,
        nBXSize: ::std::ffi::c_int,
        nBYSize: ::std::ffi::c_int,
        eBDataType: GDALDataType::Type,
        papszOptions: CSLConstList,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRasterIO(
        hRBand: GDALRasterBandH,
        eRWFlag: GDALRWFlag::Type,
        nDSXOff: ::std::ffi::c_int,
        nDSYOff: ::std::ffi::c_int,
        nDSXSize: ::std::ffi::c_int,
        nDSYSize: ::std::ffi::c_int,
        pBuffer: *mut ::std::ffi::c_void,
        nBXSize: ::std::ffi::c_int,
        nBYSize: ::std::ffi::c_int,
        eBDataType: GDALDataType::Type,
        nPixelSpace: ::std::ffi::c_int,
        nLineSpace: ::std::ffi::c_int,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRasterIOEx(
        hRBand: GDALRasterBandH,
        eRWFlag: GDALRWFlag::Type,
        nDSXOff: ::std::ffi::c_int,
        nDSYOff: ::std::ffi::c_int,
        nDSXSize: ::std::ffi::c_int,
        nDSYSize: ::std::ffi::c_int,
        pBuffer: *mut ::std::ffi::c_void,
        nBXSize: ::std::ffi::c_int,
        nBYSize: ::std::ffi::c_int,
        eBDataType: GDALDataType::Type,
        nPixelSpace: GSpacing,
        nLineSpace: GSpacing,
        psExtraArg: *mut GDALRasterIOExtraArg,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALReadBlock(
        arg1: GDALRasterBandH,
        arg2: ::std::ffi::c_int,
        arg3: ::std::ffi::c_int,
        arg4: *mut ::std::ffi::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALWriteBlock(
        arg1: GDALRasterBandH,
        arg2: ::std::ffi::c_int,
        arg3: ::std::ffi::c_int,
        arg4: *mut ::std::ffi::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetRasterBandXSize(arg1: GDALRasterBandH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALGetRasterBandYSize(arg1: GDALRasterBandH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALGetRasterAccess(arg1: GDALRasterBandH) -> GDALAccess::Type;
}
extern "C" {
    pub fn GDALGetBandNumber(arg1: GDALRasterBandH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALGetBandDataset(arg1: GDALRasterBandH) -> GDALDatasetH;
}
extern "C" {
    pub fn GDALGetRasterColorInterpretation(arg1: GDALRasterBandH) -> GDALColorInterp::Type;
}
extern "C" {
    pub fn GDALSetRasterColorInterpretation(
        arg1: GDALRasterBandH,
        arg2: GDALColorInterp::Type,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetRasterColorTable(arg1: GDALRasterBandH) -> GDALColorTableH;
}
extern "C" {
    pub fn GDALSetRasterColorTable(arg1: GDALRasterBandH, arg2: GDALColorTableH) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALHasArbitraryOverviews(arg1: GDALRasterBandH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALGetOverviewCount(arg1: GDALRasterBandH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALGetOverview(arg1: GDALRasterBandH, arg2: ::std::ffi::c_int) -> GDALRasterBandH;
}
extern "C" {
    pub fn GDALGetRasterNoDataValue(arg1: GDALRasterBandH, arg2: *mut ::std::ffi::c_int) -> f64;
}
extern "C" {
    pub fn GDALGetRasterNoDataValueAsInt64(
        arg1: GDALRasterBandH,
        arg2: *mut ::std::ffi::c_int,
    ) -> i64;
}
extern "C" {
    pub fn GDALGetRasterNoDataValueAsUInt64(
        arg1: GDALRasterBandH,
        arg2: *mut ::std::ffi::c_int,
    ) -> u64;
}
extern "C" {
    pub fn GDALSetRasterNoDataValue(arg1: GDALRasterBandH, arg2: f64) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALSetRasterNoDataValueAsInt64(arg1: GDALRasterBandH, arg2: i64) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALSetRasterNoDataValueAsUInt64(arg1: GDALRasterBandH, arg2: u64) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALDeleteRasterNoDataValue(arg1: GDALRasterBandH) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetRasterCategoryNames(arg1: GDALRasterBandH) -> *mut *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn GDALSetRasterCategoryNames(arg1: GDALRasterBandH, arg2: CSLConstList) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetRasterMinimum(arg1: GDALRasterBandH, pbSuccess: *mut ::std::ffi::c_int) -> f64;
}
extern "C" {
    pub fn GDALGetRasterMaximum(arg1: GDALRasterBandH, pbSuccess: *mut ::std::ffi::c_int) -> f64;
}
extern "C" {
    pub fn GDALGetRasterStatistics(
        arg1: GDALRasterBandH,
        bApproxOK: ::std::ffi::c_int,
        bForce: ::std::ffi::c_int,
        pdfMin: *mut f64,
        pdfMax: *mut f64,
        pdfMean: *mut f64,
        pdfStdDev: *mut f64,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALComputeRasterStatistics(
        arg1: GDALRasterBandH,
        bApproxOK: ::std::ffi::c_int,
        pdfMin: *mut f64,
        pdfMax: *mut f64,
        pdfMean: *mut f64,
        pdfStdDev: *mut f64,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut ::std::ffi::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALSetRasterStatistics(
        hBand: GDALRasterBandH,
        dfMin: f64,
        dfMax: f64,
        dfMean: f64,
        dfStdDev: f64,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRasterBandAsMDArray(arg1: GDALRasterBandH) -> GDALMDArrayH;
}
extern "C" {
    pub fn GDALGetRasterUnitType(arg1: GDALRasterBandH) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn GDALSetRasterUnitType(
        hBand: GDALRasterBandH,
        pszNewValue: *const ::std::ffi::c_char,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetRasterOffset(arg1: GDALRasterBandH, pbSuccess: *mut ::std::ffi::c_int) -> f64;
}
extern "C" {
    pub fn GDALSetRasterOffset(hBand: GDALRasterBandH, dfNewOffset: f64) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetRasterScale(arg1: GDALRasterBandH, pbSuccess: *mut ::std::ffi::c_int) -> f64;
}
extern "C" {
    pub fn GDALSetRasterScale(hBand: GDALRasterBandH, dfNewOffset: f64) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALComputeRasterMinMax(
        hBand: GDALRasterBandH,
        bApproxOK: ::std::ffi::c_int,
        adfMinMax: *mut f64,
    );
}
extern "C" {
    pub fn GDALFlushRasterCache(hBand: GDALRasterBandH) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetRasterHistogram(
        hBand: GDALRasterBandH,
        dfMin: f64,
        dfMax: f64,
        nBuckets: ::std::ffi::c_int,
        panHistogram: *mut ::std::ffi::c_int,
        bIncludeOutOfRange: ::std::ffi::c_int,
        bApproxOK: ::std::ffi::c_int,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut ::std::ffi::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetRasterHistogramEx(
        hBand: GDALRasterBandH,
        dfMin: f64,
        dfMax: f64,
        nBuckets: ::std::ffi::c_int,
        panHistogram: *mut GUIntBig,
        bIncludeOutOfRange: ::std::ffi::c_int,
        bApproxOK: ::std::ffi::c_int,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut ::std::ffi::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetDefaultHistogram(
        hBand: GDALRasterBandH,
        pdfMin: *mut f64,
        pdfMax: *mut f64,
        pnBuckets: *mut ::std::ffi::c_int,
        ppanHistogram: *mut *mut ::std::ffi::c_int,
        bForce: ::std::ffi::c_int,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut ::std::ffi::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetDefaultHistogramEx(
        hBand: GDALRasterBandH,
        pdfMin: *mut f64,
        pdfMax: *mut f64,
        pnBuckets: *mut ::std::ffi::c_int,
        ppanHistogram: *mut *mut GUIntBig,
        bForce: ::std::ffi::c_int,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut ::std::ffi::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALSetDefaultHistogram(
        hBand: GDALRasterBandH,
        dfMin: f64,
        dfMax: f64,
        nBuckets: ::std::ffi::c_int,
        panHistogram: *mut ::std::ffi::c_int,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALSetDefaultHistogramEx(
        hBand: GDALRasterBandH,
        dfMin: f64,
        dfMax: f64,
        nBuckets: ::std::ffi::c_int,
        panHistogram: *mut GUIntBig,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetRandomRasterSample(
        arg1: GDALRasterBandH,
        arg2: ::std::ffi::c_int,
        arg3: *mut f32,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALGetRasterSampleOverview(
        arg1: GDALRasterBandH,
        arg2: ::std::ffi::c_int,
    ) -> GDALRasterBandH;
}
extern "C" {
    pub fn GDALGetRasterSampleOverviewEx(arg1: GDALRasterBandH, arg2: GUIntBig) -> GDALRasterBandH;
}
extern "C" {
    pub fn GDALFillRaster(
        hBand: GDALRasterBandH,
        dfRealValue: f64,
        dfImaginaryValue: f64,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALComputeBandStats(
        hBand: GDALRasterBandH,
        nSampleStep: ::std::ffi::c_int,
        pdfMean: *mut f64,
        pdfStdDev: *mut f64,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut ::std::ffi::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALOverviewMagnitudeCorrection(
        hBaseBand: GDALRasterBandH,
        nOverviewCount: ::std::ffi::c_int,
        pahOverviews: *mut GDALRasterBandH,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut ::std::ffi::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetDefaultRAT(hBand: GDALRasterBandH) -> GDALRasterAttributeTableH;
}
extern "C" {
    pub fn GDALSetDefaultRAT(
        arg1: GDALRasterBandH,
        arg2: GDALRasterAttributeTableH,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALAddDerivedBandPixelFunc(
        pszName: *const ::std::ffi::c_char,
        pfnPixelFunc: GDALDerivedPixelFunc,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALAddDerivedBandPixelFuncWithArgs(
        pszName: *const ::std::ffi::c_char,
        pfnPixelFunc: GDALDerivedPixelFuncWithArgs,
        pszMetadata: *const ::std::ffi::c_char,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetMaskBand(hBand: GDALRasterBandH) -> GDALRasterBandH;
}
extern "C" {
    pub fn GDALGetMaskFlags(hBand: GDALRasterBandH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALCreateMaskBand(hBand: GDALRasterBandH, nFlags: ::std::ffi::c_int) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALIsMaskBand(hBand: GDALRasterBandH) -> bool;
}
extern "C" {
    pub fn GDALGetDataCoverageStatus(
        hBand: GDALRasterBandH,
        nXOff: ::std::ffi::c_int,
        nYOff: ::std::ffi::c_int,
        nXSize: ::std::ffi::c_int,
        nYSize: ::std::ffi::c_int,
        nMaskFlagStop: ::std::ffi::c_int,
        pdfDataPct: *mut f64,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALARGetNextUpdatedRegion(
        hARIO: GDALAsyncReaderH,
        dfTimeout: f64,
        pnXBufOff: *mut ::std::ffi::c_int,
        pnYBufOff: *mut ::std::ffi::c_int,
        pnXBufSize: *mut ::std::ffi::c_int,
        pnYBufSize: *mut ::std::ffi::c_int,
    ) -> GDALAsyncStatusType::Type;
}
extern "C" {
    pub fn GDALARLockBuffer(hARIO: GDALAsyncReaderH, dfTimeout: f64) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALARUnlockBuffer(hARIO: GDALAsyncReaderH);
}
extern "C" {
    pub fn GDALGeneralCmdLineProcessor(
        nArgc: ::std::ffi::c_int,
        ppapszArgv: *mut *mut *mut ::std::ffi::c_char,
        nOptions: ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALSwapWords(
        pData: *mut ::std::ffi::c_void,
        nWordSize: ::std::ffi::c_int,
        nWordCount: ::std::ffi::c_int,
        nWordSkip: ::std::ffi::c_int,
    );
}
extern "C" {
    pub fn GDALSwapWordsEx(
        pData: *mut ::std::ffi::c_void,
        nWordSize: ::std::ffi::c_int,
        nWordCount: usize,
        nWordSkip: ::std::ffi::c_int,
    );
}
extern "C" {
    pub fn GDALCopyWords(
        pSrcData: *const ::std::ffi::c_void,
        eSrcType: GDALDataType::Type,
        nSrcPixelOffset: ::std::ffi::c_int,
        pDstData: *mut ::std::ffi::c_void,
        eDstType: GDALDataType::Type,
        nDstPixelOffset: ::std::ffi::c_int,
        nWordCount: ::std::ffi::c_int,
    );
}
extern "C" {
    pub fn GDALCopyWords64(
        pSrcData: *const ::std::ffi::c_void,
        eSrcType: GDALDataType::Type,
        nSrcPixelOffset: ::std::ffi::c_int,
        pDstData: *mut ::std::ffi::c_void,
        eDstType: GDALDataType::Type,
        nDstPixelOffset: ::std::ffi::c_int,
        nWordCount: GPtrDiff_t,
    );
}
extern "C" {
    pub fn GDALCopyBits(
        pabySrcData: *const GByte,
        nSrcOffset: ::std::ffi::c_int,
        nSrcStep: ::std::ffi::c_int,
        pabyDstData: *mut GByte,
        nDstOffset: ::std::ffi::c_int,
        nDstStep: ::std::ffi::c_int,
        nBitCount: ::std::ffi::c_int,
        nStepCount: ::std::ffi::c_int,
    );
}
extern "C" {
    pub fn GDALLoadWorldFile(arg1: *const ::std::ffi::c_char, arg2: *mut f64) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALReadWorldFile(
        arg1: *const ::std::ffi::c_char,
        arg2: *const ::std::ffi::c_char,
        arg3: *mut f64,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALWriteWorldFile(
        arg1: *const ::std::ffi::c_char,
        arg2: *const ::std::ffi::c_char,
        arg3: *mut f64,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALLoadTabFile(
        arg1: *const ::std::ffi::c_char,
        arg2: *mut f64,
        arg3: *mut *mut ::std::ffi::c_char,
        arg4: *mut ::std::ffi::c_int,
        arg5: *mut *mut GDAL_GCP,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALReadTabFile(
        arg1: *const ::std::ffi::c_char,
        arg2: *mut f64,
        arg3: *mut *mut ::std::ffi::c_char,
        arg4: *mut ::std::ffi::c_int,
        arg5: *mut *mut GDAL_GCP,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALLoadOziMapFile(
        arg1: *const ::std::ffi::c_char,
        arg2: *mut f64,
        arg3: *mut *mut ::std::ffi::c_char,
        arg4: *mut ::std::ffi::c_int,
        arg5: *mut *mut GDAL_GCP,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALReadOziMapFile(
        arg1: *const ::std::ffi::c_char,
        arg2: *mut f64,
        arg3: *mut *mut ::std::ffi::c_char,
        arg4: *mut ::std::ffi::c_int,
        arg5: *mut *mut GDAL_GCP,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALDecToDMS(
        arg1: f64,
        arg2: *const ::std::ffi::c_char,
        arg3: ::std::ffi::c_int,
    ) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn GDALPackedDMSToDec(arg1: f64) -> f64;
}
extern "C" {
    pub fn GDALDecToPackedDMS(arg1: f64) -> f64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALRPCInfoV1 {
    #[doc = "< Line offset"]
    pub dfLINE_OFF: f64,
    #[doc = "< Sample/Pixel offset"]
    pub dfSAMP_OFF: f64,
    #[doc = "< Latitude offset"]
    pub dfLAT_OFF: f64,
    #[doc = "< Longitude offset"]
    pub dfLONG_OFF: f64,
    #[doc = "< Height offset"]
    pub dfHEIGHT_OFF: f64,
    #[doc = "< Line scale"]
    pub dfLINE_SCALE: f64,
    #[doc = "< Sample/Pixel scale"]
    pub dfSAMP_SCALE: f64,
    #[doc = "< Latitude scale"]
    pub dfLAT_SCALE: f64,
    #[doc = "< Longitude scale"]
    pub dfLONG_SCALE: f64,
    #[doc = "< Height scale"]
    pub dfHEIGHT_SCALE: f64,
    #[doc = "< Line Numerator Coefficients"]
    pub adfLINE_NUM_COEFF: [f64; 20usize],
    #[doc = "< Line Denominator Coefficients"]
    pub adfLINE_DEN_COEFF: [f64; 20usize],
    #[doc = "< Sample/Pixel Numerator Coefficients"]
    pub adfSAMP_NUM_COEFF: [f64; 20usize],
    #[doc = "< Sample/Pixel Denominator Coefficients"]
    pub adfSAMP_DEN_COEFF: [f64; 20usize],
    #[doc = "< Minimum longitude"]
    pub dfMIN_LONG: f64,
    #[doc = "< Minimum latitude"]
    pub dfMIN_LAT: f64,
    #[doc = "< Maximum longitude"]
    pub dfMAX_LONG: f64,
    #[doc = "< Maximum latitude"]
    pub dfMAX_LAT: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GDALRPCInfoV1"][::std::mem::size_of::<GDALRPCInfoV1>() - 752usize];
    ["Alignment of GDALRPCInfoV1"][::std::mem::align_of::<GDALRPCInfoV1>() - 4usize];
    ["Offset of field: GDALRPCInfoV1::dfLINE_OFF"]
        [::std::mem::offset_of!(GDALRPCInfoV1, dfLINE_OFF) - 0usize];
    ["Offset of field: GDALRPCInfoV1::dfSAMP_OFF"]
        [::std::mem::offset_of!(GDALRPCInfoV1, dfSAMP_OFF) - 8usize];
    ["Offset of field: GDALRPCInfoV1::dfLAT_OFF"]
        [::std::mem::offset_of!(GDALRPCInfoV1, dfLAT_OFF) - 16usize];
    ["Offset of field: GDALRPCInfoV1::dfLONG_OFF"]
        [::std::mem::offset_of!(GDALRPCInfoV1, dfLONG_OFF) - 24usize];
    ["Offset of field: GDALRPCInfoV1::dfHEIGHT_OFF"]
        [::std::mem::offset_of!(GDALRPCInfoV1, dfHEIGHT_OFF) - 32usize];
    ["Offset of field: GDALRPCInfoV1::dfLINE_SCALE"]
        [::std::mem::offset_of!(GDALRPCInfoV1, dfLINE_SCALE) - 40usize];
    ["Offset of field: GDALRPCInfoV1::dfSAMP_SCALE"]
        [::std::mem::offset_of!(GDALRPCInfoV1, dfSAMP_SCALE) - 48usize];
    ["Offset of field: GDALRPCInfoV1::dfLAT_SCALE"]
        [::std::mem::offset_of!(GDALRPCInfoV1, dfLAT_SCALE) - 56usize];
    ["Offset of field: GDALRPCInfoV1::dfLONG_SCALE"]
        [::std::mem::offset_of!(GDALRPCInfoV1, dfLONG_SCALE) - 64usize];
    ["Offset of field: GDALRPCInfoV1::dfHEIGHT_SCALE"]
        [::std::mem::offset_of!(GDALRPCInfoV1, dfHEIGHT_SCALE) - 72usize];
    ["Offset of field: GDALRPCInfoV1::adfLINE_NUM_COEFF"]
        [::std::mem::offset_of!(GDALRPCInfoV1, adfLINE_NUM_COEFF) - 80usize];
    ["Offset of field: GDALRPCInfoV1::adfLINE_DEN_COEFF"]
        [::std::mem::offset_of!(GDALRPCInfoV1, adfLINE_DEN_COEFF) - 240usize];
    ["Offset of field: GDALRPCInfoV1::adfSAMP_NUM_COEFF"]
        [::std::mem::offset_of!(GDALRPCInfoV1, adfSAMP_NUM_COEFF) - 400usize];
    ["Offset of field: GDALRPCInfoV1::adfSAMP_DEN_COEFF"]
        [::std::mem::offset_of!(GDALRPCInfoV1, adfSAMP_DEN_COEFF) - 560usize];
    ["Offset of field: GDALRPCInfoV1::dfMIN_LONG"]
        [::std::mem::offset_of!(GDALRPCInfoV1, dfMIN_LONG) - 720usize];
    ["Offset of field: GDALRPCInfoV1::dfMIN_LAT"]
        [::std::mem::offset_of!(GDALRPCInfoV1, dfMIN_LAT) - 728usize];
    ["Offset of field: GDALRPCInfoV1::dfMAX_LONG"]
        [::std::mem::offset_of!(GDALRPCInfoV1, dfMAX_LONG) - 736usize];
    ["Offset of field: GDALRPCInfoV1::dfMAX_LAT"]
        [::std::mem::offset_of!(GDALRPCInfoV1, dfMAX_LAT) - 744usize];
};
#[doc = " Structure to store Rational Polynomial Coefficients / Rigorous Projection\n Model. See http://geotiff.maptools.org/rpc_prop.html"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALRPCInfoV2 {
    #[doc = "< Line offset"]
    pub dfLINE_OFF: f64,
    #[doc = "< Sample/Pixel offset"]
    pub dfSAMP_OFF: f64,
    #[doc = "< Latitude offset"]
    pub dfLAT_OFF: f64,
    #[doc = "< Longitude offset"]
    pub dfLONG_OFF: f64,
    #[doc = "< Height offset"]
    pub dfHEIGHT_OFF: f64,
    #[doc = "< Line scale"]
    pub dfLINE_SCALE: f64,
    #[doc = "< Sample/Pixel scale"]
    pub dfSAMP_SCALE: f64,
    #[doc = "< Latitude scale"]
    pub dfLAT_SCALE: f64,
    #[doc = "< Longitude scale"]
    pub dfLONG_SCALE: f64,
    #[doc = "< Height scale"]
    pub dfHEIGHT_SCALE: f64,
    #[doc = "< Line Numerator Coefficients"]
    pub adfLINE_NUM_COEFF: [f64; 20usize],
    #[doc = "< Line Denominator Coefficients"]
    pub adfLINE_DEN_COEFF: [f64; 20usize],
    #[doc = "< Sample/Pixel Numerator Coefficients"]
    pub adfSAMP_NUM_COEFF: [f64; 20usize],
    #[doc = "< Sample/Pixel Denominator Coefficients"]
    pub adfSAMP_DEN_COEFF: [f64; 20usize],
    #[doc = "< Minimum longitude"]
    pub dfMIN_LONG: f64,
    #[doc = "< Minimum latitude"]
    pub dfMIN_LAT: f64,
    #[doc = "< Maximum longitude"]
    pub dfMAX_LONG: f64,
    #[doc = "< Maximum latitude"]
    pub dfMAX_LAT: f64,
    #[doc = "< Bias error"]
    pub dfERR_BIAS: f64,
    #[doc = "< Random error"]
    pub dfERR_RAND: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GDALRPCInfoV2"][::std::mem::size_of::<GDALRPCInfoV2>() - 768usize];
    ["Alignment of GDALRPCInfoV2"][::std::mem::align_of::<GDALRPCInfoV2>() - 4usize];
    ["Offset of field: GDALRPCInfoV2::dfLINE_OFF"]
        [::std::mem::offset_of!(GDALRPCInfoV2, dfLINE_OFF) - 0usize];
    ["Offset of field: GDALRPCInfoV2::dfSAMP_OFF"]
        [::std::mem::offset_of!(GDALRPCInfoV2, dfSAMP_OFF) - 8usize];
    ["Offset of field: GDALRPCInfoV2::dfLAT_OFF"]
        [::std::mem::offset_of!(GDALRPCInfoV2, dfLAT_OFF) - 16usize];
    ["Offset of field: GDALRPCInfoV2::dfLONG_OFF"]
        [::std::mem::offset_of!(GDALRPCInfoV2, dfLONG_OFF) - 24usize];
    ["Offset of field: GDALRPCInfoV2::dfHEIGHT_OFF"]
        [::std::mem::offset_of!(GDALRPCInfoV2, dfHEIGHT_OFF) - 32usize];
    ["Offset of field: GDALRPCInfoV2::dfLINE_SCALE"]
        [::std::mem::offset_of!(GDALRPCInfoV2, dfLINE_SCALE) - 40usize];
    ["Offset of field: GDALRPCInfoV2::dfSAMP_SCALE"]
        [::std::mem::offset_of!(GDALRPCInfoV2, dfSAMP_SCALE) - 48usize];
    ["Offset of field: GDALRPCInfoV2::dfLAT_SCALE"]
        [::std::mem::offset_of!(GDALRPCInfoV2, dfLAT_SCALE) - 56usize];
    ["Offset of field: GDALRPCInfoV2::dfLONG_SCALE"]
        [::std::mem::offset_of!(GDALRPCInfoV2, dfLONG_SCALE) - 64usize];
    ["Offset of field: GDALRPCInfoV2::dfHEIGHT_SCALE"]
        [::std::mem::offset_of!(GDALRPCInfoV2, dfHEIGHT_SCALE) - 72usize];
    ["Offset of field: GDALRPCInfoV2::adfLINE_NUM_COEFF"]
        [::std::mem::offset_of!(GDALRPCInfoV2, adfLINE_NUM_COEFF) - 80usize];
    ["Offset of field: GDALRPCInfoV2::adfLINE_DEN_COEFF"]
        [::std::mem::offset_of!(GDALRPCInfoV2, adfLINE_DEN_COEFF) - 240usize];
    ["Offset of field: GDALRPCInfoV2::adfSAMP_NUM_COEFF"]
        [::std::mem::offset_of!(GDALRPCInfoV2, adfSAMP_NUM_COEFF) - 400usize];
    ["Offset of field: GDALRPCInfoV2::adfSAMP_DEN_COEFF"]
        [::std::mem::offset_of!(GDALRPCInfoV2, adfSAMP_DEN_COEFF) - 560usize];
    ["Offset of field: GDALRPCInfoV2::dfMIN_LONG"]
        [::std::mem::offset_of!(GDALRPCInfoV2, dfMIN_LONG) - 720usize];
    ["Offset of field: GDALRPCInfoV2::dfMIN_LAT"]
        [::std::mem::offset_of!(GDALRPCInfoV2, dfMIN_LAT) - 728usize];
    ["Offset of field: GDALRPCInfoV2::dfMAX_LONG"]
        [::std::mem::offset_of!(GDALRPCInfoV2, dfMAX_LONG) - 736usize];
    ["Offset of field: GDALRPCInfoV2::dfMAX_LAT"]
        [::std::mem::offset_of!(GDALRPCInfoV2, dfMAX_LAT) - 744usize];
    ["Offset of field: GDALRPCInfoV2::dfERR_BIAS"]
        [::std::mem::offset_of!(GDALRPCInfoV2, dfERR_BIAS) - 752usize];
    ["Offset of field: GDALRPCInfoV2::dfERR_RAND"]
        [::std::mem::offset_of!(GDALRPCInfoV2, dfERR_RAND) - 760usize];
};
extern "C" {
    #[doc = " @cond Doxygen_Suppress"]
    pub fn GDALExtractRPCInfoV1(arg1: CSLConstList, arg2: *mut GDALRPCInfoV1) -> ::std::ffi::c_int;
}
extern "C" {
    #[doc = " @endcond"]
    pub fn GDALExtractRPCInfoV2(arg1: CSLConstList, arg2: *mut GDALRPCInfoV2) -> ::std::ffi::c_int;
}
#[doc = " Color tuple"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALColorEntry {
    #[doc = " gray, red, cyan or hue"]
    pub c1: ::std::ffi::c_short,
    #[doc = " green, magenta, or lightness"]
    pub c2: ::std::ffi::c_short,
    #[doc = " blue, yellow, or saturation"]
    pub c3: ::std::ffi::c_short,
    #[doc = " alpha or blackband"]
    pub c4: ::std::ffi::c_short,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GDALColorEntry"][::std::mem::size_of::<GDALColorEntry>() - 8usize];
    ["Alignment of GDALColorEntry"][::std::mem::align_of::<GDALColorEntry>() - 2usize];
    ["Offset of field: GDALColorEntry::c1"][::std::mem::offset_of!(GDALColorEntry, c1) - 0usize];
    ["Offset of field: GDALColorEntry::c2"][::std::mem::offset_of!(GDALColorEntry, c2) - 2usize];
    ["Offset of field: GDALColorEntry::c3"][::std::mem::offset_of!(GDALColorEntry, c3) - 4usize];
    ["Offset of field: GDALColorEntry::c4"][::std::mem::offset_of!(GDALColorEntry, c4) - 6usize];
};
extern "C" {
    pub fn GDALCreateColorTable(arg1: GDALPaletteInterp::Type) -> GDALColorTableH;
}
extern "C" {
    pub fn GDALDestroyColorTable(arg1: GDALColorTableH);
}
extern "C" {
    pub fn GDALCloneColorTable(arg1: GDALColorTableH) -> GDALColorTableH;
}
extern "C" {
    pub fn GDALGetPaletteInterpretation(arg1: GDALColorTableH) -> GDALPaletteInterp::Type;
}
extern "C" {
    pub fn GDALGetColorEntryCount(arg1: GDALColorTableH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALGetColorEntry(
        arg1: GDALColorTableH,
        arg2: ::std::ffi::c_int,
    ) -> *const GDALColorEntry;
}
extern "C" {
    pub fn GDALGetColorEntryAsRGB(
        arg1: GDALColorTableH,
        arg2: ::std::ffi::c_int,
        arg3: *mut GDALColorEntry,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALSetColorEntry(
        arg1: GDALColorTableH,
        arg2: ::std::ffi::c_int,
        arg3: *const GDALColorEntry,
    );
}
extern "C" {
    pub fn GDALCreateColorRamp(
        hTable: GDALColorTableH,
        nStartIndex: ::std::ffi::c_int,
        psStartColor: *const GDALColorEntry,
        nEndIndex: ::std::ffi::c_int,
        psEndColor: *const GDALColorEntry,
    );
}
pub mod GDALRATFieldType {
    #[doc = " Field type of raster attribute table"]
    pub type Type = ::std::ffi::c_uint;
    #[doc = " Integer field"]
    pub const GFT_Integer: Type = 0;
    #[doc = " Floating point (double) field"]
    pub const GFT_Real: Type = 1;
    #[doc = " String field"]
    pub const GFT_String: Type = 2;
}
pub mod GDALRATFieldUsage {
    #[doc = " Field usage of raster attribute table"]
    pub type Type = ::std::ffi::c_uint;
    #[doc = " General purpose field."]
    pub const GFU_Generic: Type = 0;
    #[doc = " Histogram pixel count"]
    pub const GFU_PixelCount: Type = 1;
    #[doc = " Class name"]
    pub const GFU_Name: Type = 2;
    #[doc = " Class range minimum"]
    pub const GFU_Min: Type = 3;
    #[doc = " Class range maximum"]
    pub const GFU_Max: Type = 4;
    #[doc = " Class value (min=max)"]
    pub const GFU_MinMax: Type = 5;
    #[doc = " Red class color (0-255)"]
    pub const GFU_Red: Type = 6;
    #[doc = " Green class color (0-255)"]
    pub const GFU_Green: Type = 7;
    #[doc = " Blue class color (0-255)"]
    pub const GFU_Blue: Type = 8;
    #[doc = " Alpha (0=transparent,255=opaque)"]
    pub const GFU_Alpha: Type = 9;
    #[doc = " Color Range Red Minimum"]
    pub const GFU_RedMin: Type = 10;
    #[doc = " Color Range Green Minimum"]
    pub const GFU_GreenMin: Type = 11;
    #[doc = " Color Range Blue Minimum"]
    pub const GFU_BlueMin: Type = 12;
    #[doc = " Color Range Alpha Minimum"]
    pub const GFU_AlphaMin: Type = 13;
    #[doc = " Color Range Red Maximum"]
    pub const GFU_RedMax: Type = 14;
    #[doc = " Color Range Green Maximum"]
    pub const GFU_GreenMax: Type = 15;
    #[doc = " Color Range Blue Maximum"]
    pub const GFU_BlueMax: Type = 16;
    #[doc = " Color Range Alpha Maximum"]
    pub const GFU_AlphaMax: Type = 17;
    #[doc = " Maximum GFU value (equals to GFU_AlphaMax+1 currently)"]
    pub const GFU_MaxCount: Type = 18;
}
pub mod GDALRATTableType {
    #[doc = " RAT table type (thematic or athematic)\n @since GDAL 2.4"]
    pub type Type = ::std::ffi::c_uint;
    #[doc = " Thematic table type"]
    pub const GRTT_THEMATIC: Type = 0;
    #[doc = " Athematic table type"]
    pub const GRTT_ATHEMATIC: Type = 1;
}
extern "C" {
    pub fn GDALCreateRasterAttributeTable() -> GDALRasterAttributeTableH;
}
extern "C" {
    pub fn GDALDestroyRasterAttributeTable(arg1: GDALRasterAttributeTableH);
}
extern "C" {
    pub fn GDALRATGetColumnCount(arg1: GDALRasterAttributeTableH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALRATGetNameOfCol(
        arg1: GDALRasterAttributeTableH,
        arg2: ::std::ffi::c_int,
    ) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn GDALRATGetUsageOfCol(
        arg1: GDALRasterAttributeTableH,
        arg2: ::std::ffi::c_int,
    ) -> GDALRATFieldUsage::Type;
}
extern "C" {
    pub fn GDALRATGetTypeOfCol(
        arg1: GDALRasterAttributeTableH,
        arg2: ::std::ffi::c_int,
    ) -> GDALRATFieldType::Type;
}
extern "C" {
    pub fn GDALRATGetColOfUsage(
        arg1: GDALRasterAttributeTableH,
        arg2: GDALRATFieldUsage::Type,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALRATGetRowCount(arg1: GDALRasterAttributeTableH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALRATGetValueAsString(
        arg1: GDALRasterAttributeTableH,
        arg2: ::std::ffi::c_int,
        arg3: ::std::ffi::c_int,
    ) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn GDALRATGetValueAsInt(
        arg1: GDALRasterAttributeTableH,
        arg2: ::std::ffi::c_int,
        arg3: ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALRATGetValueAsDouble(
        arg1: GDALRasterAttributeTableH,
        arg2: ::std::ffi::c_int,
        arg3: ::std::ffi::c_int,
    ) -> f64;
}
extern "C" {
    pub fn GDALRATSetValueAsString(
        arg1: GDALRasterAttributeTableH,
        arg2: ::std::ffi::c_int,
        arg3: ::std::ffi::c_int,
        arg4: *const ::std::ffi::c_char,
    );
}
extern "C" {
    pub fn GDALRATSetValueAsInt(
        arg1: GDALRasterAttributeTableH,
        arg2: ::std::ffi::c_int,
        arg3: ::std::ffi::c_int,
        arg4: ::std::ffi::c_int,
    );
}
extern "C" {
    pub fn GDALRATSetValueAsDouble(
        arg1: GDALRasterAttributeTableH,
        arg2: ::std::ffi::c_int,
        arg3: ::std::ffi::c_int,
        arg4: f64,
    );
}
extern "C" {
    pub fn GDALRATChangesAreWrittenToFile(hRAT: GDALRasterAttributeTableH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALRATValuesIOAsDouble(
        hRAT: GDALRasterAttributeTableH,
        eRWFlag: GDALRWFlag::Type,
        iField: ::std::ffi::c_int,
        iStartRow: ::std::ffi::c_int,
        iLength: ::std::ffi::c_int,
        pdfData: *mut f64,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRATValuesIOAsInteger(
        hRAT: GDALRasterAttributeTableH,
        eRWFlag: GDALRWFlag::Type,
        iField: ::std::ffi::c_int,
        iStartRow: ::std::ffi::c_int,
        iLength: ::std::ffi::c_int,
        pnData: *mut ::std::ffi::c_int,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRATValuesIOAsString(
        hRAT: GDALRasterAttributeTableH,
        eRWFlag: GDALRWFlag::Type,
        iField: ::std::ffi::c_int,
        iStartRow: ::std::ffi::c_int,
        iLength: ::std::ffi::c_int,
        papszStrList: CSLConstList,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRATSetRowCount(arg1: GDALRasterAttributeTableH, arg2: ::std::ffi::c_int);
}
extern "C" {
    pub fn GDALRATCreateColumn(
        arg1: GDALRasterAttributeTableH,
        arg2: *const ::std::ffi::c_char,
        arg3: GDALRATFieldType::Type,
        arg4: GDALRATFieldUsage::Type,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRATSetLinearBinning(
        arg1: GDALRasterAttributeTableH,
        arg2: f64,
        arg3: f64,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRATGetLinearBinning(
        arg1: GDALRasterAttributeTableH,
        arg2: *mut f64,
        arg3: *mut f64,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALRATSetTableType(
        hRAT: GDALRasterAttributeTableH,
        eInTableType: GDALRATTableType::Type,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRATGetTableType(hRAT: GDALRasterAttributeTableH) -> GDALRATTableType::Type;
}
extern "C" {
    pub fn GDALRATInitializeFromColorTable(
        arg1: GDALRasterAttributeTableH,
        arg2: GDALColorTableH,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRATTranslateToColorTable(
        arg1: GDALRasterAttributeTableH,
        nEntryCount: ::std::ffi::c_int,
    ) -> GDALColorTableH;
}
extern "C" {
    pub fn GDALRATDumpReadable(arg1: GDALRasterAttributeTableH, arg2: *mut FILE);
}
extern "C" {
    pub fn GDALRATClone(arg1: GDALRasterAttributeTableH) -> GDALRasterAttributeTableH;
}
extern "C" {
    pub fn GDALRATSerializeJSON(arg1: GDALRasterAttributeTableH) -> *mut ::std::ffi::c_void;
}
extern "C" {
    pub fn GDALRATGetRowOfValue(arg1: GDALRasterAttributeTableH, arg2: f64) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALRATRemoveStatistics(arg1: GDALRasterAttributeTableH);
}
extern "C" {
    pub fn GDALSetCacheMax(nBytes: ::std::ffi::c_int);
}
extern "C" {
    pub fn GDALGetCacheMax() -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALGetCacheUsed() -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALSetCacheMax64(nBytes: GIntBig);
}
extern "C" {
    pub fn GDALGetCacheMax64() -> GIntBig;
}
extern "C" {
    pub fn GDALGetCacheUsed64() -> GIntBig;
}
extern "C" {
    pub fn GDALFlushCacheBlock() -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALDatasetGetVirtualMem(
        hDS: GDALDatasetH,
        eRWFlag: GDALRWFlag::Type,
        nXOff: ::std::ffi::c_int,
        nYOff: ::std::ffi::c_int,
        nXSize: ::std::ffi::c_int,
        nYSize: ::std::ffi::c_int,
        nBufXSize: ::std::ffi::c_int,
        nBufYSize: ::std::ffi::c_int,
        eBufType: GDALDataType::Type,
        nBandCount: ::std::ffi::c_int,
        panBandMap: *mut ::std::ffi::c_int,
        nPixelSpace: ::std::ffi::c_int,
        nLineSpace: GIntBig,
        nBandSpace: GIntBig,
        nCacheSize: usize,
        nPageSizeHint: usize,
        bSingleThreadUsage: ::std::ffi::c_int,
        papszOptions: CSLConstList,
    ) -> *mut CPLVirtualMem;
}
extern "C" {
    pub fn GDALRasterBandGetVirtualMem(
        hBand: GDALRasterBandH,
        eRWFlag: GDALRWFlag::Type,
        nXOff: ::std::ffi::c_int,
        nYOff: ::std::ffi::c_int,
        nXSize: ::std::ffi::c_int,
        nYSize: ::std::ffi::c_int,
        nBufXSize: ::std::ffi::c_int,
        nBufYSize: ::std::ffi::c_int,
        eBufType: GDALDataType::Type,
        nPixelSpace: ::std::ffi::c_int,
        nLineSpace: GIntBig,
        nCacheSize: usize,
        nPageSizeHint: usize,
        bSingleThreadUsage: ::std::ffi::c_int,
        papszOptions: CSLConstList,
    ) -> *mut CPLVirtualMem;
}
extern "C" {
    pub fn GDALGetVirtualMemAuto(
        hBand: GDALRasterBandH,
        eRWFlag: GDALRWFlag::Type,
        pnPixelSpace: *mut ::std::ffi::c_int,
        pnLineSpace: *mut GIntBig,
        papszOptions: CSLConstList,
    ) -> *mut CPLVirtualMem;
}
pub mod GDALTileOrganization {
    #[doc = " Enumeration to describe the tile organization"]
    pub type Type = ::std::ffi::c_uint;
    #[doc = " Tile Interleaved by Pixel: tile (0,0) with internal band interleaved by pixel organization, tile (1, 0), ..."]
    pub const GTO_TIP: Type = 0;
    #[doc = " Band Interleaved by Tile : tile (0,0) of first band, tile (0,0) of second band, ... tile (1,0) of first band, tile (1,0) of second band, ..."]
    pub const GTO_BIT: Type = 1;
    #[doc = " Band SeQuential : all the tiles of first band, all the tiles of following band..."]
    pub const GTO_BSQ: Type = 2;
}
extern "C" {
    pub fn GDALDatasetGetTiledVirtualMem(
        hDS: GDALDatasetH,
        eRWFlag: GDALRWFlag::Type,
        nXOff: ::std::ffi::c_int,
        nYOff: ::std::ffi::c_int,
        nXSize: ::std::ffi::c_int,
        nYSize: ::std::ffi::c_int,
        nTileXSize: ::std::ffi::c_int,
        nTileYSize: ::std::ffi::c_int,
        eBufType: GDALDataType::Type,
        nBandCount: ::std::ffi::c_int,
        panBandMap: *mut ::std::ffi::c_int,
        eTileOrganization: GDALTileOrganization::Type,
        nCacheSize: usize,
        bSingleThreadUsage: ::std::ffi::c_int,
        papszOptions: CSLConstList,
    ) -> *mut CPLVirtualMem;
}
extern "C" {
    pub fn GDALRasterBandGetTiledVirtualMem(
        hBand: GDALRasterBandH,
        eRWFlag: GDALRWFlag::Type,
        nXOff: ::std::ffi::c_int,
        nYOff: ::std::ffi::c_int,
        nXSize: ::std::ffi::c_int,
        nYSize: ::std::ffi::c_int,
        nTileXSize: ::std::ffi::c_int,
        nTileYSize: ::std::ffi::c_int,
        eBufType: GDALDataType::Type,
        nCacheSize: usize,
        bSingleThreadUsage: ::std::ffi::c_int,
        papszOptions: CSLConstList,
    ) -> *mut CPLVirtualMem;
}
extern "C" {
    pub fn GDALCreatePansharpenedVRT(
        pszXML: *const ::std::ffi::c_char,
        hPanchroBand: GDALRasterBandH,
        nInputSpectralBands: ::std::ffi::c_int,
        pahInputSpectralBands: *mut GDALRasterBandH,
    ) -> GDALDatasetH;
}
extern "C" {
    pub fn GDALGetJPEG2000Structure(
        pszFilename: *const ::std::ffi::c_char,
        papszOptions: CSLConstList,
    ) -> *mut CPLXMLNode;
}
extern "C" {
    pub fn GDALCreateMultiDimensional(
        hDriver: GDALDriverH,
        pszName: *const ::std::ffi::c_char,
        papszRootGroupOptions: CSLConstList,
        papszOptions: CSLConstList,
    ) -> GDALDatasetH;
}
extern "C" {
    pub fn GDALExtendedDataTypeCreate(eType: GDALDataType::Type) -> GDALExtendedDataTypeH;
}
extern "C" {
    pub fn GDALExtendedDataTypeCreateString(nMaxStringLength: usize) -> GDALExtendedDataTypeH;
}
extern "C" {
    pub fn GDALExtendedDataTypeCreateStringEx(
        nMaxStringLength: usize,
        eSubType: GDALExtendedDataTypeSubType::Type,
    ) -> GDALExtendedDataTypeH;
}
extern "C" {
    pub fn GDALExtendedDataTypeCreateCompound(
        pszName: *const ::std::ffi::c_char,
        nTotalSize: usize,
        nComponents: usize,
        comps: *const GDALEDTComponentH,
    ) -> GDALExtendedDataTypeH;
}
extern "C" {
    pub fn GDALExtendedDataTypeRelease(hEDT: GDALExtendedDataTypeH);
}
extern "C" {
    pub fn GDALExtendedDataTypeGetName(hEDT: GDALExtendedDataTypeH) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn GDALExtendedDataTypeGetClass(
        hEDT: GDALExtendedDataTypeH,
    ) -> GDALExtendedDataTypeClass::Type;
}
extern "C" {
    pub fn GDALExtendedDataTypeGetNumericDataType(
        hEDT: GDALExtendedDataTypeH,
    ) -> GDALDataType::Type;
}
extern "C" {
    pub fn GDALExtendedDataTypeGetSize(hEDT: GDALExtendedDataTypeH) -> usize;
}
extern "C" {
    pub fn GDALExtendedDataTypeGetMaxStringLength(hEDT: GDALExtendedDataTypeH) -> usize;
}
extern "C" {
    pub fn GDALExtendedDataTypeGetComponents(
        hEDT: GDALExtendedDataTypeH,
        pnCount: *mut usize,
    ) -> *mut GDALEDTComponentH;
}
extern "C" {
    pub fn GDALExtendedDataTypeFreeComponents(components: *mut GDALEDTComponentH, nCount: usize);
}
extern "C" {
    pub fn GDALExtendedDataTypeCanConvertTo(
        hSourceEDT: GDALExtendedDataTypeH,
        hTargetEDT: GDALExtendedDataTypeH,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALExtendedDataTypeEquals(
        hFirstEDT: GDALExtendedDataTypeH,
        hSecondEDT: GDALExtendedDataTypeH,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALExtendedDataTypeGetSubType(
        hEDT: GDALExtendedDataTypeH,
    ) -> GDALExtendedDataTypeSubType::Type;
}
extern "C" {
    pub fn GDALEDTComponentCreate(
        pszName: *const ::std::ffi::c_char,
        nOffset: usize,
        hType: GDALExtendedDataTypeH,
    ) -> GDALEDTComponentH;
}
extern "C" {
    pub fn GDALEDTComponentRelease(hComp: GDALEDTComponentH);
}
extern "C" {
    pub fn GDALEDTComponentGetName(hComp: GDALEDTComponentH) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn GDALEDTComponentGetOffset(hComp: GDALEDTComponentH) -> usize;
}
extern "C" {
    pub fn GDALEDTComponentGetType(hComp: GDALEDTComponentH) -> GDALExtendedDataTypeH;
}
extern "C" {
    pub fn GDALDatasetGetRootGroup(hDS: GDALDatasetH) -> GDALGroupH;
}
extern "C" {
    pub fn GDALGroupRelease(hGroup: GDALGroupH);
}
extern "C" {
    pub fn GDALGroupGetName(hGroup: GDALGroupH) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn GDALGroupGetFullName(hGroup: GDALGroupH) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn GDALGroupGetMDArrayNames(
        hGroup: GDALGroupH,
        papszOptions: CSLConstList,
    ) -> *mut *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn GDALGroupOpenMDArray(
        hGroup: GDALGroupH,
        pszMDArrayName: *const ::std::ffi::c_char,
        papszOptions: CSLConstList,
    ) -> GDALMDArrayH;
}
extern "C" {
    pub fn GDALGroupOpenMDArrayFromFullname(
        hGroup: GDALGroupH,
        pszMDArrayName: *const ::std::ffi::c_char,
        papszOptions: CSLConstList,
    ) -> GDALMDArrayH;
}
extern "C" {
    pub fn GDALGroupResolveMDArray(
        hGroup: GDALGroupH,
        pszName: *const ::std::ffi::c_char,
        pszStartingPoint: *const ::std::ffi::c_char,
        papszOptions: CSLConstList,
    ) -> GDALMDArrayH;
}
extern "C" {
    pub fn GDALGroupGetGroupNames(
        hGroup: GDALGroupH,
        papszOptions: CSLConstList,
    ) -> *mut *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn GDALGroupOpenGroup(
        hGroup: GDALGroupH,
        pszSubGroupName: *const ::std::ffi::c_char,
        papszOptions: CSLConstList,
    ) -> GDALGroupH;
}
extern "C" {
    pub fn GDALGroupOpenGroupFromFullname(
        hGroup: GDALGroupH,
        pszMDArrayName: *const ::std::ffi::c_char,
        papszOptions: CSLConstList,
    ) -> GDALGroupH;
}
extern "C" {
    pub fn GDALGroupGetVectorLayerNames(
        hGroup: GDALGroupH,
        papszOptions: CSLConstList,
    ) -> *mut *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn GDALGroupOpenVectorLayer(
        hGroup: GDALGroupH,
        pszVectorLayerName: *const ::std::ffi::c_char,
        papszOptions: CSLConstList,
    ) -> OGRLayerH;
}
extern "C" {
    pub fn GDALGroupGetDimensions(
        hGroup: GDALGroupH,
        pnCount: *mut usize,
        papszOptions: CSLConstList,
    ) -> *mut GDALDimensionH;
}
extern "C" {
    pub fn GDALGroupGetAttribute(
        hGroup: GDALGroupH,
        pszName: *const ::std::ffi::c_char,
    ) -> GDALAttributeH;
}
extern "C" {
    pub fn GDALGroupGetAttributes(
        hGroup: GDALGroupH,
        pnCount: *mut usize,
        papszOptions: CSLConstList,
    ) -> *mut GDALAttributeH;
}
extern "C" {
    pub fn GDALGroupGetStructuralInfo(hGroup: GDALGroupH) -> CSLConstList;
}
extern "C" {
    pub fn GDALGroupCreateGroup(
        hGroup: GDALGroupH,
        pszSubGroupName: *const ::std::ffi::c_char,
        papszOptions: CSLConstList,
    ) -> GDALGroupH;
}
extern "C" {
    pub fn GDALGroupCreateDimension(
        hGroup: GDALGroupH,
        pszName: *const ::std::ffi::c_char,
        pszType: *const ::std::ffi::c_char,
        pszDirection: *const ::std::ffi::c_char,
        nSize: GUInt64,
        papszOptions: CSLConstList,
    ) -> GDALDimensionH;
}
extern "C" {
    pub fn GDALGroupCreateMDArray(
        hGroup: GDALGroupH,
        pszName: *const ::std::ffi::c_char,
        nDimensions: usize,
        pahDimensions: *mut GDALDimensionH,
        hEDT: GDALExtendedDataTypeH,
        papszOptions: CSLConstList,
    ) -> GDALMDArrayH;
}
extern "C" {
    pub fn GDALGroupCreateAttribute(
        hGroup: GDALGroupH,
        pszName: *const ::std::ffi::c_char,
        nDimensions: usize,
        panDimensions: *const GUInt64,
        hEDT: GDALExtendedDataTypeH,
        papszOptions: CSLConstList,
    ) -> GDALAttributeH;
}
extern "C" {
    pub fn GDALMDArrayRelease(hMDArray: GDALMDArrayH);
}
extern "C" {
    pub fn GDALMDArrayGetName(hArray: GDALMDArrayH) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn GDALMDArrayGetFullName(hArray: GDALMDArrayH) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn GDALMDArrayGetTotalElementsCount(hArray: GDALMDArrayH) -> GUInt64;
}
extern "C" {
    pub fn GDALMDArrayGetDimensionCount(hArray: GDALMDArrayH) -> usize;
}
extern "C" {
    pub fn GDALMDArrayGetDimensions(
        hArray: GDALMDArrayH,
        pnCount: *mut usize,
    ) -> *mut GDALDimensionH;
}
extern "C" {
    pub fn GDALMDArrayGetDataType(hArray: GDALMDArrayH) -> GDALExtendedDataTypeH;
}
extern "C" {
    pub fn GDALMDArrayRead(
        hArray: GDALMDArrayH,
        arrayStartIdx: *const GUInt64,
        count: *const usize,
        arrayStep: *const GInt64,
        bufferStride: *const GPtrDiff_t,
        bufferDatatype: GDALExtendedDataTypeH,
        pDstBuffer: *mut ::std::ffi::c_void,
        pDstBufferAllocStart: *const ::std::ffi::c_void,
        nDstBufferllocSize: usize,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALMDArrayWrite(
        hArray: GDALMDArrayH,
        arrayStartIdx: *const GUInt64,
        count: *const usize,
        arrayStep: *const GInt64,
        bufferStride: *const GPtrDiff_t,
        bufferDatatype: GDALExtendedDataTypeH,
        pSrcBuffer: *const ::std::ffi::c_void,
        psrcBufferAllocStart: *const ::std::ffi::c_void,
        nSrcBufferllocSize: usize,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALMDArrayAdviseRead(
        hArray: GDALMDArrayH,
        arrayStartIdx: *const GUInt64,
        count: *const usize,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALMDArrayAdviseReadEx(
        hArray: GDALMDArrayH,
        arrayStartIdx: *const GUInt64,
        count: *const usize,
        papszOptions: CSLConstList,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALMDArrayGetAttribute(
        hArray: GDALMDArrayH,
        pszName: *const ::std::ffi::c_char,
    ) -> GDALAttributeH;
}
extern "C" {
    pub fn GDALMDArrayGetAttributes(
        hArray: GDALMDArrayH,
        pnCount: *mut usize,
        papszOptions: CSLConstList,
    ) -> *mut GDALAttributeH;
}
extern "C" {
    pub fn GDALMDArrayCreateAttribute(
        hArray: GDALMDArrayH,
        pszName: *const ::std::ffi::c_char,
        nDimensions: usize,
        panDimensions: *const GUInt64,
        hEDT: GDALExtendedDataTypeH,
        papszOptions: CSLConstList,
    ) -> GDALAttributeH;
}
extern "C" {
    pub fn GDALMDArrayGetRawNoDataValue(hArray: GDALMDArrayH) -> *const ::std::ffi::c_void;
}
extern "C" {
    pub fn GDALMDArrayGetNoDataValueAsDouble(
        hArray: GDALMDArrayH,
        pbHasNoDataValue: *mut ::std::ffi::c_int,
    ) -> f64;
}
extern "C" {
    pub fn GDALMDArrayGetNoDataValueAsInt64(
        hArray: GDALMDArrayH,
        pbHasNoDataValue: *mut ::std::ffi::c_int,
    ) -> i64;
}
extern "C" {
    pub fn GDALMDArrayGetNoDataValueAsUInt64(
        hArray: GDALMDArrayH,
        pbHasNoDataValue: *mut ::std::ffi::c_int,
    ) -> u64;
}
extern "C" {
    pub fn GDALMDArraySetRawNoDataValue(
        hArray: GDALMDArrayH,
        arg1: *const ::std::ffi::c_void,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALMDArraySetNoDataValueAsDouble(
        hArray: GDALMDArrayH,
        dfNoDataValue: f64,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALMDArraySetNoDataValueAsInt64(
        hArray: GDALMDArrayH,
        nNoDataValue: i64,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALMDArraySetNoDataValueAsUInt64(
        hArray: GDALMDArrayH,
        nNoDataValue: u64,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALMDArraySetScale(hArray: GDALMDArrayH, dfScale: f64) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALMDArraySetScaleEx(
        hArray: GDALMDArrayH,
        dfScale: f64,
        eStorageType: GDALDataType::Type,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALMDArrayGetScale(hArray: GDALMDArrayH, pbHasValue: *mut ::std::ffi::c_int) -> f64;
}
extern "C" {
    pub fn GDALMDArrayGetScaleEx(
        hArray: GDALMDArrayH,
        pbHasValue: *mut ::std::ffi::c_int,
        peStorageType: *mut GDALDataType::Type,
    ) -> f64;
}
extern "C" {
    pub fn GDALMDArraySetOffset(hArray: GDALMDArrayH, dfOffset: f64) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALMDArraySetOffsetEx(
        hArray: GDALMDArrayH,
        dfOffset: f64,
        eStorageType: GDALDataType::Type,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALMDArrayGetOffset(hArray: GDALMDArrayH, pbHasValue: *mut ::std::ffi::c_int) -> f64;
}
extern "C" {
    pub fn GDALMDArrayGetOffsetEx(
        hArray: GDALMDArrayH,
        pbHasValue: *mut ::std::ffi::c_int,
        peStorageType: *mut GDALDataType::Type,
    ) -> f64;
}
extern "C" {
    pub fn GDALMDArrayGetBlockSize(hArray: GDALMDArrayH, pnCount: *mut usize) -> *mut GUInt64;
}
extern "C" {
    pub fn GDALMDArraySetUnit(
        hArray: GDALMDArrayH,
        arg1: *const ::std::ffi::c_char,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALMDArrayGetUnit(hArray: GDALMDArrayH) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn GDALMDArraySetSpatialRef(
        arg1: GDALMDArrayH,
        arg2: OGRSpatialReferenceH,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALMDArrayGetSpatialRef(hArray: GDALMDArrayH) -> OGRSpatialReferenceH;
}
extern "C" {
    pub fn GDALMDArrayGetProcessingChunkSize(
        hArray: GDALMDArrayH,
        pnCount: *mut usize,
        nMaxChunkMemory: usize,
    ) -> *mut usize;
}
extern "C" {
    pub fn GDALMDArrayGetStructuralInfo(hArray: GDALMDArrayH) -> CSLConstList;
}
extern "C" {
    pub fn GDALMDArrayGetView(
        hArray: GDALMDArrayH,
        pszViewExpr: *const ::std::ffi::c_char,
    ) -> GDALMDArrayH;
}
extern "C" {
    pub fn GDALMDArrayTranspose(
        hArray: GDALMDArrayH,
        nNewAxisCount: usize,
        panMapNewAxisToOldAxis: *const ::std::ffi::c_int,
    ) -> GDALMDArrayH;
}
extern "C" {
    pub fn GDALMDArrayGetUnscaled(hArray: GDALMDArrayH) -> GDALMDArrayH;
}
extern "C" {
    pub fn GDALMDArrayGetMask(hArray: GDALMDArrayH, papszOptions: CSLConstList) -> GDALMDArrayH;
}
extern "C" {
    pub fn GDALMDArrayAsClassicDataset(
        hArray: GDALMDArrayH,
        iXDim: usize,
        iYDim: usize,
    ) -> GDALDatasetH;
}
extern "C" {
    pub fn GDALMDArrayGetStatistics(
        hArray: GDALMDArrayH,
        arg1: GDALDatasetH,
        bApproxOK: ::std::ffi::c_int,
        bForce: ::std::ffi::c_int,
        pdfMin: *mut f64,
        pdfMax: *mut f64,
        pdfMean: *mut f64,
        pdfStdDev: *mut f64,
        pnValidCount: *mut GUInt64,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut ::std::ffi::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALMDArrayComputeStatistics(
        hArray: GDALMDArrayH,
        arg1: GDALDatasetH,
        bApproxOK: ::std::ffi::c_int,
        pdfMin: *mut f64,
        pdfMax: *mut f64,
        pdfMean: *mut f64,
        pdfStdDev: *mut f64,
        pnValidCount: *mut GUInt64,
        arg2: GDALProgressFunc,
        pProgressData: *mut ::std::ffi::c_void,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALMDArrayGetResampled(
        hArray: GDALMDArrayH,
        nNewDimCount: usize,
        pahNewDims: *const GDALDimensionH,
        resampleAlg: GDALRIOResampleAlg::Type,
        hTargetSRS: OGRSpatialReferenceH,
        papszOptions: CSLConstList,
    ) -> GDALMDArrayH;
}
extern "C" {
    pub fn GDALMDArrayGetCoordinateVariables(
        hArray: GDALMDArrayH,
        pnCount: *mut usize,
    ) -> *mut GDALMDArrayH;
}
extern "C" {
    pub fn GDALReleaseArrays(arrays: *mut GDALMDArrayH, nCount: usize);
}
extern "C" {
    pub fn GDALMDArrayCache(hArray: GDALMDArrayH, papszOptions: CSLConstList) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALAttributeRelease(hAttr: GDALAttributeH);
}
extern "C" {
    pub fn GDALReleaseAttributes(attributes: *mut GDALAttributeH, nCount: usize);
}
extern "C" {
    pub fn GDALAttributeGetName(hAttr: GDALAttributeH) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn GDALAttributeGetFullName(hAttr: GDALAttributeH) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn GDALAttributeGetTotalElementsCount(hAttr: GDALAttributeH) -> GUInt64;
}
extern "C" {
    pub fn GDALAttributeGetDimensionCount(hAttr: GDALAttributeH) -> usize;
}
extern "C" {
    pub fn GDALAttributeGetDimensionsSize(
        hAttr: GDALAttributeH,
        pnCount: *mut usize,
    ) -> *mut GUInt64;
}
extern "C" {
    pub fn GDALAttributeGetDataType(hAttr: GDALAttributeH) -> GDALExtendedDataTypeH;
}
extern "C" {
    pub fn GDALAttributeReadAsRaw(hAttr: GDALAttributeH, pnSize: *mut usize) -> *mut GByte;
}
extern "C" {
    pub fn GDALAttributeFreeRawResult(hAttr: GDALAttributeH, raw: *mut GByte, nSize: usize);
}
extern "C" {
    pub fn GDALAttributeReadAsString(hAttr: GDALAttributeH) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn GDALAttributeReadAsInt(hAttr: GDALAttributeH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALAttributeReadAsDouble(hAttr: GDALAttributeH) -> f64;
}
extern "C" {
    pub fn GDALAttributeReadAsStringArray(hAttr: GDALAttributeH) -> *mut *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn GDALAttributeReadAsIntArray(
        hAttr: GDALAttributeH,
        pnCount: *mut usize,
    ) -> *mut ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALAttributeReadAsDoubleArray(hAttr: GDALAttributeH, pnCount: *mut usize) -> *mut f64;
}
extern "C" {
    pub fn GDALAttributeWriteRaw(
        hAttr: GDALAttributeH,
        arg1: *const ::std::ffi::c_void,
        arg2: usize,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALAttributeWriteString(
        hAttr: GDALAttributeH,
        arg1: *const ::std::ffi::c_char,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALAttributeWriteStringArray(
        hAttr: GDALAttributeH,
        arg1: CSLConstList,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALAttributeWriteInt(
        hAttr: GDALAttributeH,
        arg1: ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALAttributeWriteDouble(hAttr: GDALAttributeH, arg1: f64) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALAttributeWriteDoubleArray(
        hAttr: GDALAttributeH,
        arg1: *const f64,
        arg2: usize,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALDimensionRelease(hDim: GDALDimensionH);
}
extern "C" {
    pub fn GDALReleaseDimensions(dims: *mut GDALDimensionH, nCount: usize);
}
extern "C" {
    pub fn GDALDimensionGetName(hDim: GDALDimensionH) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn GDALDimensionGetFullName(hDim: GDALDimensionH) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn GDALDimensionGetType(hDim: GDALDimensionH) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn GDALDimensionGetDirection(hDim: GDALDimensionH) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn GDALDimensionGetSize(hDim: GDALDimensionH) -> GUInt64;
}
extern "C" {
    pub fn GDALDimensionGetIndexingVariable(hDim: GDALDimensionH) -> GDALMDArrayH;
}
extern "C" {
    pub fn GDALDimensionSetIndexingVariable(
        hDim: GDALDimensionH,
        hArray: GDALMDArrayH,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALComputeMedianCutPCT(
        hRed: GDALRasterBandH,
        hGreen: GDALRasterBandH,
        hBlue: GDALRasterBandH,
        pfnIncludePixel: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: ::std::ffi::c_int,
                arg2: ::std::ffi::c_int,
                arg3: *mut ::std::ffi::c_void,
            ) -> ::std::ffi::c_int,
        >,
        nColors: ::std::ffi::c_int,
        hColorTable: GDALColorTableH,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut ::std::ffi::c_void,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALDitherRGB2PCT(
        hRed: GDALRasterBandH,
        hGreen: GDALRasterBandH,
        hBlue: GDALRasterBandH,
        hTarget: GDALRasterBandH,
        hColorTable: GDALColorTableH,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut ::std::ffi::c_void,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALChecksumImage(
        hBand: GDALRasterBandH,
        nXOff: ::std::ffi::c_int,
        nYOff: ::std::ffi::c_int,
        nXSize: ::std::ffi::c_int,
        nYSize: ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALComputeProximity(
        hSrcBand: GDALRasterBandH,
        hProximityBand: GDALRasterBandH,
        papszOptions: *mut *mut ::std::ffi::c_char,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut ::std::ffi::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALFillNodata(
        hTargetBand: GDALRasterBandH,
        hMaskBand: GDALRasterBandH,
        dfMaxSearchDist: f64,
        bDeprecatedOption: ::std::ffi::c_int,
        nSmoothingIterations: ::std::ffi::c_int,
        papszOptions: *mut *mut ::std::ffi::c_char,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut ::std::ffi::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALPolygonize(
        hSrcBand: GDALRasterBandH,
        hMaskBand: GDALRasterBandH,
        hOutLayer: OGRLayerH,
        iPixValField: ::std::ffi::c_int,
        papszOptions: *mut *mut ::std::ffi::c_char,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut ::std::ffi::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALFPolygonize(
        hSrcBand: GDALRasterBandH,
        hMaskBand: GDALRasterBandH,
        hOutLayer: OGRLayerH,
        iPixValField: ::std::ffi::c_int,
        papszOptions: *mut *mut ::std::ffi::c_char,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut ::std::ffi::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALSieveFilter(
        hSrcBand: GDALRasterBandH,
        hMaskBand: GDALRasterBandH,
        hDstBand: GDALRasterBandH,
        nSizeThreshold: ::std::ffi::c_int,
        nConnectedness: ::std::ffi::c_int,
        papszOptions: *mut *mut ::std::ffi::c_char,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut ::std::ffi::c_void,
    ) -> CPLErr::Type;
}
pub type GDALTransformerFunc = ::std::option::Option<
    unsafe extern "C" fn(
        pTransformerArg: *mut ::std::ffi::c_void,
        bDstToSrc: ::std::ffi::c_int,
        nPointCount: ::std::ffi::c_int,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
        panSuccess: *mut ::std::ffi::c_int,
    ) -> ::std::ffi::c_int,
>;
extern "C" {
    #[doc = " @cond Doxygen_Suppress"]
    pub fn GDALDestroyTransformer(pTransformerArg: *mut ::std::ffi::c_void);
}
extern "C" {
    pub fn GDALUseTransformer(
        pTransformerArg: *mut ::std::ffi::c_void,
        bDstToSrc: ::std::ffi::c_int,
        nPointCount: ::std::ffi::c_int,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
        panSuccess: *mut ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALCreateSimilarTransformer(
        psTransformerArg: *mut ::std::ffi::c_void,
        dfSrcRatioX: f64,
        dfSrcRatioY: f64,
    ) -> *mut ::std::ffi::c_void;
}
extern "C" {
    #[doc = " @endcond"]
    pub fn GDALCreateGenImgProjTransformer(
        hSrcDS: GDALDatasetH,
        pszSrcWKT: *const ::std::ffi::c_char,
        hDstDS: GDALDatasetH,
        pszDstWKT: *const ::std::ffi::c_char,
        bGCPUseOK: ::std::ffi::c_int,
        dfGCPErrorThreshold: f64,
        nOrder: ::std::ffi::c_int,
    ) -> *mut ::std::ffi::c_void;
}
extern "C" {
    pub fn GDALCreateGenImgProjTransformer2(
        hSrcDS: GDALDatasetH,
        hDstDS: GDALDatasetH,
        papszOptions: *mut *mut ::std::ffi::c_char,
    ) -> *mut ::std::ffi::c_void;
}
extern "C" {
    pub fn GDALCreateGenImgProjTransformer3(
        pszSrcWKT: *const ::std::ffi::c_char,
        padfSrcGeoTransform: *const f64,
        pszDstWKT: *const ::std::ffi::c_char,
        padfDstGeoTransform: *const f64,
    ) -> *mut ::std::ffi::c_void;
}
extern "C" {
    pub fn GDALCreateGenImgProjTransformer4(
        hSrcSRS: OGRSpatialReferenceH,
        padfSrcGeoTransform: *const f64,
        hDstSRS: OGRSpatialReferenceH,
        padfDstGeoTransform: *const f64,
        papszOptions: *const *const ::std::ffi::c_char,
    ) -> *mut ::std::ffi::c_void;
}
extern "C" {
    pub fn GDALSetGenImgProjTransformerDstGeoTransform(
        arg1: *mut ::std::ffi::c_void,
        arg2: *const f64,
    );
}
extern "C" {
    pub fn GDALDestroyGenImgProjTransformer(arg1: *mut ::std::ffi::c_void);
}
extern "C" {
    pub fn GDALGenImgProjTransform(
        pTransformArg: *mut ::std::ffi::c_void,
        bDstToSrc: ::std::ffi::c_int,
        nPointCount: ::std::ffi::c_int,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
        panSuccess: *mut ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALSetTransformerDstGeoTransform(arg1: *mut ::std::ffi::c_void, arg2: *const f64);
}
extern "C" {
    pub fn GDALGetTransformerDstGeoTransform(arg1: *mut ::std::ffi::c_void, arg2: *mut f64);
}
extern "C" {
    pub fn GDALCreateReprojectionTransformer(
        pszSrcWKT: *const ::std::ffi::c_char,
        pszDstWKT: *const ::std::ffi::c_char,
    ) -> *mut ::std::ffi::c_void;
}
extern "C" {
    pub fn GDALCreateReprojectionTransformerEx(
        hSrcSRS: OGRSpatialReferenceH,
        hDstSRS: OGRSpatialReferenceH,
        papszOptions: *const *const ::std::ffi::c_char,
    ) -> *mut ::std::ffi::c_void;
}
extern "C" {
    pub fn GDALDestroyReprojectionTransformer(arg1: *mut ::std::ffi::c_void);
}
extern "C" {
    pub fn GDALReprojectionTransform(
        pTransformArg: *mut ::std::ffi::c_void,
        bDstToSrc: ::std::ffi::c_int,
        nPointCount: ::std::ffi::c_int,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
        panSuccess: *mut ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALCreateGCPTransformer(
        nGCPCount: ::std::ffi::c_int,
        pasGCPList: *const GDAL_GCP,
        nReqOrder: ::std::ffi::c_int,
        bReversed: ::std::ffi::c_int,
    ) -> *mut ::std::ffi::c_void;
}
extern "C" {
    pub fn GDALCreateGCPRefineTransformer(
        nGCPCount: ::std::ffi::c_int,
        pasGCPList: *const GDAL_GCP,
        nReqOrder: ::std::ffi::c_int,
        bReversed: ::std::ffi::c_int,
        tolerance: f64,
        minimumGcps: ::std::ffi::c_int,
    ) -> *mut ::std::ffi::c_void;
}
extern "C" {
    pub fn GDALDestroyGCPTransformer(pTransformArg: *mut ::std::ffi::c_void);
}
extern "C" {
    pub fn GDALGCPTransform(
        pTransformArg: *mut ::std::ffi::c_void,
        bDstToSrc: ::std::ffi::c_int,
        nPointCount: ::std::ffi::c_int,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
        panSuccess: *mut ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALCreateTPSTransformer(
        nGCPCount: ::std::ffi::c_int,
        pasGCPList: *const GDAL_GCP,
        bReversed: ::std::ffi::c_int,
    ) -> *mut ::std::ffi::c_void;
}
extern "C" {
    pub fn GDALDestroyTPSTransformer(pTransformArg: *mut ::std::ffi::c_void);
}
extern "C" {
    pub fn GDALTPSTransform(
        pTransformArg: *mut ::std::ffi::c_void,
        bDstToSrc: ::std::ffi::c_int,
        nPointCount: ::std::ffi::c_int,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
        panSuccess: *mut ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALCreateRPCTransformerV1(
        psRPC: *mut GDALRPCInfoV1,
        bReversed: ::std::ffi::c_int,
        dfPixErrThreshold: f64,
        papszOptions: *mut *mut ::std::ffi::c_char,
    ) -> *mut ::std::ffi::c_void;
}
extern "C" {
    #[doc = " @endcond"]
    pub fn GDALCreateRPCTransformerV2(
        psRPC: *const GDALRPCInfoV2,
        bReversed: ::std::ffi::c_int,
        dfPixErrThreshold: f64,
        papszOptions: *mut *mut ::std::ffi::c_char,
    ) -> *mut ::std::ffi::c_void;
}
extern "C" {
    pub fn GDALDestroyRPCTransformer(pTransformArg: *mut ::std::ffi::c_void);
}
extern "C" {
    pub fn GDALRPCTransform(
        pTransformArg: *mut ::std::ffi::c_void,
        bDstToSrc: ::std::ffi::c_int,
        nPointCount: ::std::ffi::c_int,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
        panSuccess: *mut ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALCreateGeoLocTransformer(
        hBaseDS: GDALDatasetH,
        papszGeolocationInfo: *mut *mut ::std::ffi::c_char,
        bReversed: ::std::ffi::c_int,
    ) -> *mut ::std::ffi::c_void;
}
extern "C" {
    pub fn GDALDestroyGeoLocTransformer(pTransformArg: *mut ::std::ffi::c_void);
}
extern "C" {
    pub fn GDALGeoLocTransform(
        pTransformArg: *mut ::std::ffi::c_void,
        bDstToSrc: ::std::ffi::c_int,
        nPointCount: ::std::ffi::c_int,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
        panSuccess: *mut ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALCreateApproxTransformer(
        pfnRawTransformer: GDALTransformerFunc,
        pRawTransformerArg: *mut ::std::ffi::c_void,
        dfMaxError: f64,
    ) -> *mut ::std::ffi::c_void;
}
extern "C" {
    pub fn GDALApproxTransformerOwnsSubtransformer(
        pCBData: *mut ::std::ffi::c_void,
        bOwnFlag: ::std::ffi::c_int,
    );
}
extern "C" {
    pub fn GDALDestroyApproxTransformer(pApproxArg: *mut ::std::ffi::c_void);
}
extern "C" {
    pub fn GDALApproxTransform(
        pTransformArg: *mut ::std::ffi::c_void,
        bDstToSrc: ::std::ffi::c_int,
        nPointCount: ::std::ffi::c_int,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
        panSuccess: *mut ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALSimpleImageWarp(
        hSrcDS: GDALDatasetH,
        hDstDS: GDALDatasetH,
        nBandCount: ::std::ffi::c_int,
        panBandList: *mut ::std::ffi::c_int,
        pfnTransform: GDALTransformerFunc,
        pTransformArg: *mut ::std::ffi::c_void,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut ::std::ffi::c_void,
        papszWarpOptions: *mut *mut ::std::ffi::c_char,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALSuggestedWarpOutput(
        hSrcDS: GDALDatasetH,
        pfnTransformer: GDALTransformerFunc,
        pTransformArg: *mut ::std::ffi::c_void,
        padfGeoTransformOut: *mut f64,
        pnPixels: *mut ::std::ffi::c_int,
        pnLines: *mut ::std::ffi::c_int,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALSuggestedWarpOutput2(
        hSrcDS: GDALDatasetH,
        pfnTransformer: GDALTransformerFunc,
        pTransformArg: *mut ::std::ffi::c_void,
        padfGeoTransformOut: *mut f64,
        pnPixels: *mut ::std::ffi::c_int,
        pnLines: *mut ::std::ffi::c_int,
        padfExtents: *mut f64,
        nOptions: ::std::ffi::c_int,
    ) -> CPLErr::Type;
}
extern "C" {
    #[doc = " @cond Doxygen_Suppress"]
    pub fn GDALSerializeTransformer(
        pfnFunc: GDALTransformerFunc,
        pTransformArg: *mut ::std::ffi::c_void,
    ) -> *mut CPLXMLNode;
}
extern "C" {
    pub fn GDALDeserializeTransformer(
        psTree: *mut CPLXMLNode,
        ppfnFunc: *mut GDALTransformerFunc,
        ppTransformArg: *mut *mut ::std::ffi::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    #[doc = " @endcond"]
    pub fn GDALTransformGeolocations(
        hXBand: GDALRasterBandH,
        hYBand: GDALRasterBandH,
        hZBand: GDALRasterBandH,
        pfnTransformer: GDALTransformerFunc,
        pTransformArg: *mut ::std::ffi::c_void,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut ::std::ffi::c_void,
        papszOptions: *mut *mut ::std::ffi::c_char,
    ) -> CPLErr::Type;
}
#[doc = " Contour writer callback type"]
pub type GDALContourWriter = ::std::option::Option<
    unsafe extern "C" fn(
        dfLevel: f64,
        nPoints: ::std::ffi::c_int,
        padfX: *mut f64,
        padfY: *mut f64,
        arg1: *mut ::std::ffi::c_void,
    ) -> CPLErr::Type,
>;
#[doc = " Contour generator opaque type"]
pub type GDALContourGeneratorH = *mut ::std::ffi::c_void;
extern "C" {
    pub fn GDAL_CG_Create(
        nWidth: ::std::ffi::c_int,
        nHeight: ::std::ffi::c_int,
        bNoDataSet: ::std::ffi::c_int,
        dfNoDataValue: f64,
        dfContourInterval: f64,
        dfContourBase: f64,
        pfnWriter: GDALContourWriter,
        pCBData: *mut ::std::ffi::c_void,
    ) -> GDALContourGeneratorH;
}
extern "C" {
    pub fn GDAL_CG_FeedLine(hCG: GDALContourGeneratorH, padfScanline: *mut f64) -> CPLErr::Type;
}
extern "C" {
    pub fn GDAL_CG_Destroy(hCG: GDALContourGeneratorH);
}
extern "C" {
    pub fn OGRContourWriter(
        arg1: f64,
        arg2: ::std::ffi::c_int,
        arg3: *mut f64,
        arg4: *mut f64,
        pInfo: *mut ::std::ffi::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    #[doc = " @endcond"]
    pub fn GDALContourGenerate(
        hBand: GDALRasterBandH,
        dfContourInterval: f64,
        dfContourBase: f64,
        nFixedLevelCount: ::std::ffi::c_int,
        padfFixedLevels: *mut f64,
        bUseNoData: ::std::ffi::c_int,
        dfNoDataValue: f64,
        hLayer: *mut ::std::ffi::c_void,
        iIDField: ::std::ffi::c_int,
        iElevField: ::std::ffi::c_int,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut ::std::ffi::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALContourGenerateEx(
        hBand: GDALRasterBandH,
        hLayer: *mut ::std::ffi::c_void,
        options: CSLConstList,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut ::std::ffi::c_void,
    ) -> CPLErr::Type;
}
pub mod GDALViewshedMode {
    #[doc = " Viewshed Modes"]
    pub type Type = ::std::ffi::c_uint;
    pub const GVM_Diagonal: Type = 1;
    pub const GVM_Edge: Type = 2;
    pub const GVM_Max: Type = 3;
    pub const GVM_Min: Type = 4;
}
pub mod GDALViewshedOutputType {
    #[doc = " Viewshed output types"]
    pub type Type = ::std::ffi::c_uint;
    pub const GVOT_NORMAL: Type = 1;
    pub const GVOT_MIN_TARGET_HEIGHT_FROM_DEM: Type = 2;
    pub const GVOT_MIN_TARGET_HEIGHT_FROM_GROUND: Type = 3;
}
extern "C" {
    pub fn GDALViewshedGenerate(
        hBand: GDALRasterBandH,
        pszDriverName: *const ::std::ffi::c_char,
        pszTargetRasterName: *const ::std::ffi::c_char,
        papszCreationOptions: CSLConstList,
        dfObserverX: f64,
        dfObserverY: f64,
        dfObserverHeight: f64,
        dfTargetHeight: f64,
        dfVisibleVal: f64,
        dfInvisibleVal: f64,
        dfOutOfRangeVal: f64,
        dfNoDataVal: f64,
        dfCurvCoeff: f64,
        eMode: GDALViewshedMode::Type,
        dfMaxDistance: f64,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut ::std::ffi::c_void,
        heightMode: GDALViewshedOutputType::Type,
        papszExtraOptions: CSLConstList,
    ) -> GDALDatasetH;
}
extern "C" {
    pub fn GDALRasterizeGeometries(
        hDS: GDALDatasetH,
        nBandCount: ::std::ffi::c_int,
        panBandList: *const ::std::ffi::c_int,
        nGeomCount: ::std::ffi::c_int,
        pahGeometries: *const OGRGeometryH,
        pfnTransformer: GDALTransformerFunc,
        pTransformArg: *mut ::std::ffi::c_void,
        padfGeomBurnValues: *const f64,
        papszOptions: CSLConstList,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut ::std::ffi::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRasterizeGeometriesInt64(
        hDS: GDALDatasetH,
        nBandCount: ::std::ffi::c_int,
        panBandList: *const ::std::ffi::c_int,
        nGeomCount: ::std::ffi::c_int,
        pahGeometries: *const OGRGeometryH,
        pfnTransformer: GDALTransformerFunc,
        pTransformArg: *mut ::std::ffi::c_void,
        panGeomBurnValues: *const i64,
        papszOptions: CSLConstList,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut ::std::ffi::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRasterizeLayers(
        hDS: GDALDatasetH,
        nBandCount: ::std::ffi::c_int,
        panBandList: *mut ::std::ffi::c_int,
        nLayerCount: ::std::ffi::c_int,
        pahLayers: *mut OGRLayerH,
        pfnTransformer: GDALTransformerFunc,
        pTransformArg: *mut ::std::ffi::c_void,
        padfLayerBurnValues: *mut f64,
        papszOptions: *mut *mut ::std::ffi::c_char,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut ::std::ffi::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRasterizeLayersBuf(
        pData: *mut ::std::ffi::c_void,
        nBufXSize: ::std::ffi::c_int,
        nBufYSize: ::std::ffi::c_int,
        eBufType: GDALDataType::Type,
        nPixelSpace: ::std::ffi::c_int,
        nLineSpace: ::std::ffi::c_int,
        nLayerCount: ::std::ffi::c_int,
        pahLayers: *mut OGRLayerH,
        pszDstProjection: *const ::std::ffi::c_char,
        padfDstGeoTransform: *mut f64,
        pfnTransformer: GDALTransformerFunc,
        pTransformArg: *mut ::std::ffi::c_void,
        dfBurnValue: f64,
        papszOptions: *mut *mut ::std::ffi::c_char,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut ::std::ffi::c_void,
    ) -> CPLErr::Type;
}
pub mod GDALGridAlgorithm {
    #[doc = " Gridding Algorithms"]
    pub type Type = ::std::ffi::c_uint;
    #[doc = " Inverse distance to a power"]
    pub const GGA_InverseDistanceToAPower: Type = 1;
    #[doc = " Moving Average"]
    pub const GGA_MovingAverage: Type = 2;
    #[doc = " Nearest Neighbor"]
    pub const GGA_NearestNeighbor: Type = 3;
    #[doc = " Minimum Value (Data Metric)"]
    pub const GGA_MetricMinimum: Type = 4;
    #[doc = " Maximum Value (Data Metric)"]
    pub const GGA_MetricMaximum: Type = 5;
    #[doc = " Data Range (Data Metric)"]
    pub const GGA_MetricRange: Type = 6;
    #[doc = " Number of Points (Data Metric)"]
    pub const GGA_MetricCount: Type = 7;
    #[doc = " Average Distance (Data Metric)"]
    pub const GGA_MetricAverageDistance: Type = 8;
    #[doc = " Average Distance Between Data Points (Data Metric)"]
    pub const GGA_MetricAverageDistancePts: Type = 9;
    #[doc = " Linear interpolation (from Delaunay triangulation. Since GDAL 2.1"]
    pub const GGA_Linear: Type = 10;
    #[doc = " Inverse distance to a power with nearest neighbor search for max points"]
    pub const GGA_InverseDistanceToAPowerNearestNeighbor: Type = 11;
}
extern "C" {
    pub fn GDALGridCreate(
        arg1: GDALGridAlgorithm::Type,
        arg2: *const ::std::ffi::c_void,
        arg3: GUInt32,
        arg4: *const f64,
        arg5: *const f64,
        arg6: *const f64,
        arg7: f64,
        arg8: f64,
        arg9: f64,
        arg10: f64,
        arg11: GUInt32,
        arg12: GUInt32,
        arg13: GDALDataType::Type,
        arg14: *mut ::std::ffi::c_void,
        arg15: GDALProgressFunc,
        arg16: *mut ::std::ffi::c_void,
    ) -> CPLErr::Type;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALGridContext {
    _unused: [u8; 0],
}
extern "C" {
    pub fn GDALGridContextCreate(
        eAlgorithm: GDALGridAlgorithm::Type,
        poOptions: *const ::std::ffi::c_void,
        nPoints: GUInt32,
        padfX: *const f64,
        padfY: *const f64,
        padfZ: *const f64,
        bCallerWillKeepPointArraysAlive: ::std::ffi::c_int,
    ) -> *mut GDALGridContext;
}
extern "C" {
    pub fn GDALGridContextFree(psContext: *mut GDALGridContext);
}
extern "C" {
    pub fn GDALGridContextProcess(
        psContext: *mut GDALGridContext,
        dfXMin: f64,
        dfXMax: f64,
        dfYMin: f64,
        dfYMax: f64,
        nXSize: GUInt32,
        nYSize: GUInt32,
        eType: GDALDataType::Type,
        pData: *mut ::std::ffi::c_void,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut ::std::ffi::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALComputeMatchingPoints(
        hFirstImage: GDALDatasetH,
        hSecondImage: GDALDatasetH,
        papszOptions: *mut *mut ::std::ffi::c_char,
        pnGCPCount: *mut ::std::ffi::c_int,
    ) -> *mut GDAL_GCP;
}
#[doc = " Triangle fact"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALTriFacet {
    #[doc = "< index to the padfX/padfY arrays"]
    pub anVertexIdx: [::std::ffi::c_int; 3usize],
    #[doc = "< index to GDALDelaunayTriangulation.pasFacets, or -1"]
    pub anNeighborIdx: [::std::ffi::c_int; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GDALTriFacet"][::std::mem::size_of::<GDALTriFacet>() - 24usize];
    ["Alignment of GDALTriFacet"][::std::mem::align_of::<GDALTriFacet>() - 4usize];
    ["Offset of field: GDALTriFacet::anVertexIdx"]
        [::std::mem::offset_of!(GDALTriFacet, anVertexIdx) - 0usize];
    ["Offset of field: GDALTriFacet::anNeighborIdx"]
        [::std::mem::offset_of!(GDALTriFacet, anNeighborIdx) - 12usize];
};
#[doc = " Triangle barycentric coefficients.\n\n Conversion from cartesian (x,y) to barycentric (l1,l2,l3) with :\n  l1 = dfMul1X * (x - dfCxtX) + dfMul1Y * (y - dfCstY)\n  l2 = dfMul2X * (x - dfCxtX) + dfMul2Y * (y - dfCstY)\n  l3 = 1 - l1 - l2"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALTriBarycentricCoefficients {
    #[doc = "< dfMul1X"]
    pub dfMul1X: f64,
    #[doc = "< dfMul1Y"]
    pub dfMul1Y: f64,
    #[doc = "< dfMul2X"]
    pub dfMul2X: f64,
    #[doc = "< dfMul2Y"]
    pub dfMul2Y: f64,
    #[doc = "< dfCstX"]
    pub dfCstX: f64,
    #[doc = "< dfCstY"]
    pub dfCstY: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GDALTriBarycentricCoefficients"]
        [::std::mem::size_of::<GDALTriBarycentricCoefficients>() - 48usize];
    ["Alignment of GDALTriBarycentricCoefficients"]
        [::std::mem::align_of::<GDALTriBarycentricCoefficients>() - 4usize];
    ["Offset of field: GDALTriBarycentricCoefficients::dfMul1X"]
        [::std::mem::offset_of!(GDALTriBarycentricCoefficients, dfMul1X) - 0usize];
    ["Offset of field: GDALTriBarycentricCoefficients::dfMul1Y"]
        [::std::mem::offset_of!(GDALTriBarycentricCoefficients, dfMul1Y) - 8usize];
    ["Offset of field: GDALTriBarycentricCoefficients::dfMul2X"]
        [::std::mem::offset_of!(GDALTriBarycentricCoefficients, dfMul2X) - 16usize];
    ["Offset of field: GDALTriBarycentricCoefficients::dfMul2Y"]
        [::std::mem::offset_of!(GDALTriBarycentricCoefficients, dfMul2Y) - 24usize];
    ["Offset of field: GDALTriBarycentricCoefficients::dfCstX"]
        [::std::mem::offset_of!(GDALTriBarycentricCoefficients, dfCstX) - 32usize];
    ["Offset of field: GDALTriBarycentricCoefficients::dfCstY"]
        [::std::mem::offset_of!(GDALTriBarycentricCoefficients, dfCstY) - 40usize];
};
#[doc = " Triangulation structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALTriangulation {
    #[doc = "< number of facets"]
    pub nFacets: ::std::ffi::c_int,
    #[doc = "< array of nFacets facets"]
    pub pasFacets: *mut GDALTriFacet,
    #[doc = "< arra of nFacets barycentric coefficients"]
    pub pasFacetCoefficients: *mut GDALTriBarycentricCoefficients,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GDALTriangulation"][::std::mem::size_of::<GDALTriangulation>() - 12usize];
    ["Alignment of GDALTriangulation"][::std::mem::align_of::<GDALTriangulation>() - 4usize];
    ["Offset of field: GDALTriangulation::nFacets"]
        [::std::mem::offset_of!(GDALTriangulation, nFacets) - 0usize];
    ["Offset of field: GDALTriangulation::pasFacets"]
        [::std::mem::offset_of!(GDALTriangulation, pasFacets) - 4usize];
    ["Offset of field: GDALTriangulation::pasFacetCoefficients"]
        [::std::mem::offset_of!(GDALTriangulation, pasFacetCoefficients) - 8usize];
};
extern "C" {
    pub fn GDALHasTriangulation() -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALTriangulationCreateDelaunay(
        nPoints: ::std::ffi::c_int,
        padfX: *const f64,
        padfY: *const f64,
    ) -> *mut GDALTriangulation;
}
extern "C" {
    pub fn GDALTriangulationComputeBarycentricCoefficients(
        psDT: *mut GDALTriangulation,
        padfX: *const f64,
        padfY: *const f64,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALTriangulationComputeBarycentricCoordinates(
        psDT: *const GDALTriangulation,
        nFacetIdx: ::std::ffi::c_int,
        dfX: f64,
        dfY: f64,
        pdfL1: *mut f64,
        pdfL2: *mut f64,
        pdfL3: *mut f64,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALTriangulationFindFacetBruteForce(
        psDT: *const GDALTriangulation,
        dfX: f64,
        dfY: f64,
        panOutputFacetIdx: *mut ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALTriangulationFindFacetDirected(
        psDT: *const GDALTriangulation,
        nFacetIdx: ::std::ffi::c_int,
        dfX: f64,
        dfY: f64,
        panOutputFacetIdx: *mut ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn GDALTriangulationFree(psDT: *mut GDALTriangulation);
}
extern "C" {
    #[doc = " @endcond"]
    pub fn GDALOpenVerticalShiftGrid(
        pszProj4Geoidgrids: *const ::std::ffi::c_char,
        pbError: *mut ::std::ffi::c_int,
    ) -> GDALDatasetH;
}
extern "C" {
    #[doc = " @endcond"]
    pub fn GDALApplyVerticalShiftGrid(
        hSrcDataset: GDALDatasetH,
        hGridDataset: GDALDatasetH,
        bInverse: ::std::ffi::c_int,
        dfSrcUnitToMeter: f64,
        dfDstUnitToMeter: f64,
        papszOptions: *const *const ::std::ffi::c_char,
    ) -> GDALDatasetH;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALInfoOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALInfoOptionsForBinary {
    _unused: [u8; 0],
}
extern "C" {
    pub fn GDALInfoOptionsNew(
        papszArgv: *mut *mut ::std::ffi::c_char,
        psOptionsForBinary: *mut GDALInfoOptionsForBinary,
    ) -> *mut GDALInfoOptions;
}
extern "C" {
    pub fn GDALInfoOptionsFree(psOptions: *mut GDALInfoOptions);
}
extern "C" {
    pub fn GDALInfo(
        hDataset: GDALDatasetH,
        psOptions: *const GDALInfoOptions,
    ) -> *mut ::std::ffi::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALTranslateOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALTranslateOptionsForBinary {
    _unused: [u8; 0],
}
extern "C" {
    pub fn GDALTranslateOptionsNew(
        papszArgv: *mut *mut ::std::ffi::c_char,
        psOptionsForBinary: *mut GDALTranslateOptionsForBinary,
    ) -> *mut GDALTranslateOptions;
}
extern "C" {
    pub fn GDALTranslateOptionsFree(psOptions: *mut GDALTranslateOptions);
}
extern "C" {
    pub fn GDALTranslateOptionsSetProgress(
        psOptions: *mut GDALTranslateOptions,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut ::std::ffi::c_void,
    );
}
extern "C" {
    pub fn GDALTranslate(
        pszDestFilename: *const ::std::ffi::c_char,
        hSrcDataset: GDALDatasetH,
        psOptions: *const GDALTranslateOptions,
        pbUsageError: *mut ::std::ffi::c_int,
    ) -> GDALDatasetH;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALWarpAppOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALWarpAppOptionsForBinary {
    _unused: [u8; 0],
}
extern "C" {
    pub fn GDALWarpAppOptionsNew(
        papszArgv: *mut *mut ::std::ffi::c_char,
        psOptionsForBinary: *mut GDALWarpAppOptionsForBinary,
    ) -> *mut GDALWarpAppOptions;
}
extern "C" {
    pub fn GDALWarpAppOptionsFree(psOptions: *mut GDALWarpAppOptions);
}
extern "C" {
    pub fn GDALWarpAppOptionsSetProgress(
        psOptions: *mut GDALWarpAppOptions,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut ::std::ffi::c_void,
    );
}
extern "C" {
    pub fn GDALWarpAppOptionsSetQuiet(
        psOptions: *mut GDALWarpAppOptions,
        bQuiet: ::std::ffi::c_int,
    );
}
extern "C" {
    pub fn GDALWarpAppOptionsSetWarpOption(
        psOptions: *mut GDALWarpAppOptions,
        pszKey: *const ::std::ffi::c_char,
        pszValue: *const ::std::ffi::c_char,
    );
}
extern "C" {
    pub fn GDALWarp(
        pszDest: *const ::std::ffi::c_char,
        hDstDS: GDALDatasetH,
        nSrcCount: ::std::ffi::c_int,
        pahSrcDS: *mut GDALDatasetH,
        psOptions: *const GDALWarpAppOptions,
        pbUsageError: *mut ::std::ffi::c_int,
    ) -> GDALDatasetH;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALVectorTranslateOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALVectorTranslateOptionsForBinary {
    _unused: [u8; 0],
}
extern "C" {
    pub fn GDALVectorTranslateOptionsNew(
        papszArgv: *mut *mut ::std::ffi::c_char,
        psOptionsForBinary: *mut GDALVectorTranslateOptionsForBinary,
    ) -> *mut GDALVectorTranslateOptions;
}
extern "C" {
    pub fn GDALVectorTranslateOptionsFree(psOptions: *mut GDALVectorTranslateOptions);
}
extern "C" {
    pub fn GDALVectorTranslateOptionsSetProgress(
        psOptions: *mut GDALVectorTranslateOptions,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut ::std::ffi::c_void,
    );
}
extern "C" {
    pub fn GDALVectorTranslate(
        pszDest: *const ::std::ffi::c_char,
        hDstDS: GDALDatasetH,
        nSrcCount: ::std::ffi::c_int,
        pahSrcDS: *mut GDALDatasetH,
        psOptions: *const GDALVectorTranslateOptions,
        pbUsageError: *mut ::std::ffi::c_int,
    ) -> GDALDatasetH;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALDEMProcessingOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALDEMProcessingOptionsForBinary {
    _unused: [u8; 0],
}
extern "C" {
    pub fn GDALDEMProcessingOptionsNew(
        papszArgv: *mut *mut ::std::ffi::c_char,
        psOptionsForBinary: *mut GDALDEMProcessingOptionsForBinary,
    ) -> *mut GDALDEMProcessingOptions;
}
extern "C" {
    pub fn GDALDEMProcessingOptionsFree(psOptions: *mut GDALDEMProcessingOptions);
}
extern "C" {
    pub fn GDALDEMProcessingOptionsSetProgress(
        psOptions: *mut GDALDEMProcessingOptions,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut ::std::ffi::c_void,
    );
}
extern "C" {
    pub fn GDALDEMProcessing(
        pszDestFilename: *const ::std::ffi::c_char,
        hSrcDataset: GDALDatasetH,
        pszProcessing: *const ::std::ffi::c_char,
        pszColorFilename: *const ::std::ffi::c_char,
        psOptions: *const GDALDEMProcessingOptions,
        pbUsageError: *mut ::std::ffi::c_int,
    ) -> GDALDatasetH;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALNearblackOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALNearblackOptionsForBinary {
    _unused: [u8; 0],
}
extern "C" {
    pub fn GDALNearblackOptionsNew(
        papszArgv: *mut *mut ::std::ffi::c_char,
        psOptionsForBinary: *mut GDALNearblackOptionsForBinary,
    ) -> *mut GDALNearblackOptions;
}
extern "C" {
    pub fn GDALNearblackOptionsFree(psOptions: *mut GDALNearblackOptions);
}
extern "C" {
    pub fn GDALNearblackOptionsSetProgress(
        psOptions: *mut GDALNearblackOptions,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut ::std::ffi::c_void,
    );
}
extern "C" {
    pub fn GDALNearblack(
        pszDest: *const ::std::ffi::c_char,
        hDstDS: GDALDatasetH,
        hSrcDS: GDALDatasetH,
        psOptions: *const GDALNearblackOptions,
        pbUsageError: *mut ::std::ffi::c_int,
    ) -> GDALDatasetH;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALGridOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALGridOptionsForBinary {
    _unused: [u8; 0],
}
extern "C" {
    pub fn GDALGridOptionsNew(
        papszArgv: *mut *mut ::std::ffi::c_char,
        psOptionsForBinary: *mut GDALGridOptionsForBinary,
    ) -> *mut GDALGridOptions;
}
extern "C" {
    pub fn GDALGridOptionsFree(psOptions: *mut GDALGridOptions);
}
extern "C" {
    pub fn GDALGridOptionsSetProgress(
        psOptions: *mut GDALGridOptions,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut ::std::ffi::c_void,
    );
}
extern "C" {
    pub fn GDALGrid(
        pszDest: *const ::std::ffi::c_char,
        hSrcDS: GDALDatasetH,
        psOptions: *const GDALGridOptions,
        pbUsageError: *mut ::std::ffi::c_int,
    ) -> GDALDatasetH;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALRasterizeOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALRasterizeOptionsForBinary {
    _unused: [u8; 0],
}
extern "C" {
    pub fn GDALRasterizeOptionsNew(
        papszArgv: *mut *mut ::std::ffi::c_char,
        psOptionsForBinary: *mut GDALRasterizeOptionsForBinary,
    ) -> *mut GDALRasterizeOptions;
}
extern "C" {
    pub fn GDALRasterizeOptionsFree(psOptions: *mut GDALRasterizeOptions);
}
extern "C" {
    pub fn GDALRasterizeOptionsSetProgress(
        psOptions: *mut GDALRasterizeOptions,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut ::std::ffi::c_void,
    );
}
extern "C" {
    pub fn GDALRasterize(
        pszDest: *const ::std::ffi::c_char,
        hDstDS: GDALDatasetH,
        hSrcDS: GDALDatasetH,
        psOptions: *const GDALRasterizeOptions,
        pbUsageError: *mut ::std::ffi::c_int,
    ) -> GDALDatasetH;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALBuildVRTOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALBuildVRTOptionsForBinary {
    _unused: [u8; 0],
}
extern "C" {
    pub fn GDALBuildVRTOptionsNew(
        papszArgv: *mut *mut ::std::ffi::c_char,
        psOptionsForBinary: *mut GDALBuildVRTOptionsForBinary,
    ) -> *mut GDALBuildVRTOptions;
}
extern "C" {
    pub fn GDALBuildVRTOptionsFree(psOptions: *mut GDALBuildVRTOptions);
}
extern "C" {
    pub fn GDALBuildVRTOptionsSetProgress(
        psOptions: *mut GDALBuildVRTOptions,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut ::std::ffi::c_void,
    );
}
extern "C" {
    pub fn GDALBuildVRT(
        pszDest: *const ::std::ffi::c_char,
        nSrcCount: ::std::ffi::c_int,
        pahSrcDS: *mut GDALDatasetH,
        papszSrcDSNames: *const *const ::std::ffi::c_char,
        psOptions: *const GDALBuildVRTOptions,
        pbUsageError: *mut ::std::ffi::c_int,
    ) -> GDALDatasetH;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALMultiDimInfoOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALMultiDimInfoOptionsForBinary {
    _unused: [u8; 0],
}
extern "C" {
    pub fn GDALMultiDimInfoOptionsNew(
        papszArgv: *mut *mut ::std::ffi::c_char,
        psOptionsForBinary: *mut GDALMultiDimInfoOptionsForBinary,
    ) -> *mut GDALMultiDimInfoOptions;
}
extern "C" {
    pub fn GDALMultiDimInfoOptionsFree(psOptions: *mut GDALMultiDimInfoOptions);
}
extern "C" {
    pub fn GDALMultiDimInfo(
        hDataset: GDALDatasetH,
        psOptions: *const GDALMultiDimInfoOptions,
    ) -> *mut ::std::ffi::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALMultiDimTranslateOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALMultiDimTranslateOptionsForBinary {
    _unused: [u8; 0],
}
extern "C" {
    pub fn GDALMultiDimTranslateOptionsNew(
        papszArgv: *mut *mut ::std::ffi::c_char,
        psOptionsForBinary: *mut GDALMultiDimTranslateOptionsForBinary,
    ) -> *mut GDALMultiDimTranslateOptions;
}
extern "C" {
    pub fn GDALMultiDimTranslateOptionsFree(psOptions: *mut GDALMultiDimTranslateOptions);
}
extern "C" {
    pub fn GDALMultiDimTranslateOptionsSetProgress(
        psOptions: *mut GDALMultiDimTranslateOptions,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut ::std::ffi::c_void,
    );
}
extern "C" {
    pub fn GDALMultiDimTranslate(
        pszDest: *const ::std::ffi::c_char,
        hDstDataset: GDALDatasetH,
        nSrcCount: ::std::ffi::c_int,
        pahSrcDS: *mut GDALDatasetH,
        psOptions: *const GDALMultiDimTranslateOptions,
        pbUsageError: *mut ::std::ffi::c_int,
    ) -> GDALDatasetH;
}
pub mod OGRAxisOrientation {
    #[doc = " Axis orientations (corresponds to CS_AxisOrientationEnum)."]
    pub type Type = ::std::ffi::c_uint;
    #[doc = "< Other"]
    pub const OAO_Other: Type = 0;
    #[doc = "< North"]
    pub const OAO_North: Type = 1;
    #[doc = "< South"]
    pub const OAO_South: Type = 2;
    #[doc = "< East"]
    pub const OAO_East: Type = 3;
    #[doc = "< West"]
    pub const OAO_West: Type = 4;
    #[doc = "< Up (to space)"]
    pub const OAO_Up: Type = 5;
    #[doc = "< Down (to Earth center)"]
    pub const OAO_Down: Type = 6;
}
extern "C" {
    pub fn OSRAxisEnumToName(eOrientation: OGRAxisOrientation::Type) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn OSRSetPROJSearchPaths(papszPaths: *const *const ::std::ffi::c_char);
}
extern "C" {
    pub fn OSRGetPROJSearchPaths() -> *mut *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn OSRSetPROJAuxDbPaths(papszPaths: *const *const ::std::ffi::c_char);
}
extern "C" {
    pub fn OSRGetPROJAuxDbPaths() -> *mut *mut ::std::ffi::c_char;
}
extern "C" {
    pub fn OSRSetPROJEnableNetwork(enabled: ::std::ffi::c_int);
}
extern "C" {
    pub fn OSRGetPROJEnableNetwork() -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OSRGetPROJVersion(
        pnMajor: *mut ::std::ffi::c_int,
        pnMinor: *mut ::std::ffi::c_int,
        pnPatch: *mut ::std::ffi::c_int,
    );
}
extern "C" {
    pub fn OSRNewSpatialReference(arg1: *const ::std::ffi::c_char) -> OGRSpatialReferenceH;
}
extern "C" {
    pub fn OSRCloneGeogCS(arg1: OGRSpatialReferenceH) -> OGRSpatialReferenceH;
}
extern "C" {
    pub fn OSRClone(arg1: OGRSpatialReferenceH) -> OGRSpatialReferenceH;
}
extern "C" {
    pub fn OSRDestroySpatialReference(arg1: OGRSpatialReferenceH);
}
extern "C" {
    pub fn OSRReference(arg1: OGRSpatialReferenceH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OSRDereference(arg1: OGRSpatialReferenceH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OSRRelease(arg1: OGRSpatialReferenceH);
}
extern "C" {
    pub fn OSRValidate(arg1: OGRSpatialReferenceH) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRImportFromEPSG(arg1: OGRSpatialReferenceH, arg2: ::std::ffi::c_int) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRImportFromEPSGA(arg1: OGRSpatialReferenceH, arg2: ::std::ffi::c_int) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRImportFromWkt(
        arg1: OGRSpatialReferenceH,
        arg2: *mut *mut ::std::ffi::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRImportFromProj4(
        arg1: OGRSpatialReferenceH,
        arg2: *const ::std::ffi::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRImportFromESRI(
        arg1: OGRSpatialReferenceH,
        arg2: *mut *mut ::std::ffi::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRImportFromPCI(
        hSRS: OGRSpatialReferenceH,
        arg1: *const ::std::ffi::c_char,
        arg2: *const ::std::ffi::c_char,
        arg3: *mut f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRImportFromUSGS(
        arg1: OGRSpatialReferenceH,
        arg2: ::std::ffi::c_long,
        arg3: ::std::ffi::c_long,
        arg4: *mut f64,
        arg5: ::std::ffi::c_long,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRImportFromXML(
        arg1: OGRSpatialReferenceH,
        arg2: *const ::std::ffi::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRImportFromDict(
        arg1: OGRSpatialReferenceH,
        arg2: *const ::std::ffi::c_char,
        arg3: *const ::std::ffi::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRImportFromPanorama(
        arg1: OGRSpatialReferenceH,
        arg2: ::std::ffi::c_long,
        arg3: ::std::ffi::c_long,
        arg4: ::std::ffi::c_long,
        arg5: *mut f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRImportFromOzi(
        arg1: OGRSpatialReferenceH,
        arg2: *const *const ::std::ffi::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRImportFromMICoordSys(
        arg1: OGRSpatialReferenceH,
        arg2: *const ::std::ffi::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRImportFromERM(
        arg1: OGRSpatialReferenceH,
        arg2: *const ::std::ffi::c_char,
        arg3: *const ::std::ffi::c_char,
        arg4: *const ::std::ffi::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRImportFromUrl(
        arg1: OGRSpatialReferenceH,
        arg2: *const ::std::ffi::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRExportToWkt(
        arg1: OGRSpatialReferenceH,
        arg2: *mut *mut ::std::ffi::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRExportToWktEx(
        arg1: OGRSpatialReferenceH,
        ppszResult: *mut *mut ::std::ffi::c_char,
        papszOptions: *const *const ::std::ffi::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRExportToPrettyWkt(
        arg1: OGRSpatialReferenceH,
        arg2: *mut *mut ::std::ffi::c_char,
        arg3: ::std::ffi::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRExportToPROJJSON(
        hSRS: OGRSpatialReferenceH,
        ppszReturn: *mut *mut ::std::ffi::c_char,
        papszOptions: *const *const ::std::ffi::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRExportToProj4(
        arg1: OGRSpatialReferenceH,
        arg2: *mut *mut ::std::ffi::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRExportToPCI(
        arg1: OGRSpatialReferenceH,
        arg2: *mut *mut ::std::ffi::c_char,
        arg3: *mut *mut ::std::ffi::c_char,
        arg4: *mut *mut f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRExportToUSGS(
        arg1: OGRSpatialReferenceH,
        arg2: *mut ::std::ffi::c_long,
        arg3: *mut ::std::ffi::c_long,
        arg4: *mut *mut f64,
        arg5: *mut ::std::ffi::c_long,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRExportToXML(
        arg1: OGRSpatialReferenceH,
        arg2: *mut *mut ::std::ffi::c_char,
        arg3: *const ::std::ffi::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRExportToPanorama(
        arg1: OGRSpatialReferenceH,
        arg2: *mut ::std::ffi::c_long,
        arg3: *mut ::std::ffi::c_long,
        arg4: *mut ::std::ffi::c_long,
        arg5: *mut ::std::ffi::c_long,
        arg6: *mut f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRExportToMICoordSys(
        arg1: OGRSpatialReferenceH,
        arg2: *mut *mut ::std::ffi::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRExportToERM(
        arg1: OGRSpatialReferenceH,
        arg2: *mut ::std::ffi::c_char,
        arg3: *mut ::std::ffi::c_char,
        arg4: *mut ::std::ffi::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRMorphToESRI(arg1: OGRSpatialReferenceH) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRMorphFromESRI(arg1: OGRSpatialReferenceH) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRConvertToOtherProjection(
        hSRS: OGRSpatialReferenceH,
        pszTargetProjection: *const ::std::ffi::c_char,
        papszOptions: *const *const ::std::ffi::c_char,
    ) -> OGRSpatialReferenceH;
}
extern "C" {
    pub fn OSRGetName(hSRS: OGRSpatialReferenceH) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn OSRSetAttrValue(
        hSRS: OGRSpatialReferenceH,
        pszNodePath: *const ::std::ffi::c_char,
        pszNewNodeValue: *const ::std::ffi::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRGetAttrValue(
        hSRS: OGRSpatialReferenceH,
        pszName: *const ::std::ffi::c_char,
        iChild: ::std::ffi::c_int,
    ) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn OSRSetAngularUnits(
        arg1: OGRSpatialReferenceH,
        arg2: *const ::std::ffi::c_char,
        arg3: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRGetAngularUnits(
        arg1: OGRSpatialReferenceH,
        arg2: *mut *mut ::std::ffi::c_char,
    ) -> f64;
}
extern "C" {
    pub fn OSRSetLinearUnits(
        arg1: OGRSpatialReferenceH,
        arg2: *const ::std::ffi::c_char,
        arg3: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetTargetLinearUnits(
        arg1: OGRSpatialReferenceH,
        arg2: *const ::std::ffi::c_char,
        arg3: *const ::std::ffi::c_char,
        arg4: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetLinearUnitsAndUpdateParameters(
        arg1: OGRSpatialReferenceH,
        arg2: *const ::std::ffi::c_char,
        arg3: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRGetLinearUnits(arg1: OGRSpatialReferenceH, arg2: *mut *mut ::std::ffi::c_char)
        -> f64;
}
extern "C" {
    pub fn OSRGetTargetLinearUnits(
        arg1: OGRSpatialReferenceH,
        arg2: *const ::std::ffi::c_char,
        arg3: *mut *mut ::std::ffi::c_char,
    ) -> f64;
}
extern "C" {
    pub fn OSRGetPrimeMeridian(
        arg1: OGRSpatialReferenceH,
        arg2: *mut *mut ::std::ffi::c_char,
    ) -> f64;
}
extern "C" {
    pub fn OSRIsGeographic(arg1: OGRSpatialReferenceH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OSRIsDerivedGeographic(arg1: OGRSpatialReferenceH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OSRIsLocal(arg1: OGRSpatialReferenceH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OSRIsProjected(arg1: OGRSpatialReferenceH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OSRIsCompound(arg1: OGRSpatialReferenceH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OSRIsGeocentric(arg1: OGRSpatialReferenceH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OSRIsVertical(arg1: OGRSpatialReferenceH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OSRIsDynamic(arg1: OGRSpatialReferenceH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OSRIsSameGeogCS(
        arg1: OGRSpatialReferenceH,
        arg2: OGRSpatialReferenceH,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OSRIsSameVertCS(
        arg1: OGRSpatialReferenceH,
        arg2: OGRSpatialReferenceH,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OSRIsSame(arg1: OGRSpatialReferenceH, arg2: OGRSpatialReferenceH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OSRIsSameEx(
        arg1: OGRSpatialReferenceH,
        arg2: OGRSpatialReferenceH,
        papszOptions: *const *const ::std::ffi::c_char,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OSRSetCoordinateEpoch(hSRS: OGRSpatialReferenceH, dfCoordinateEpoch: f64);
}
extern "C" {
    pub fn OSRGetCoordinateEpoch(hSRS: OGRSpatialReferenceH) -> f64;
}
extern "C" {
    pub fn OSRSetLocalCS(
        hSRS: OGRSpatialReferenceH,
        pszName: *const ::std::ffi::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetProjCS(
        hSRS: OGRSpatialReferenceH,
        pszName: *const ::std::ffi::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetGeocCS(
        hSRS: OGRSpatialReferenceH,
        pszName: *const ::std::ffi::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetWellKnownGeogCS(
        hSRS: OGRSpatialReferenceH,
        pszName: *const ::std::ffi::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetFromUserInput(
        hSRS: OGRSpatialReferenceH,
        arg1: *const ::std::ffi::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRCopyGeogCSFrom(
        hSRS: OGRSpatialReferenceH,
        hSrcSRS: OGRSpatialReferenceH,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetTOWGS84(
        hSRS: OGRSpatialReferenceH,
        arg1: f64,
        arg2: f64,
        arg3: f64,
        arg4: f64,
        arg5: f64,
        arg6: f64,
        arg7: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRGetTOWGS84(
        hSRS: OGRSpatialReferenceH,
        arg1: *mut f64,
        arg2: ::std::ffi::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRAddGuessedTOWGS84(hSRS: OGRSpatialReferenceH) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetCompoundCS(
        hSRS: OGRSpatialReferenceH,
        pszName: *const ::std::ffi::c_char,
        hHorizSRS: OGRSpatialReferenceH,
        hVertSRS: OGRSpatialReferenceH,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRPromoteTo3D(
        hSRS: OGRSpatialReferenceH,
        pszName: *const ::std::ffi::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRDemoteTo2D(
        hSRS: OGRSpatialReferenceH,
        pszName: *const ::std::ffi::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetGeogCS(
        hSRS: OGRSpatialReferenceH,
        pszGeogName: *const ::std::ffi::c_char,
        pszDatumName: *const ::std::ffi::c_char,
        pszEllipsoidName: *const ::std::ffi::c_char,
        dfSemiMajor: f64,
        dfInvFlattening: f64,
        pszPMName: *const ::std::ffi::c_char,
        dfPMOffset: f64,
        pszUnits: *const ::std::ffi::c_char,
        dfConvertToRadians: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetVertCS(
        hSRS: OGRSpatialReferenceH,
        pszVertCSName: *const ::std::ffi::c_char,
        pszVertDatumName: *const ::std::ffi::c_char,
        nVertDatumType: ::std::ffi::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRGetSemiMajor(arg1: OGRSpatialReferenceH, arg2: *mut OGRErr::Type) -> f64;
}
extern "C" {
    pub fn OSRGetSemiMinor(arg1: OGRSpatialReferenceH, arg2: *mut OGRErr::Type) -> f64;
}
extern "C" {
    pub fn OSRGetInvFlattening(arg1: OGRSpatialReferenceH, arg2: *mut OGRErr::Type) -> f64;
}
extern "C" {
    pub fn OSRSetAuthority(
        hSRS: OGRSpatialReferenceH,
        pszTargetKey: *const ::std::ffi::c_char,
        pszAuthority: *const ::std::ffi::c_char,
        nCode: ::std::ffi::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRGetAuthorityCode(
        hSRS: OGRSpatialReferenceH,
        pszTargetKey: *const ::std::ffi::c_char,
    ) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn OSRGetAuthorityName(
        hSRS: OGRSpatialReferenceH,
        pszTargetKey: *const ::std::ffi::c_char,
    ) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn OSRGetAreaOfUse(
        hSRS: OGRSpatialReferenceH,
        pdfWestLongitudeDeg: *mut f64,
        pdfSouthLatitudeDeg: *mut f64,
        pdfEastLongitudeDeg: *mut f64,
        pdfNorthLatitudeDeg: *mut f64,
        ppszAreaName: *mut *const ::std::ffi::c_char,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OSRSetProjection(
        arg1: OGRSpatialReferenceH,
        arg2: *const ::std::ffi::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetProjParm(
        arg1: OGRSpatialReferenceH,
        arg2: *const ::std::ffi::c_char,
        arg3: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRGetProjParm(
        hSRS: OGRSpatialReferenceH,
        pszParamName: *const ::std::ffi::c_char,
        dfDefault: f64,
        arg1: *mut OGRErr::Type,
    ) -> f64;
}
extern "C" {
    pub fn OSRSetNormProjParm(
        arg1: OGRSpatialReferenceH,
        arg2: *const ::std::ffi::c_char,
        arg3: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRGetNormProjParm(
        hSRS: OGRSpatialReferenceH,
        pszParamName: *const ::std::ffi::c_char,
        dfDefault: f64,
        arg1: *mut OGRErr::Type,
    ) -> f64;
}
extern "C" {
    pub fn OSRSetUTM(
        hSRS: OGRSpatialReferenceH,
        nZone: ::std::ffi::c_int,
        bNorth: ::std::ffi::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRGetUTMZone(
        hSRS: OGRSpatialReferenceH,
        pbNorth: *mut ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OSRSetStatePlane(
        hSRS: OGRSpatialReferenceH,
        nZone: ::std::ffi::c_int,
        bNAD83: ::std::ffi::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetStatePlaneWithUnits(
        hSRS: OGRSpatialReferenceH,
        nZone: ::std::ffi::c_int,
        bNAD83: ::std::ffi::c_int,
        pszOverrideUnitName: *const ::std::ffi::c_char,
        dfOverrideUnit: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRAutoIdentifyEPSG(hSRS: OGRSpatialReferenceH) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRFindMatches(
        hSRS: OGRSpatialReferenceH,
        papszOptions: *mut *mut ::std::ffi::c_char,
        pnEntries: *mut ::std::ffi::c_int,
        ppanMatchConfidence: *mut *mut ::std::ffi::c_int,
    ) -> *mut OGRSpatialReferenceH;
}
extern "C" {
    pub fn OSRFreeSRSArray(pahSRS: *mut OGRSpatialReferenceH);
}
extern "C" {
    pub fn OSREPSGTreatsAsLatLong(hSRS: OGRSpatialReferenceH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OSREPSGTreatsAsNorthingEasting(hSRS: OGRSpatialReferenceH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OSRGetAxis(
        hSRS: OGRSpatialReferenceH,
        pszTargetKey: *const ::std::ffi::c_char,
        iAxis: ::std::ffi::c_int,
        peOrientation: *mut OGRAxisOrientation::Type,
    ) -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn OSRGetAxesCount(hSRS: OGRSpatialReferenceH) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OSRSetAxes(
        hSRS: OGRSpatialReferenceH,
        pszTargetKey: *const ::std::ffi::c_char,
        pszXAxisName: *const ::std::ffi::c_char,
        eXAxisOrientation: OGRAxisOrientation::Type,
        pszYAxisName: *const ::std::ffi::c_char,
        eYAxisOrientation: OGRAxisOrientation::Type,
    ) -> OGRErr::Type;
}
pub mod OSRAxisMappingStrategy {
    #[doc = " Data axis to CRS axis mapping strategy."]
    pub type Type = ::std::ffi::c_uint;
    #[doc = "< Traditional GIS order"]
    pub const OAMS_TRADITIONAL_GIS_ORDER: Type = 0;
    #[doc = "< Compliant with the order mandated by the CRS authority"]
    pub const OAMS_AUTHORITY_COMPLIANT: Type = 1;
    #[doc = "< Custom"]
    pub const OAMS_CUSTOM: Type = 2;
}
extern "C" {
    pub fn OSRGetAxisMappingStrategy(hSRS: OGRSpatialReferenceH) -> OSRAxisMappingStrategy::Type;
}
extern "C" {
    pub fn OSRSetAxisMappingStrategy(
        hSRS: OGRSpatialReferenceH,
        strategy: OSRAxisMappingStrategy::Type,
    );
}
extern "C" {
    pub fn OSRGetDataAxisToSRSAxisMapping(
        hSRS: OGRSpatialReferenceH,
        pnCount: *mut ::std::ffi::c_int,
    ) -> *const ::std::ffi::c_int;
}
extern "C" {
    pub fn OSRSetDataAxisToSRSAxisMapping(
        hSRS: OGRSpatialReferenceH,
        nMappingSize: ::std::ffi::c_int,
        panMapping: *const ::std::ffi::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Albers Conic Equal Area"]
    pub fn OSRSetACEA(
        hSRS: OGRSpatialReferenceH,
        dfStdP1: f64,
        dfStdP2: f64,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Azimuthal Equidistant"]
    pub fn OSRSetAE(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Bonne"]
    pub fn OSRSetBonne(
        hSRS: OGRSpatialReferenceH,
        dfStandardParallel: f64,
        dfCentralMeridian: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Cylindrical Equal Area"]
    pub fn OSRSetCEA(
        hSRS: OGRSpatialReferenceH,
        dfStdP1: f64,
        dfCentralMeridian: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Cassini-Soldner"]
    pub fn OSRSetCS(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Equidistant Conic"]
    pub fn OSRSetEC(
        hSRS: OGRSpatialReferenceH,
        dfStdP1: f64,
        dfStdP2: f64,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Eckert I-VI"]
    pub fn OSRSetEckert(
        hSRS: OGRSpatialReferenceH,
        nVariation: ::std::ffi::c_int,
        dfCentralMeridian: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Eckert IV"]
    pub fn OSRSetEckertIV(
        hSRS: OGRSpatialReferenceH,
        dfCentralMeridian: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Eckert VI"]
    pub fn OSRSetEckertVI(
        hSRS: OGRSpatialReferenceH,
        dfCentralMeridian: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Equirectangular"]
    pub fn OSRSetEquirectangular(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Equirectangular generalized form"]
    pub fn OSRSetEquirectangular2(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfPseudoStdParallel1: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Gall Stereograpic"]
    pub fn OSRSetGS(
        hSRS: OGRSpatialReferenceH,
        dfCentralMeridian: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Goode Homolosine"]
    pub fn OSRSetGH(
        hSRS: OGRSpatialReferenceH,
        dfCentralMeridian: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Interrupted Goode Homolosine"]
    pub fn OSRSetIGH(hSRS: OGRSpatialReferenceH) -> OGRErr::Type;
}
extern "C" {
    #[doc = " GEOS - Geostationary Satellite View"]
    pub fn OSRSetGEOS(
        hSRS: OGRSpatialReferenceH,
        dfCentralMeridian: f64,
        dfSatelliteHeight: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Gauss Schreiber Transverse Mercator"]
    pub fn OSRSetGaussSchreiberTMercator(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfScale: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Gnomonic"]
    pub fn OSRSetGnomonic(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Hotine Oblique Mercator using azimuth angle"]
    pub fn OSRSetHOM(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfAzimuth: f64,
        dfRectToSkew: f64,
        dfScale: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetHOMAC(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfAzimuth: f64,
        dfRectToSkew: f64,
        dfScale: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Hotine Oblique Mercator using two points on centerline"]
    pub fn OSRSetHOM2PNO(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfLat1: f64,
        dfLong1: f64,
        dfLat2: f64,
        dfLong2: f64,
        dfScale: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " International Map of the World Polyconic"]
    pub fn OSRSetIWMPolyconic(
        hSRS: OGRSpatialReferenceH,
        dfLat1: f64,
        dfLat2: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Krovak Oblique Conic Conformal"]
    pub fn OSRSetKrovak(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfAzimuth: f64,
        dfPseudoStdParallelLat: f64,
        dfScale: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Lambert Azimuthal Equal-Area"]
    pub fn OSRSetLAEA(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Lambert Conformal Conic"]
    pub fn OSRSetLCC(
        hSRS: OGRSpatialReferenceH,
        dfStdP1: f64,
        dfStdP2: f64,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Lambert Conformal Conic 1SP"]
    pub fn OSRSetLCC1SP(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfScale: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Lambert Conformal Conic (Belgium)"]
    pub fn OSRSetLCCB(
        hSRS: OGRSpatialReferenceH,
        dfStdP1: f64,
        dfStdP2: f64,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Miller Cylindrical"]
    pub fn OSRSetMC(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Mercator"]
    pub fn OSRSetMercator(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfScale: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Mercator 2SP"]
    pub fn OSRSetMercator2SP(
        hSRS: OGRSpatialReferenceH,
        dfStdP1: f64,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Mollweide"]
    pub fn OSRSetMollweide(
        hSRS: OGRSpatialReferenceH,
        dfCentralMeridian: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " New Zealand Map Grid"]
    pub fn OSRSetNZMG(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Oblique Stereographic"]
    pub fn OSRSetOS(
        hSRS: OGRSpatialReferenceH,
        dfOriginLat: f64,
        dfCMeridian: f64,
        dfScale: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Orthographic"]
    pub fn OSRSetOrthographic(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Polyconic"]
    pub fn OSRSetPolyconic(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Polar Stereographic"]
    pub fn OSRSetPS(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfScale: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Robinson"]
    pub fn OSRSetRobinson(
        hSRS: OGRSpatialReferenceH,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Sinusoidal"]
    pub fn OSRSetSinusoidal(
        hSRS: OGRSpatialReferenceH,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Stereographic"]
    pub fn OSRSetStereographic(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfScale: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Swiss Oblique Cylindrical"]
    pub fn OSRSetSOC(
        hSRS: OGRSpatialReferenceH,
        dfLatitudeOfOrigin: f64,
        dfCentralMeridian: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Transverse Mercator\n\n Special processing available for Transverse Mercator with GDAL &gt;= 1.10 and PROJ &gt;= 4.8 :\n see OGRSpatialReference::exportToProj4()."]
    pub fn OSRSetTM(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfScale: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Transverse Mercator variant"]
    pub fn OSRSetTMVariant(
        hSRS: OGRSpatialReferenceH,
        pszVariantName: *const ::std::ffi::c_char,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfScale: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Tunesia Mining Grid"]
    pub fn OSRSetTMG(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Transverse Mercator (South Oriented)"]
    pub fn OSRSetTMSO(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfScale: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " TPED (Two Point Equi Distant)"]
    pub fn OSRSetTPED(
        hSRS: OGRSpatialReferenceH,
        dfLat1: f64,
        dfLong1: f64,
        dfLat2: f64,
        dfLong2: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " VanDerGrinten"]
    pub fn OSRSetVDG(
        hSRS: OGRSpatialReferenceH,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Wagner I -- VII"]
    pub fn OSRSetWagner(
        hSRS: OGRSpatialReferenceH,
        nVariation: ::std::ffi::c_int,
        dfCenterLat: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Quadrilateralized Spherical Cube"]
    pub fn OSRSetQSC(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Spherical, Cross-track, Height"]
    pub fn OSRSetSCH(
        hSRS: OGRSpatialReferenceH,
        dfPegLat: f64,
        dfPegLong: f64,
        dfPegHeading: f64,
        dfPegHgt: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Vertical Perspective / Near-sided Perspective"]
    pub fn OSRSetVerticalPerspective(
        hSRS: OGRSpatialReferenceH,
        dfTopoOriginLat: f64,
        dfTopoOriginLon: f64,
        dfTopoOriginHeight: f64,
        dfViewPointHeight: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRCalcInvFlattening(dfSemiMajor: f64, dfSemiMinor: f64) -> f64;
}
extern "C" {
    pub fn OSRCalcSemiMinorFromInvFlattening(dfSemiMajor: f64, dfInvFlattening: f64) -> f64;
}
extern "C" {
    pub fn OSRCleanup();
}
pub mod OSRCRSType {
    #[doc = " \\brief Type of Coordinate Reference System (CRS)."]
    pub type Type = ::std::ffi::c_uint;
    #[doc = " Geographic 2D CRS"]
    pub const OSR_CRS_TYPE_GEOGRAPHIC_2D: Type = 0;
    #[doc = " Geographic 3D CRS"]
    pub const OSR_CRS_TYPE_GEOGRAPHIC_3D: Type = 1;
    #[doc = " Geocentric CRS"]
    pub const OSR_CRS_TYPE_GEOCENTRIC: Type = 2;
    #[doc = " Projected CRS"]
    pub const OSR_CRS_TYPE_PROJECTED: Type = 3;
    #[doc = " Vertical CRS"]
    pub const OSR_CRS_TYPE_VERTICAL: Type = 4;
    #[doc = " Compound CRS"]
    pub const OSR_CRS_TYPE_COMPOUND: Type = 5;
    #[doc = " Other"]
    pub const OSR_CRS_TYPE_OTHER: Type = 6;
}
#[doc = " \\brief Structure given overall description of a CRS.\n\n This structure may grow over time, and should not be directly allocated by\n client code."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSRCRSInfo {
    #[doc = " Authority name."]
    pub pszAuthName: *mut ::std::ffi::c_char,
    #[doc = " Object code."]
    pub pszCode: *mut ::std::ffi::c_char,
    #[doc = " Object name."]
    pub pszName: *mut ::std::ffi::c_char,
    #[doc = " Object type."]
    pub eType: OSRCRSType::Type,
    #[doc = " Whether the object is deprecated"]
    pub bDeprecated: ::std::ffi::c_int,
    #[doc = " Whereas the west_lon_degree, south_lat_degree, east_lon_degree and\n north_lat_degree fields are valid."]
    pub bBboxValid: ::std::ffi::c_int,
    #[doc = " Western-most longitude of the area of use, in degrees."]
    pub dfWestLongitudeDeg: f64,
    #[doc = " Southern-most latitude of the area of use, in degrees."]
    pub dfSouthLatitudeDeg: f64,
    #[doc = " Eastern-most longitude of the area of use, in degrees."]
    pub dfEastLongitudeDeg: f64,
    #[doc = " Northern-most latitude of the area of use, in degrees."]
    pub dfNorthLatitudeDeg: f64,
    #[doc = " Name of the area of use."]
    pub pszAreaName: *mut ::std::ffi::c_char,
    #[doc = " Name of the projection method for a projected CRS. Might be NULL even\nfor projected CRS in some cases."]
    pub pszProjectionMethod: *mut ::std::ffi::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of OSRCRSInfo"][::std::mem::size_of::<OSRCRSInfo>() - 64usize];
    ["Alignment of OSRCRSInfo"][::std::mem::align_of::<OSRCRSInfo>() - 4usize];
    ["Offset of field: OSRCRSInfo::pszAuthName"]
        [::std::mem::offset_of!(OSRCRSInfo, pszAuthName) - 0usize];
    ["Offset of field: OSRCRSInfo::pszCode"][::std::mem::offset_of!(OSRCRSInfo, pszCode) - 4usize];
    ["Offset of field: OSRCRSInfo::pszName"][::std::mem::offset_of!(OSRCRSInfo, pszName) - 8usize];
    ["Offset of field: OSRCRSInfo::eType"][::std::mem::offset_of!(OSRCRSInfo, eType) - 12usize];
    ["Offset of field: OSRCRSInfo::bDeprecated"]
        [::std::mem::offset_of!(OSRCRSInfo, bDeprecated) - 16usize];
    ["Offset of field: OSRCRSInfo::bBboxValid"]
        [::std::mem::offset_of!(OSRCRSInfo, bBboxValid) - 20usize];
    ["Offset of field: OSRCRSInfo::dfWestLongitudeDeg"]
        [::std::mem::offset_of!(OSRCRSInfo, dfWestLongitudeDeg) - 24usize];
    ["Offset of field: OSRCRSInfo::dfSouthLatitudeDeg"]
        [::std::mem::offset_of!(OSRCRSInfo, dfSouthLatitudeDeg) - 32usize];
    ["Offset of field: OSRCRSInfo::dfEastLongitudeDeg"]
        [::std::mem::offset_of!(OSRCRSInfo, dfEastLongitudeDeg) - 40usize];
    ["Offset of field: OSRCRSInfo::dfNorthLatitudeDeg"]
        [::std::mem::offset_of!(OSRCRSInfo, dfNorthLatitudeDeg) - 48usize];
    ["Offset of field: OSRCRSInfo::pszAreaName"]
        [::std::mem::offset_of!(OSRCRSInfo, pszAreaName) - 56usize];
    ["Offset of field: OSRCRSInfo::pszProjectionMethod"]
        [::std::mem::offset_of!(OSRCRSInfo, pszProjectionMethod) - 60usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSRCRSListParameters {
    _unused: [u8; 0],
}
extern "C" {
    pub fn OSRGetCRSInfoListFromDatabase(
        pszAuthName: *const ::std::ffi::c_char,
        params: *const OSRCRSListParameters,
        pnOutResultCount: *mut ::std::ffi::c_int,
    ) -> *mut *mut OSRCRSInfo;
}
extern "C" {
    pub fn OSRDestroyCRSInfoList(list: *mut *mut OSRCRSInfo);
}
extern "C" {
    pub fn OCTNewCoordinateTransformation(
        hSourceSRS: OGRSpatialReferenceH,
        hTargetSRS: OGRSpatialReferenceH,
    ) -> OGRCoordinateTransformationH;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OGRCoordinateTransformationOptions {
    _unused: [u8; 0],
}
#[doc = " Coordinate transformation options."]
pub type OGRCoordinateTransformationOptionsH = *mut OGRCoordinateTransformationOptions;
extern "C" {
    pub fn OCTNewCoordinateTransformationOptions() -> OGRCoordinateTransformationOptionsH;
}
extern "C" {
    pub fn OCTCoordinateTransformationOptionsSetOperation(
        hOptions: OGRCoordinateTransformationOptionsH,
        pszCO: *const ::std::ffi::c_char,
        bReverseCO: ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OCTCoordinateTransformationOptionsSetAreaOfInterest(
        hOptions: OGRCoordinateTransformationOptionsH,
        dfWestLongitudeDeg: f64,
        dfSouthLatitudeDeg: f64,
        dfEastLongitudeDeg: f64,
        dfNorthLatitudeDeg: f64,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OCTCoordinateTransformationOptionsSetDesiredAccuracy(
        hOptions: OGRCoordinateTransformationOptionsH,
        dfAccuracy: f64,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OCTCoordinateTransformationOptionsSetBallparkAllowed(
        hOptions: OGRCoordinateTransformationOptionsH,
        bAllowBallpark: ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OCTDestroyCoordinateTransformationOptions(arg1: OGRCoordinateTransformationOptionsH);
}
extern "C" {
    pub fn OCTNewCoordinateTransformationEx(
        hSourceSRS: OGRSpatialReferenceH,
        hTargetSRS: OGRSpatialReferenceH,
        hOptions: OGRCoordinateTransformationOptionsH,
    ) -> OGRCoordinateTransformationH;
}
extern "C" {
    pub fn OCTClone(hTransform: OGRCoordinateTransformationH) -> OGRCoordinateTransformationH;
}
extern "C" {
    pub fn OCTGetSourceCS(hTransform: OGRCoordinateTransformationH) -> OGRSpatialReferenceH;
}
extern "C" {
    pub fn OCTGetTargetCS(hTransform: OGRCoordinateTransformationH) -> OGRSpatialReferenceH;
}
extern "C" {
    pub fn OCTGetInverse(hTransform: OGRCoordinateTransformationH) -> OGRCoordinateTransformationH;
}
extern "C" {
    pub fn OCTDestroyCoordinateTransformation(arg1: OGRCoordinateTransformationH);
}
extern "C" {
    pub fn OCTTransform(
        hCT: OGRCoordinateTransformationH,
        nCount: ::std::ffi::c_int,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OCTTransformEx(
        hCT: OGRCoordinateTransformationH,
        nCount: ::std::ffi::c_int,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
        pabSuccess: *mut ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OCTTransform4D(
        hCT: OGRCoordinateTransformationH,
        nCount: ::std::ffi::c_int,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
        t: *mut f64,
        pabSuccess: *mut ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OCTTransform4DWithErrorCodes(
        hCT: OGRCoordinateTransformationH,
        nCount: ::std::ffi::c_int,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
        t: *mut f64,
        panErrorCodes: *mut ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn OCTTransformBounds(
        hCT: OGRCoordinateTransformationH,
        xmin: f64,
        ymin: f64,
        xmax: f64,
        ymax: f64,
        out_xmin: *mut f64,
        out_ymin: *mut f64,
        out_xmax: *mut f64,
        out_ymax: *mut f64,
        densify_pts: ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
pub type CPLThreadFunc = ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::ffi::c_void)>;
extern "C" {
    pub fn CPLLockFile(
        pszPath: *const ::std::ffi::c_char,
        dfWaitInSeconds: f64,
    ) -> *mut ::std::ffi::c_void;
}
extern "C" {
    pub fn CPLUnlockFile(hLock: *mut ::std::ffi::c_void);
}
extern "C" {
    pub fn CPLCreateMutex() -> *mut ::std::ffi::c_void;
}
extern "C" {
    pub fn CPLCreateMutexEx(nOptions: ::std::ffi::c_int) -> *mut ::std::ffi::c_void;
}
extern "C" {
    pub fn CPLCreateOrAcquireMutex(
        arg1: *mut *mut ::std::ffi::c_void,
        dfWaitInSeconds: f64,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn CPLCreateOrAcquireMutexEx(
        arg1: *mut *mut ::std::ffi::c_void,
        dfWaitInSeconds: f64,
        nOptions: ::std::ffi::c_int,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn CPLAcquireMutex(
        hMutex: *mut ::std::ffi::c_void,
        dfWaitInSeconds: f64,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn CPLReleaseMutex(hMutex: *mut ::std::ffi::c_void);
}
extern "C" {
    pub fn CPLDestroyMutex(hMutex: *mut ::std::ffi::c_void);
}
extern "C" {
    pub fn CPLCleanupMasterMutex();
}
extern "C" {
    pub fn CPLCreateCond() -> *mut ::std::ffi::c_void;
}
extern "C" {
    pub fn CPLCondWait(hCond: *mut ::std::ffi::c_void, hMutex: *mut ::std::ffi::c_void);
}
pub mod CPLCondTimedWaitReason {
    pub type Type = ::std::ffi::c_uint;
    pub const COND_TIMED_WAIT_COND: Type = 0;
    pub const COND_TIMED_WAIT_TIME_OUT: Type = 1;
    pub const COND_TIMED_WAIT_OTHER: Type = 2;
}
extern "C" {
    pub fn CPLCondTimedWait(
        hCond: *mut ::std::ffi::c_void,
        hMutex: *mut ::std::ffi::c_void,
        dfWaitInSeconds: f64,
    ) -> CPLCondTimedWaitReason::Type;
}
extern "C" {
    pub fn CPLCondSignal(hCond: *mut ::std::ffi::c_void);
}
extern "C" {
    pub fn CPLCondBroadcast(hCond: *mut ::std::ffi::c_void);
}
extern "C" {
    pub fn CPLDestroyCond(hCond: *mut ::std::ffi::c_void);
}
extern "C" {
    #[doc = " Contrary to what its name suggests, CPLGetPID() actually returns the thread id"]
    pub fn CPLGetPID() -> GIntBig;
}
extern "C" {
    pub fn CPLGetCurrentProcessID() -> ::std::ffi::c_int;
}
extern "C" {
    pub fn CPLCreateThread(
        pfnMain: CPLThreadFunc,
        pArg: *mut ::std::ffi::c_void,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn CPLCreateJoinableThread(
        pfnMain: CPLThreadFunc,
        pArg: *mut ::std::ffi::c_void,
    ) -> *mut ::std::ffi::c_void;
}
extern "C" {
    pub fn CPLJoinThread(hJoinableThread: *mut ::std::ffi::c_void);
}
extern "C" {
    pub fn CPLSleep(dfWaitInSeconds: f64);
}
extern "C" {
    pub fn CPLGetThreadingModel() -> *const ::std::ffi::c_char;
}
extern "C" {
    pub fn CPLGetNumCPUs() -> ::std::ffi::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CPLLock {
    _unused: [u8; 0],
}
pub type CPLLock = _CPLLock;
pub mod CPLLockType {
    pub type Type = ::std::ffi::c_uint;
    pub const LOCK_RECURSIVE_MUTEX: Type = 0;
    pub const LOCK_ADAPTIVE_MUTEX: Type = 1;
    pub const LOCK_SPIN: Type = 2;
}
extern "C" {
    pub fn CPLCreateLock(eType: CPLLockType::Type) -> *mut CPLLock;
}
extern "C" {
    pub fn CPLCreateOrAcquireLock(
        arg1: *mut *mut CPLLock,
        eType: CPLLockType::Type,
    ) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn CPLAcquireLock(arg1: *mut CPLLock) -> ::std::ffi::c_int;
}
extern "C" {
    pub fn CPLReleaseLock(arg1: *mut CPLLock);
}
extern "C" {
    pub fn CPLDestroyLock(arg1: *mut CPLLock);
}
extern "C" {
    pub fn CPLLockSetDebugPerf(arg1: *mut CPLLock, bEnableIn: ::std::ffi::c_int);
}
extern "C" {
    pub fn CPLGetTLS(nIndex: ::std::ffi::c_int) -> *mut ::std::ffi::c_void;
}
extern "C" {
    pub fn CPLGetTLSEx(
        nIndex: ::std::ffi::c_int,
        pbMemoryErrorOccurred: *mut ::std::ffi::c_int,
    ) -> *mut ::std::ffi::c_void;
}
extern "C" {
    pub fn CPLSetTLS(
        nIndex: ::std::ffi::c_int,
        pData: *mut ::std::ffi::c_void,
        bFreeOnExit: ::std::ffi::c_int,
    );
}
pub type CPLTLSFreeFunc =
    ::std::option::Option<unsafe extern "C" fn(pData: *mut ::std::ffi::c_void)>;
extern "C" {
    pub fn CPLSetTLSWithFreeFunc(
        nIndex: ::std::ffi::c_int,
        pData: *mut ::std::ffi::c_void,
        pfnFree: CPLTLSFreeFunc,
    );
}
extern "C" {
    pub fn CPLSetTLSWithFreeFuncEx(
        nIndex: ::std::ffi::c_int,
        pData: *mut ::std::ffi::c_void,
        pfnFree: CPLTLSFreeFunc,
        pbMemoryErrorOccurred: *mut ::std::ffi::c_int,
    );
}
extern "C" {
    pub fn CPLCleanupTLS();
}
pub mod GDALResampleAlg {
    #[doc = " Warp Resampling Algorithm"]
    pub type Type = ::std::ffi::c_uint;
    #[doc = " Nearest neighbour (select on one input pixel)"]
    pub const GRA_NearestNeighbour: Type = 0;
    #[doc = " Bilinear (2x2 kernel)"]
    pub const GRA_Bilinear: Type = 1;
    #[doc = " Cubic Convolution Approximation (4x4 kernel)"]
    pub const GRA_Cubic: Type = 2;
    #[doc = " Cubic B-Spline Approximation (4x4 kernel)"]
    pub const GRA_CubicSpline: Type = 3;
    #[doc = " Lanczos windowed sinc interpolation (6x6 kernel)"]
    pub const GRA_Lanczos: Type = 4;
    #[doc = " Average (computes the weighted average of all non-NODATA contributing pixels)"]
    pub const GRA_Average: Type = 5;
    #[doc = " Mode (selects the value which appears most often of all the sampled points)"]
    pub const GRA_Mode: Type = 6;
    #[doc = " Max (selects maximum of all non-NODATA contributing pixels)"]
    pub const GRA_Max: Type = 8;
    #[doc = " Min (selects minimum of all non-NODATA contributing pixels)"]
    pub const GRA_Min: Type = 9;
    #[doc = " Med (selects median of all non-NODATA contributing pixels)"]
    pub const GRA_Med: Type = 10;
    #[doc = " Q1 (selects first quartile of all non-NODATA contributing pixels)"]
    pub const GRA_Q1: Type = 11;
    #[doc = " Q3 (selects third quartile of all non-NODATA contributing pixels)"]
    pub const GRA_Q3: Type = 12;
    #[doc = " Sum (weighed sum of all non-NODATA contributing pixels). Added in GDAL 3.1"]
    pub const GRA_Sum: Type = 13;
    #[doc = " RMS (weighted root mean square (quadratic mean) of all non-NODATA contributing pixels)"]
    pub const GRA_RMS: Type = 14;
    #[doc = " @cond Doxygen_Suppress"]
    pub const GRA_LAST_VALUE: Type = 14;
}
#[doc = " @cond Doxygen_Suppress"]
pub type GDALMaskFunc = ::std::option::Option<
    unsafe extern "C" fn(
        pMaskFuncArg: *mut ::std::ffi::c_void,
        nBandCount: ::std::ffi::c_int,
        eType: GDALDataType::Type,
        nXOff: ::std::ffi::c_int,
        nYOff: ::std::ffi::c_int,
        nXSize: ::std::ffi::c_int,
        nYSize: ::std::ffi::c_int,
        papabyImageData: *mut *mut GByte,
        bMaskIsFloat: ::std::ffi::c_int,
        pMask: *mut ::std::ffi::c_void,
    ) -> ::std::ffi::c_int,
>;
extern "C" {
    pub fn GDALWarpNoDataMasker(
        pMaskFuncArg: *mut ::std::ffi::c_void,
        nBandCount: ::std::ffi::c_int,
        eType: GDALDataType::Type,
        nXOff: ::std::ffi::c_int,
        nYOff: ::std::ffi::c_int,
        nXSize: ::std::ffi::c_int,
        nYSize: ::std::ffi::c_int,
        papabyImageData: *mut *mut GByte,
        bMaskIsFloat: ::std::ffi::c_int,
        pValidityMask: *mut ::std::ffi::c_void,
        pbOutAllValid: *mut ::std::ffi::c_int,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALWarpDstAlphaMasker(
        pMaskFuncArg: *mut ::std::ffi::c_void,
        nBandCount: ::std::ffi::c_int,
        eType: GDALDataType::Type,
        nXOff: ::std::ffi::c_int,
        nYOff: ::std::ffi::c_int,
        nXSize: ::std::ffi::c_int,
        nYSize: ::std::ffi::c_int,
        arg1: *mut *mut GByte,
        bMaskIsFloat: ::std::ffi::c_int,
        pValidityMask: *mut ::std::ffi::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALWarpSrcAlphaMasker(
        pMaskFuncArg: *mut ::std::ffi::c_void,
        nBandCount: ::std::ffi::c_int,
        eType: GDALDataType::Type,
        nXOff: ::std::ffi::c_int,
        nYOff: ::std::ffi::c_int,
        nXSize: ::std::ffi::c_int,
        nYSize: ::std::ffi::c_int,
        arg1: *mut *mut GByte,
        bMaskIsFloat: ::std::ffi::c_int,
        pValidityMask: *mut ::std::ffi::c_void,
        pbOutAllOpaque: *mut ::std::ffi::c_int,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALWarpSrcMaskMasker(
        pMaskFuncArg: *mut ::std::ffi::c_void,
        nBandCount: ::std::ffi::c_int,
        eType: GDALDataType::Type,
        nXOff: ::std::ffi::c_int,
        nYOff: ::std::ffi::c_int,
        nXSize: ::std::ffi::c_int,
        nYSize: ::std::ffi::c_int,
        arg1: *mut *mut GByte,
        bMaskIsFloat: ::std::ffi::c_int,
        pValidityMask: *mut ::std::ffi::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALWarpCutlineMasker(
        pMaskFuncArg: *mut ::std::ffi::c_void,
        nBandCount: ::std::ffi::c_int,
        eType: GDALDataType::Type,
        nXOff: ::std::ffi::c_int,
        nYOff: ::std::ffi::c_int,
        nXSize: ::std::ffi::c_int,
        nYSize: ::std::ffi::c_int,
        arg1: *mut *mut GByte,
        bMaskIsFloat: ::std::ffi::c_int,
        pValidityMask: *mut ::std::ffi::c_void,
    ) -> CPLErr::Type;
}
#[doc = " Warp control options for use with GDALWarpOperation::Initialize()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALWarpOptions {
    pub papszWarpOptions: *mut *mut ::std::ffi::c_char,
    #[doc = " In bytes, 0.0 for internal default"]
    pub dfWarpMemoryLimit: f64,
    #[doc = " Resampling algorithm to use"]
    pub eResampleAlg: GDALResampleAlg::Type,
    #[doc = " data type to use during warp operation, GDT_Unknown lets the algorithm\nselect the type"]
    pub eWorkingDataType: GDALDataType::Type,
    #[doc = " Source image dataset."]
    pub hSrcDS: GDALDatasetH,
    #[doc = " Destination image dataset - may be NULL if only using GDALWarpOperation::WarpRegionToBuffer()."]
    pub hDstDS: GDALDatasetH,
    #[doc = " Number of bands to process, may be 0 to select all bands."]
    pub nBandCount: ::std::ffi::c_int,
    #[doc = " The band numbers for the source bands to process (1 based)"]
    pub panSrcBands: *mut ::std::ffi::c_int,
    #[doc = " The band numbers for the destination bands to process (1 based)"]
    pub panDstBands: *mut ::std::ffi::c_int,
    #[doc = " The source band so use as an alpha (transparency) value, 0=disabled"]
    pub nSrcAlphaBand: ::std::ffi::c_int,
    #[doc = " The dest. band so use as an alpha (transparency) value, 0=disabled"]
    pub nDstAlphaBand: ::std::ffi::c_int,
    #[doc = " The \"nodata\" value real component for each input band, if NULL there isn't one"]
    pub padfSrcNoDataReal: *mut f64,
    #[doc = " The \"nodata\" value imaginary component - may be NULL even if real\ncomponent is provided. This value is not used to flag invalid values.\nOnly the real component is used."]
    pub padfSrcNoDataImag: *mut f64,
    #[doc = " The \"nodata\" value real component for each output band, if NULL there isn't one"]
    pub padfDstNoDataReal: *mut f64,
    #[doc = " The \"nodata\" value imaginary component - may be NULL even if real\ncomponent is provided. Note that warp operations only use real component\nfor flagging invalid data."]
    pub padfDstNoDataImag: *mut f64,
    #[doc = " GDALProgressFunc() compatible progress reporting function, or NULL\nif there isn't one."]
    pub pfnProgress: GDALProgressFunc,
    #[doc = " Callback argument to be passed to pfnProgress."]
    pub pProgressArg: *mut ::std::ffi::c_void,
    #[doc = " Type of spatial point transformer function"]
    pub pfnTransformer: GDALTransformerFunc,
    #[doc = " Handle to image transformer setup structure"]
    pub pTransformerArg: *mut ::std::ffi::c_void,
    #[doc = " Unused. Must be NULL"]
    pub papfnSrcPerBandValidityMaskFunc: *mut GDALMaskFunc,
    #[doc = " Unused. Must be NULL"]
    pub papSrcPerBandValidityMaskFuncArg: *mut *mut ::std::ffi::c_void,
    #[doc = " Unused. Must be NULL"]
    pub pfnSrcValidityMaskFunc: GDALMaskFunc,
    #[doc = " Unused. Must be NULL"]
    pub pSrcValidityMaskFuncArg: *mut ::std::ffi::c_void,
    #[doc = " Unused. Must be NULL"]
    pub pfnSrcDensityMaskFunc: GDALMaskFunc,
    #[doc = " Unused. Must be NULL"]
    pub pSrcDensityMaskFuncArg: *mut ::std::ffi::c_void,
    #[doc = " Unused. Must be NULL"]
    pub pfnDstDensityMaskFunc: GDALMaskFunc,
    #[doc = " Unused. Must be NULL"]
    pub pDstDensityMaskFuncArg: *mut ::std::ffi::c_void,
    #[doc = " Unused. Must be NULL"]
    pub pfnDstValidityMaskFunc: GDALMaskFunc,
    #[doc = " Unused. Must be NULL"]
    pub pDstValidityMaskFuncArg: *mut ::std::ffi::c_void,
    #[doc = " Unused. Must be NULL"]
    pub pfnPreWarpChunkProcessor: ::std::option::Option<
        unsafe extern "C" fn(
            pKern: *mut ::std::ffi::c_void,
            pArg: *mut ::std::ffi::c_void,
        ) -> CPLErr::Type,
    >,
    #[doc = " Unused. Must be NULL"]
    pub pPreWarpProcessorArg: *mut ::std::ffi::c_void,
    #[doc = " Unused. Must be NULL"]
    pub pfnPostWarpChunkProcessor: ::std::option::Option<
        unsafe extern "C" fn(
            pKern: *mut ::std::ffi::c_void,
            pArg: *mut ::std::ffi::c_void,
        ) -> CPLErr::Type,
    >,
    #[doc = " Unused. Must be NULL"]
    pub pPostWarpProcessorArg: *mut ::std::ffi::c_void,
    #[doc = " Optional OGRPolygonH for a masking cutline."]
    pub hCutline: *mut ::std::ffi::c_void,
    #[doc = " Optional blending distance to apply across cutline in pixels, default is zero."]
    pub dfCutlineBlendDist: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GDALWarpOptions"][::std::mem::size_of::<GDALWarpOptions>() - 148usize];
    ["Alignment of GDALWarpOptions"][::std::mem::align_of::<GDALWarpOptions>() - 4usize];
    ["Offset of field: GDALWarpOptions::papszWarpOptions"]
        [::std::mem::offset_of!(GDALWarpOptions, papszWarpOptions) - 0usize];
    ["Offset of field: GDALWarpOptions::dfWarpMemoryLimit"]
        [::std::mem::offset_of!(GDALWarpOptions, dfWarpMemoryLimit) - 4usize];
    ["Offset of field: GDALWarpOptions::eResampleAlg"]
        [::std::mem::offset_of!(GDALWarpOptions, eResampleAlg) - 12usize];
    ["Offset of field: GDALWarpOptions::eWorkingDataType"]
        [::std::mem::offset_of!(GDALWarpOptions, eWorkingDataType) - 16usize];
    ["Offset of field: GDALWarpOptions::hSrcDS"]
        [::std::mem::offset_of!(GDALWarpOptions, hSrcDS) - 20usize];
    ["Offset of field: GDALWarpOptions::hDstDS"]
        [::std::mem::offset_of!(GDALWarpOptions, hDstDS) - 24usize];
    ["Offset of field: GDALWarpOptions::nBandCount"]
        [::std::mem::offset_of!(GDALWarpOptions, nBandCount) - 28usize];
    ["Offset of field: GDALWarpOptions::panSrcBands"]
        [::std::mem::offset_of!(GDALWarpOptions, panSrcBands) - 32usize];
    ["Offset of field: GDALWarpOptions::panDstBands"]
        [::std::mem::offset_of!(GDALWarpOptions, panDstBands) - 36usize];
    ["Offset of field: GDALWarpOptions::nSrcAlphaBand"]
        [::std::mem::offset_of!(GDALWarpOptions, nSrcAlphaBand) - 40usize];
    ["Offset of field: GDALWarpOptions::nDstAlphaBand"]
        [::std::mem::offset_of!(GDALWarpOptions, nDstAlphaBand) - 44usize];
    ["Offset of field: GDALWarpOptions::padfSrcNoDataReal"]
        [::std::mem::offset_of!(GDALWarpOptions, padfSrcNoDataReal) - 48usize];
    ["Offset of field: GDALWarpOptions::padfSrcNoDataImag"]
        [::std::mem::offset_of!(GDALWarpOptions, padfSrcNoDataImag) - 52usize];
    ["Offset of field: GDALWarpOptions::padfDstNoDataReal"]
        [::std::mem::offset_of!(GDALWarpOptions, padfDstNoDataReal) - 56usize];
    ["Offset of field: GDALWarpOptions::padfDstNoDataImag"]
        [::std::mem::offset_of!(GDALWarpOptions, padfDstNoDataImag) - 60usize];
    ["Offset of field: GDALWarpOptions::pfnProgress"]
        [::std::mem::offset_of!(GDALWarpOptions, pfnProgress) - 64usize];
    ["Offset of field: GDALWarpOptions::pProgressArg"]
        [::std::mem::offset_of!(GDALWarpOptions, pProgressArg) - 68usize];
    ["Offset of field: GDALWarpOptions::pfnTransformer"]
        [::std::mem::offset_of!(GDALWarpOptions, pfnTransformer) - 72usize];
    ["Offset of field: GDALWarpOptions::pTransformerArg"]
        [::std::mem::offset_of!(GDALWarpOptions, pTransformerArg) - 76usize];
    ["Offset of field: GDALWarpOptions::papfnSrcPerBandValidityMaskFunc"]
        [::std::mem::offset_of!(GDALWarpOptions, papfnSrcPerBandValidityMaskFunc) - 80usize];
    ["Offset of field: GDALWarpOptions::papSrcPerBandValidityMaskFuncArg"]
        [::std::mem::offset_of!(GDALWarpOptions, papSrcPerBandValidityMaskFuncArg) - 84usize];
    ["Offset of field: GDALWarpOptions::pfnSrcValidityMaskFunc"]
        [::std::mem::offset_of!(GDALWarpOptions, pfnSrcValidityMaskFunc) - 88usize];
    ["Offset of field: GDALWarpOptions::pSrcValidityMaskFuncArg"]
        [::std::mem::offset_of!(GDALWarpOptions, pSrcValidityMaskFuncArg) - 92usize];
    ["Offset of field: GDALWarpOptions::pfnSrcDensityMaskFunc"]
        [::std::mem::offset_of!(GDALWarpOptions, pfnSrcDensityMaskFunc) - 96usize];
    ["Offset of field: GDALWarpOptions::pSrcDensityMaskFuncArg"]
        [::std::mem::offset_of!(GDALWarpOptions, pSrcDensityMaskFuncArg) - 100usize];
    ["Offset of field: GDALWarpOptions::pfnDstDensityMaskFunc"]
        [::std::mem::offset_of!(GDALWarpOptions, pfnDstDensityMaskFunc) - 104usize];
    ["Offset of field: GDALWarpOptions::pDstDensityMaskFuncArg"]
        [::std::mem::offset_of!(GDALWarpOptions, pDstDensityMaskFuncArg) - 108usize];
    ["Offset of field: GDALWarpOptions::pfnDstValidityMaskFunc"]
        [::std::mem::offset_of!(GDALWarpOptions, pfnDstValidityMaskFunc) - 112usize];
    ["Offset of field: GDALWarpOptions::pDstValidityMaskFuncArg"]
        [::std::mem::offset_of!(GDALWarpOptions, pDstValidityMaskFuncArg) - 116usize];
    ["Offset of field: GDALWarpOptions::pfnPreWarpChunkProcessor"]
        [::std::mem::offset_of!(GDALWarpOptions, pfnPreWarpChunkProcessor) - 120usize];
    ["Offset of field: GDALWarpOptions::pPreWarpProcessorArg"]
        [::std::mem::offset_of!(GDALWarpOptions, pPreWarpProcessorArg) - 124usize];
    ["Offset of field: GDALWarpOptions::pfnPostWarpChunkProcessor"]
        [::std::mem::offset_of!(GDALWarpOptions, pfnPostWarpChunkProcessor) - 128usize];
    ["Offset of field: GDALWarpOptions::pPostWarpProcessorArg"]
        [::std::mem::offset_of!(GDALWarpOptions, pPostWarpProcessorArg) - 132usize];
    ["Offset of field: GDALWarpOptions::hCutline"]
        [::std::mem::offset_of!(GDALWarpOptions, hCutline) - 136usize];
    ["Offset of field: GDALWarpOptions::dfCutlineBlendDist"]
        [::std::mem::offset_of!(GDALWarpOptions, dfCutlineBlendDist) - 140usize];
};
extern "C" {
    pub fn GDALCreateWarpOptions() -> *mut GDALWarpOptions;
}
extern "C" {
    pub fn GDALDestroyWarpOptions(arg1: *mut GDALWarpOptions);
}
extern "C" {
    pub fn GDALCloneWarpOptions(arg1: *const GDALWarpOptions) -> *mut GDALWarpOptions;
}
extern "C" {
    pub fn GDALWarpInitDstNoDataReal(arg1: *mut GDALWarpOptions, dNoDataReal: f64);
}
extern "C" {
    pub fn GDALWarpInitSrcNoDataReal(arg1: *mut GDALWarpOptions, dNoDataReal: f64);
}
extern "C" {
    pub fn GDALWarpInitNoDataReal(arg1: *mut GDALWarpOptions, dNoDataReal: f64);
}
extern "C" {
    pub fn GDALWarpInitDstNoDataImag(arg1: *mut GDALWarpOptions, dNoDataImag: f64);
}
extern "C" {
    pub fn GDALWarpInitSrcNoDataImag(arg1: *mut GDALWarpOptions, dNoDataImag: f64);
}
extern "C" {
    pub fn GDALWarpResolveWorkingDataType(arg1: *mut GDALWarpOptions);
}
extern "C" {
    pub fn GDALWarpInitDefaultBandMapping(
        arg1: *mut GDALWarpOptions,
        nBandCount: ::std::ffi::c_int,
    );
}
extern "C" {
    #[doc = " @cond Doxygen_Suppress"]
    pub fn GDALSerializeWarpOptions(arg1: *const GDALWarpOptions) -> *mut CPLXMLNode;
}
extern "C" {
    pub fn GDALDeserializeWarpOptions(arg1: *mut CPLXMLNode) -> *mut GDALWarpOptions;
}
extern "C" {
    pub fn GDALReprojectImage(
        hSrcDS: GDALDatasetH,
        pszSrcWKT: *const ::std::ffi::c_char,
        hDstDS: GDALDatasetH,
        pszDstWKT: *const ::std::ffi::c_char,
        eResampleAlg: GDALResampleAlg::Type,
        dfWarpMemoryLimit: f64,
        dfMaxError: f64,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut ::std::ffi::c_void,
        psOptions: *mut GDALWarpOptions,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALCreateAndReprojectImage(
        hSrcDS: GDALDatasetH,
        pszSrcWKT: *const ::std::ffi::c_char,
        pszDstFilename: *const ::std::ffi::c_char,
        pszDstWKT: *const ::std::ffi::c_char,
        hDstDriver: GDALDriverH,
        papszCreateOptions: *mut *mut ::std::ffi::c_char,
        eResampleAlg: GDALResampleAlg::Type,
        dfWarpMemoryLimit: f64,
        dfMaxError: f64,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut ::std::ffi::c_void,
        psOptions: *mut GDALWarpOptions,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALAutoCreateWarpedVRT(
        hSrcDS: GDALDatasetH,
        pszSrcWKT: *const ::std::ffi::c_char,
        pszDstWKT: *const ::std::ffi::c_char,
        eResampleAlg: GDALResampleAlg::Type,
        dfMaxError: f64,
        psOptions: *const GDALWarpOptions,
    ) -> GDALDatasetH;
}
extern "C" {
    pub fn GDALAutoCreateWarpedVRTEx(
        hSrcDS: GDALDatasetH,
        pszSrcWKT: *const ::std::ffi::c_char,
        pszDstWKT: *const ::std::ffi::c_char,
        eResampleAlg: GDALResampleAlg::Type,
        dfMaxError: f64,
        psOptions: *const GDALWarpOptions,
        papszTransformerOptions: CSLConstList,
    ) -> GDALDatasetH;
}
extern "C" {
    pub fn GDALCreateWarpedVRT(
        hSrcDS: GDALDatasetH,
        nPixels: ::std::ffi::c_int,
        nLines: ::std::ffi::c_int,
        padfGeoTransform: *mut f64,
        psOptions: *mut GDALWarpOptions,
    ) -> GDALDatasetH;
}
extern "C" {
    pub fn GDALInitializeWarpedVRT(hDS: GDALDatasetH, psWO: *mut GDALWarpOptions) -> CPLErr::Type;
}
#[doc = " Opaque type representing a GDALWarpOperation object"]
pub type GDALWarpOperationH = *mut ::std::ffi::c_void;
extern "C" {
    pub fn GDALCreateWarpOperation(arg1: *const GDALWarpOptions) -> GDALWarpOperationH;
}
extern "C" {
    pub fn GDALDestroyWarpOperation(arg1: GDALWarpOperationH);
}
extern "C" {
    pub fn GDALChunkAndWarpImage(
        arg1: GDALWarpOperationH,
        arg2: ::std::ffi::c_int,
        arg3: ::std::ffi::c_int,
        arg4: ::std::ffi::c_int,
        arg5: ::std::ffi::c_int,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALChunkAndWarpMulti(
        arg1: GDALWarpOperationH,
        arg2: ::std::ffi::c_int,
        arg3: ::std::ffi::c_int,
        arg4: ::std::ffi::c_int,
        arg5: ::std::ffi::c_int,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALWarpRegion(
        arg1: GDALWarpOperationH,
        arg2: ::std::ffi::c_int,
        arg3: ::std::ffi::c_int,
        arg4: ::std::ffi::c_int,
        arg5: ::std::ffi::c_int,
        arg6: ::std::ffi::c_int,
        arg7: ::std::ffi::c_int,
        arg8: ::std::ffi::c_int,
        arg9: ::std::ffi::c_int,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALWarpRegionToBuffer(
        arg1: GDALWarpOperationH,
        arg2: ::std::ffi::c_int,
        arg3: ::std::ffi::c_int,
        arg4: ::std::ffi::c_int,
        arg5: ::std::ffi::c_int,
        arg6: *mut ::std::ffi::c_void,
        arg7: GDALDataType::Type,
        arg8: ::std::ffi::c_int,
        arg9: ::std::ffi::c_int,
        arg10: ::std::ffi::c_int,
        arg11: ::std::ffi::c_int,
    ) -> CPLErr::Type;
}
pub mod OGRErr {
    #[doc = " Type for a OGR error\n\n <div rustbindgen replaces=\"OGRErr\"></div>"]
    pub type Type = ::std::ffi::c_uint;
    #[doc = " Success\n\n <div rustbindgen replaces=\"OGRERR_NONE\"></div>"]
    pub const OGRERR_NONE: Type = 0;
    #[doc = " Not enough data to deserialize\n\n <div rustbindgen replaces=\"OGRERR_NOT_ENOUGH_DATA\"></div>"]
    pub const OGRERR_NOT_ENOUGH_DATA: Type = 1;
    #[doc = " Not enough memory\n\n <div rustbindgen replaces=\"OGRERR_NOT_ENOUGH_MEMORY\"></div>"]
    pub const OGRERR_NOT_ENOUGH_MEMORY: Type = 2;
    #[doc = " Unsupported geometry type\n\n <div rustbindgen replaces=\"OGRERR_UNSUPPORTED_GEOMETRY_TYPE\"></div>"]
    pub const OGRERR_UNSUPPORTED_GEOMETRY_TYPE: Type = 3;
    #[doc = " Unsupported operation\n\n <div rustbindgen replaces=\"OGRERR_UNSUPPORTED_OPERATION\"></div>"]
    pub const OGRERR_UNSUPPORTED_OPERATION: Type = 4;
    #[doc = " Corrupt data\n\n <div rustbindgen replaces=\"OGRERR_CORRUPT_DATA\"></div>"]
    pub const OGRERR_CORRUPT_DATA: Type = 5;
    #[doc = " Failure\n\n <div rustbindgen replaces=\"OGRERR_FAILURE\"></div>"]
    pub const OGRERR_FAILURE: Type = 6;
    #[doc = " Unsupported SRS\n\n <div rustbindgen replaces=\"OGRERR_UNSUPPORTED_SRS\"></div>"]
    pub const OGRERR_UNSUPPORTED_SRS: Type = 7;
    #[doc = " Invalid handle\n\n <div rustbindgen replaces=\"INVALID_HANDLE\"></div>"]
    pub const INVALID_HANDLE: Type = 8;
    #[doc = " Non existing feature. Added in GDAL 2.0\n\n <div rustbindgen replaces=\"NON_EXISTING_FEATURE\"></div>"]
    pub const NON_EXISTING_FEATURE: Type = 9;
}
pub type __builtin_va_list = *mut ::std::ffi::c_char;
