/* automatically generated by rust-bindgen 0.59.1 */

pub type va_list = __builtin_va_list;
pub type __dev_t = libc::c_ulong;
pub type __uid_t = libc::c_uint;
pub type __gid_t = libc::c_uint;
pub type __ino_t = libc::c_ulong;
pub type __mode_t = libc::c_uint;
pub type __nlink_t = libc::c_ulong;
pub type __off_t = libc::c_long;
pub type __off64_t = libc::c_long;
pub type __time_t = libc::c_long;
pub type __blksize_t = libc::c_long;
pub type __blkcnt_t = libc::c_long;
pub type __syscall_slong_t = libc::c_long;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = libc::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: libc::c_int,
    pub _IO_read_ptr: *mut libc::c_char,
    pub _IO_read_end: *mut libc::c_char,
    pub _IO_read_base: *mut libc::c_char,
    pub _IO_write_base: *mut libc::c_char,
    pub _IO_write_ptr: *mut libc::c_char,
    pub _IO_write_end: *mut libc::c_char,
    pub _IO_buf_base: *mut libc::c_char,
    pub _IO_buf_end: *mut libc::c_char,
    pub _IO_save_base: *mut libc::c_char,
    pub _IO_backup_base: *mut libc::c_char,
    pub _IO_save_end: *mut libc::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: libc::c_int,
    pub _flags2: libc::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: libc::c_ushort,
    pub _vtable_offset: libc::c_schar,
    pub _shortbuf: [libc::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut libc::c_void,
    pub __pad5: usize,
    pub _mode: libc::c_int,
    pub _unused2: [libc::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._codecvt as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._wide_data as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_list as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_buf as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type wchar_t = libc::c_int;
pub type time_t = __time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: libc::c_int,
    pub tm_min: libc::c_int,
    pub tm_hour: libc::c_int,
    pub tm_mday: libc::c_int,
    pub tm_mon: libc::c_int,
    pub tm_year: libc::c_int,
    pub tm_wday: libc::c_int,
    pub tm_yday: libc::c_int,
    pub tm_isdst: libc::c_int,
    pub tm_gmtoff: libc::c_long,
    pub tm_zone: *const libc::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_gmtoff as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_zone as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
pub type GInt32 = libc::c_int;
pub type GUInt32 = libc::c_uint;
pub type GInt16 = libc::c_short;
pub type GByte = libc::c_uchar;
pub type GIntBig = libc::c_longlong;
pub type GUIntBig = libc::c_ulonglong;
pub type GInt64 = GIntBig;
pub type GUInt64 = GUIntBig;
pub type GPtrDiff_t = GIntBig;
pub type CSLConstList = *mut *mut libc::c_char;
extern "C" {
    pub fn CPLAtomicAdd(ptr: *mut libc::c_int, increment: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn CPLAtomicCompareAndExchange(
        ptr: *mut libc::c_int,
        oldval: libc::c_int,
        newval: libc::c_int,
    ) -> libc::c_int;
}
pub type GDALProgressFunc = ::std::option::Option<
    unsafe extern "C" fn(
        dfComplete: f64,
        pszMessage: *const libc::c_char,
        pProgressArg: *mut libc::c_void,
    ) -> libc::c_int,
>;
extern "C" {
    pub fn GDALDummyProgress(
        arg1: f64,
        arg2: *const libc::c_char,
        arg3: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALTermProgress(
        arg1: f64,
        arg2: *const libc::c_char,
        arg3: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALScaledProgress(
        arg1: f64,
        arg2: *const libc::c_char,
        arg3: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALCreateScaledProgress(
        arg1: f64,
        arg2: f64,
        arg3: GDALProgressFunc,
        arg4: *mut libc::c_void,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn GDALDestroyScaledProgress(arg1: *mut libc::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stat {
    pub st_dev: __dev_t,
    pub st_ino: __ino_t,
    pub st_nlink: __nlink_t,
    pub st_mode: __mode_t,
    pub st_uid: __uid_t,
    pub st_gid: __gid_t,
    pub __pad0: libc::c_int,
    pub st_rdev: __dev_t,
    pub st_size: __off_t,
    pub st_blksize: __blksize_t,
    pub st_blocks: __blkcnt_t,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    pub __glibc_reserved: [__syscall_slong_t; 3usize],
}
#[test]
fn bindgen_test_layout_stat() {
    assert_eq!(
        ::std::mem::size_of::<stat>(),
        144usize,
        concat!("Size of: ", stringify!(stat))
    );
    assert_eq!(
        ::std::mem::align_of::<stat>(),
        8usize,
        concat!("Alignment of ", stringify!(stat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_dev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_ino as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_nlink as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_nlink)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_mode as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_uid as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_gid as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).__pad0 as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(__pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_rdev as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_rdev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_size as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_blksize as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_blksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_blocks as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_atim as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_atim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_mtim as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_mtim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_ctim as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_ctim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).__glibc_reserved as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(__glibc_reserved)
        )
    );
}
extern "C" {
    pub fn VSIFOpen(arg1: *const libc::c_char, arg2: *const libc::c_char) -> *mut FILE;
}
extern "C" {
    pub fn VSIFClose(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn VSIFSeek(arg1: *mut FILE, arg2: libc::c_long, arg3: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn VSIFTell(arg1: *mut FILE) -> libc::c_long;
}
extern "C" {
    pub fn VSIRewind(arg1: *mut FILE);
}
extern "C" {
    pub fn VSIFFlush(arg1: *mut FILE);
}
extern "C" {
    pub fn VSIFRead(arg1: *mut libc::c_void, arg2: usize, arg3: usize, arg4: *mut FILE) -> usize;
}
extern "C" {
    pub fn VSIFWrite(arg1: *const libc::c_void, arg2: usize, arg3: usize, arg4: *mut FILE)
        -> usize;
}
extern "C" {
    pub fn VSIFGets(
        arg1: *mut libc::c_char,
        arg2: libc::c_int,
        arg3: *mut FILE,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn VSIFPuts(arg1: *const libc::c_char, arg2: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn VSIFPrintf(arg1: *mut FILE, arg2: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn VSIFGetc(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn VSIFPutc(arg1: libc::c_int, arg2: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn VSIUngetc(arg1: libc::c_int, arg2: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn VSIFEof(arg1: *mut FILE) -> libc::c_int;
}
pub type VSIStatBuf = stat;
extern "C" {
    pub fn VSIStat(arg1: *const libc::c_char, arg2: *mut VSIStatBuf) -> libc::c_int;
}
pub type vsi_l_offset = GUIntBig;
pub type VSILFILE = FILE;
extern "C" {
    pub fn VSIFOpenL(arg1: *const libc::c_char, arg2: *const libc::c_char) -> *mut VSILFILE;
}
extern "C" {
    pub fn VSIFOpenExL(
        arg1: *const libc::c_char,
        arg2: *const libc::c_char,
        arg3: libc::c_int,
    ) -> *mut VSILFILE;
}
extern "C" {
    pub fn VSIFCloseL(arg1: *mut VSILFILE) -> libc::c_int;
}
extern "C" {
    pub fn VSIFSeekL(arg1: *mut VSILFILE, arg2: vsi_l_offset, arg3: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn VSIFTellL(arg1: *mut VSILFILE) -> vsi_l_offset;
}
extern "C" {
    pub fn VSIRewindL(arg1: *mut VSILFILE);
}
extern "C" {
    pub fn VSIFReadL(
        arg1: *mut libc::c_void,
        arg2: usize,
        arg3: usize,
        arg4: *mut VSILFILE,
    ) -> usize;
}
extern "C" {
    pub fn VSIFReadMultiRangeL(
        nRanges: libc::c_int,
        ppData: *mut *mut libc::c_void,
        panOffsets: *const vsi_l_offset,
        panSizes: *const usize,
        arg1: *mut VSILFILE,
    ) -> libc::c_int;
}
extern "C" {
    pub fn VSIFWriteL(
        arg1: *const libc::c_void,
        arg2: usize,
        arg3: usize,
        arg4: *mut VSILFILE,
    ) -> usize;
}
extern "C" {
    pub fn VSIFEofL(arg1: *mut VSILFILE) -> libc::c_int;
}
extern "C" {
    pub fn VSIFTruncateL(arg1: *mut VSILFILE, arg2: vsi_l_offset) -> libc::c_int;
}
extern "C" {
    pub fn VSIFFlushL(arg1: *mut VSILFILE) -> libc::c_int;
}
extern "C" {
    pub fn VSIFPrintfL(arg1: *mut VSILFILE, arg2: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn VSIFPutcL(arg1: libc::c_int, arg2: *mut VSILFILE) -> libc::c_int;
}
pub mod VSIRangeStatus {
    pub type Type = libc::c_uint;
    pub const VSI_RANGE_STATUS_UNKNOWN: Type = 0;
    pub const VSI_RANGE_STATUS_DATA: Type = 1;
    pub const VSI_RANGE_STATUS_HOLE: Type = 2;
}
extern "C" {
    pub fn VSIFGetRangeStatusL(
        fp: *mut VSILFILE,
        nStart: vsi_l_offset,
        nLength: vsi_l_offset,
    ) -> VSIRangeStatus::Type;
}
extern "C" {
    pub fn VSIIngestFile(
        fp: *mut VSILFILE,
        pszFilename: *const libc::c_char,
        ppabyRet: *mut *mut GByte,
        pnSize: *mut vsi_l_offset,
        nMaxSize: GIntBig,
    ) -> libc::c_int;
}
extern "C" {
    pub fn VSIOverwriteFile(
        fpTarget: *mut VSILFILE,
        pszSourceFilename: *const libc::c_char,
    ) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stat64 {
    _unused: [u8; 0],
}
pub type VSIStatBufL = stat64;
extern "C" {
    pub fn VSIStatL(arg1: *const libc::c_char, arg2: *mut VSIStatBufL) -> libc::c_int;
}
extern "C" {
    pub fn VSIStatExL(
        pszFilename: *const libc::c_char,
        psStatBuf: *mut VSIStatBufL,
        nFlags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn VSIIsCaseSensitiveFS(pszFilename: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn VSISupportsSparseFiles(pszPath: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn VSIHasOptimizedReadMultiRange(pszPath: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn VSIGetActualURL(pszFilename: *const libc::c_char) -> *const libc::c_char;
}
extern "C" {
    pub fn VSIGetSignedURL(
        pszFilename: *const libc::c_char,
        papszOptions: CSLConstList,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn VSIGetFileSystemOptions(pszFilename: *const libc::c_char) -> *const libc::c_char;
}
extern "C" {
    pub fn VSIGetFileSystemsPrefixes() -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn VSIFGetNativeFileDescriptorL(arg1: *mut VSILFILE) -> *mut libc::c_void;
}
extern "C" {
    pub fn VSIGetFileMetadata(
        pszFilename: *const libc::c_char,
        pszDomain: *const libc::c_char,
        papszOptions: CSLConstList,
    ) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn VSISetFileMetadata(
        pszFilename: *const libc::c_char,
        papszMetadata: CSLConstList,
        pszDomain: *const libc::c_char,
        papszOptions: CSLConstList,
    ) -> libc::c_int;
}
extern "C" {
    pub fn VSICalloc(arg1: usize, arg2: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn VSIMalloc(arg1: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn VSIFree(arg1: *mut libc::c_void);
}
extern "C" {
    pub fn VSIRealloc(arg1: *mut libc::c_void, arg2: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn VSIStrdup(arg1: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn VSIMallocAligned(nAlignment: usize, nSize: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn VSIMallocAlignedAuto(nSize: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn VSIFreeAligned(ptr: *mut libc::c_void);
}
extern "C" {
    pub fn VSIMallocAlignedAutoVerbose(
        nSize: usize,
        pszFile: *const libc::c_char,
        nLine: libc::c_int,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn VSIMalloc2(nSize1: usize, nSize2: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn VSIMalloc3(nSize1: usize, nSize2: usize, nSize3: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn VSIMallocVerbose(
        nSize: usize,
        pszFile: *const libc::c_char,
        nLine: libc::c_int,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn VSIMalloc2Verbose(
        nSize1: usize,
        nSize2: usize,
        pszFile: *const libc::c_char,
        nLine: libc::c_int,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn VSIMalloc3Verbose(
        nSize1: usize,
        nSize2: usize,
        nSize3: usize,
        pszFile: *const libc::c_char,
        nLine: libc::c_int,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn VSICallocVerbose(
        nCount: usize,
        nSize: usize,
        pszFile: *const libc::c_char,
        nLine: libc::c_int,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn VSIReallocVerbose(
        pOldPtr: *mut libc::c_void,
        nNewSize: usize,
        pszFile: *const libc::c_char,
        nLine: libc::c_int,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn VSIStrdupVerbose(
        pszStr: *const libc::c_char,
        pszFile: *const libc::c_char,
        nLine: libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn CPLGetPhysicalRAM() -> GIntBig;
}
extern "C" {
    pub fn CPLGetUsablePhysicalRAM() -> GIntBig;
}
extern "C" {
    pub fn VSIReadDir(arg1: *const libc::c_char) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn VSIReadDirRecursive(pszPath: *const libc::c_char) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn VSIReadDirEx(
        pszPath: *const libc::c_char,
        nMaxFiles: libc::c_int,
    ) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn VSISiblingFiles(pszPath: *const libc::c_char) -> *mut *mut libc::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VSIDIR {
    _unused: [u8; 0],
}
extern "C" {
    pub fn VSIOpenDir(
        pszPath: *const libc::c_char,
        nRecurseDepth: libc::c_int,
        papszOptions: *const *const libc::c_char,
    ) -> *mut VSIDIR;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VSIDIREntry {
    pub pszName: *mut libc::c_char,
    pub nMode: libc::c_int,
    pub nSize: vsi_l_offset,
    pub nMTime: GIntBig,
    pub bModeKnown: libc::c_char,
    pub bSizeKnown: libc::c_char,
    pub bMTimeKnown: libc::c_char,
    pub papszExtra: *mut *mut libc::c_char,
}
#[test]
fn bindgen_test_layout_VSIDIREntry() {
    assert_eq!(
        ::std::mem::size_of::<VSIDIREntry>(),
        48usize,
        concat!("Size of: ", stringify!(VSIDIREntry))
    );
    assert_eq!(
        ::std::mem::align_of::<VSIDIREntry>(),
        8usize,
        concat!("Alignment of ", stringify!(VSIDIREntry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VSIDIREntry>())).pszName as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIDIREntry),
            "::",
            stringify!(pszName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VSIDIREntry>())).nMode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIDIREntry),
            "::",
            stringify!(nMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VSIDIREntry>())).nSize as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIDIREntry),
            "::",
            stringify!(nSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VSIDIREntry>())).nMTime as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIDIREntry),
            "::",
            stringify!(nMTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VSIDIREntry>())).bModeKnown as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIDIREntry),
            "::",
            stringify!(bModeKnown)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VSIDIREntry>())).bSizeKnown as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIDIREntry),
            "::",
            stringify!(bSizeKnown)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VSIDIREntry>())).bMTimeKnown as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIDIREntry),
            "::",
            stringify!(bMTimeKnown)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VSIDIREntry>())).papszExtra as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIDIREntry),
            "::",
            stringify!(papszExtra)
        )
    );
}
extern "C" {
    pub fn VSIGetNextDirEntry(dir: *mut VSIDIR) -> *const VSIDIREntry;
}
extern "C" {
    pub fn VSICloseDir(dir: *mut VSIDIR);
}
extern "C" {
    pub fn VSIMkdir(pszPathname: *const libc::c_char, mode: libc::c_long) -> libc::c_int;
}
extern "C" {
    pub fn VSIMkdirRecursive(pszPathname: *const libc::c_char, mode: libc::c_long) -> libc::c_int;
}
extern "C" {
    pub fn VSIRmdir(pszDirname: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn VSIRmdirRecursive(pszDirname: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn VSIUnlink(pszFilename: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn VSIUnlinkBatch(papszFiles: CSLConstList) -> *mut libc::c_int;
}
extern "C" {
    pub fn VSIRename(oldpath: *const libc::c_char, newpath: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn VSISync(
        pszSource: *const libc::c_char,
        pszTarget: *const libc::c_char,
        papszOptions: *const *const libc::c_char,
        pProgressFunc: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
        ppapszOutputs: *mut *mut *mut libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn VSIStrerror(arg1: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn VSIGetDiskFreeSpace(pszDirname: *const libc::c_char) -> GIntBig;
}
extern "C" {
    pub fn VSINetworkStatsReset();
}
extern "C" {
    pub fn VSINetworkStatsGetAsSerializedJSON(
        papszOptions: *mut *mut libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn VSIInstallMemFileHandler();
}
extern "C" {
    pub fn VSIInstallLargeFileHandler();
}
extern "C" {
    pub fn VSIInstallSubFileHandler();
}
extern "C" {
    pub fn VSIInstallCurlFileHandler();
}
extern "C" {
    pub fn VSICurlClearCache();
}
extern "C" {
    pub fn VSICurlPartialClearCache(pszFilenamePrefix: *const libc::c_char);
}
extern "C" {
    pub fn VSIInstallCurlStreamingFileHandler();
}
extern "C" {
    pub fn VSIInstallS3FileHandler();
}
extern "C" {
    pub fn VSIInstallS3StreamingFileHandler();
}
extern "C" {
    pub fn VSIInstallGSFileHandler();
}
extern "C" {
    pub fn VSIInstallGSStreamingFileHandler();
}
extern "C" {
    pub fn VSIInstallAzureFileHandler();
}
extern "C" {
    pub fn VSIInstallAzureStreamingFileHandler();
}
extern "C" {
    pub fn VSIInstallOSSFileHandler();
}
extern "C" {
    pub fn VSIInstallOSSStreamingFileHandler();
}
extern "C" {
    pub fn VSIInstallSwiftFileHandler();
}
extern "C" {
    pub fn VSIInstallSwiftStreamingFileHandler();
}
extern "C" {
    pub fn VSIInstallGZipFileHandler();
}
extern "C" {
    pub fn VSIInstallZipFileHandler();
}
extern "C" {
    pub fn VSIInstallStdinHandler();
}
extern "C" {
    pub fn VSIInstallHdfsHandler();
}
extern "C" {
    pub fn VSIInstallWebHdfsHandler();
}
extern "C" {
    pub fn VSIInstallStdoutHandler();
}
extern "C" {
    pub fn VSIInstallSparseFileHandler();
}
extern "C" {
    pub fn VSIInstallTarFileHandler();
}
extern "C" {
    pub fn VSIInstallCryptFileHandler();
}
extern "C" {
    pub fn VSISetCryptKey(pabyKey: *const GByte, nKeySize: libc::c_int);
}
extern "C" {
    pub fn VSICleanupFileManager();
}
extern "C" {
    pub fn VSIFileFromMemBuffer(
        pszFilename: *const libc::c_char,
        pabyData: *mut GByte,
        nDataLength: vsi_l_offset,
        bTakeOwnership: libc::c_int,
    ) -> *mut VSILFILE;
}
extern "C" {
    pub fn VSIGetMemFileBuffer(
        pszFilename: *const libc::c_char,
        pnDataLength: *mut vsi_l_offset,
        bUnlinkAndSeize: libc::c_int,
    ) -> *mut GByte;
}
pub type VSIWriteFunction = ::std::option::Option<
    unsafe extern "C" fn(
        ptr: *const libc::c_void,
        size: usize,
        nmemb: usize,
        stream: *mut FILE,
    ) -> usize,
>;
extern "C" {
    pub fn VSIStdoutSetRedirection(pFct: VSIWriteFunction, stream: *mut FILE);
}
pub type VSIFilesystemPluginStatCallback = ::std::option::Option<
    unsafe extern "C" fn(
        pUserData: *mut libc::c_void,
        pszFilename: *const libc::c_char,
        pStatBuf: *mut VSIStatBufL,
        nFlags: libc::c_int,
    ) -> libc::c_int,
>;
pub type VSIFilesystemPluginUnlinkCallback = ::std::option::Option<
    unsafe extern "C" fn(
        pUserData: *mut libc::c_void,
        pszFilename: *const libc::c_char,
    ) -> libc::c_int,
>;
pub type VSIFilesystemPluginRenameCallback = ::std::option::Option<
    unsafe extern "C" fn(
        pUserData: *mut libc::c_void,
        oldpath: *const libc::c_char,
        newpath: *const libc::c_char,
    ) -> libc::c_int,
>;
pub type VSIFilesystemPluginMkdirCallback = ::std::option::Option<
    unsafe extern "C" fn(
        pUserData: *mut libc::c_void,
        pszDirname: *const libc::c_char,
        nMode: libc::c_long,
    ) -> libc::c_int,
>;
pub type VSIFilesystemPluginRmdirCallback = ::std::option::Option<
    unsafe extern "C" fn(
        pUserData: *mut libc::c_void,
        pszDirname: *const libc::c_char,
    ) -> libc::c_int,
>;
pub type VSIFilesystemPluginReadDirCallback = ::std::option::Option<
    unsafe extern "C" fn(
        pUserData: *mut libc::c_void,
        pszDirname: *const libc::c_char,
        nMaxFiles: libc::c_int,
    ) -> *mut *mut libc::c_char,
>;
pub type VSIFilesystemPluginSiblingFilesCallback = ::std::option::Option<
    unsafe extern "C" fn(
        pUserData: *mut libc::c_void,
        pszDirname: *const libc::c_char,
    ) -> *mut *mut libc::c_char,
>;
pub type VSIFilesystemPluginOpenCallback = ::std::option::Option<
    unsafe extern "C" fn(
        pUserData: *mut libc::c_void,
        pszFilename: *const libc::c_char,
        pszAccess: *const libc::c_char,
    ) -> *mut libc::c_void,
>;
pub type VSIFilesystemPluginTellCallback =
    ::std::option::Option<unsafe extern "C" fn(pFile: *mut libc::c_void) -> vsi_l_offset>;
pub type VSIFilesystemPluginSeekCallback = ::std::option::Option<
    unsafe extern "C" fn(
        pFile: *mut libc::c_void,
        nOffset: vsi_l_offset,
        nWhence: libc::c_int,
    ) -> libc::c_int,
>;
pub type VSIFilesystemPluginReadCallback = ::std::option::Option<
    unsafe extern "C" fn(
        pFile: *mut libc::c_void,
        pBuffer: *mut libc::c_void,
        nSize: usize,
        nCount: usize,
    ) -> usize,
>;
pub type VSIFilesystemPluginReadMultiRangeCallback = ::std::option::Option<
    unsafe extern "C" fn(
        pFile: *mut libc::c_void,
        nRanges: libc::c_int,
        ppData: *mut *mut libc::c_void,
        panOffsets: *const vsi_l_offset,
        panSizes: *const usize,
    ) -> libc::c_int,
>;
pub type VSIFilesystemPluginGetRangeStatusCallback = ::std::option::Option<
    unsafe extern "C" fn(
        pFile: *mut libc::c_void,
        nOffset: vsi_l_offset,
        nLength: vsi_l_offset,
    ) -> VSIRangeStatus::Type,
>;
pub type VSIFilesystemPluginEofCallback =
    ::std::option::Option<unsafe extern "C" fn(pFile: *mut libc::c_void) -> libc::c_int>;
pub type VSIFilesystemPluginWriteCallback = ::std::option::Option<
    unsafe extern "C" fn(
        pFile: *mut libc::c_void,
        pBuffer: *const libc::c_void,
        nSize: usize,
        nCount: usize,
    ) -> usize,
>;
pub type VSIFilesystemPluginFlushCallback =
    ::std::option::Option<unsafe extern "C" fn(pFile: *mut libc::c_void) -> libc::c_int>;
pub type VSIFilesystemPluginTruncateCallback = ::std::option::Option<
    unsafe extern "C" fn(pFile: *mut libc::c_void, nNewSize: vsi_l_offset) -> libc::c_int,
>;
pub type VSIFilesystemPluginCloseCallback =
    ::std::option::Option<unsafe extern "C" fn(pFile: *mut libc::c_void) -> libc::c_int>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VSIFilesystemPluginCallbacksStruct {
    pub pUserData: *mut libc::c_void,
    pub stat: VSIFilesystemPluginStatCallback,
    pub unlink: VSIFilesystemPluginUnlinkCallback,
    pub rename: VSIFilesystemPluginRenameCallback,
    pub mkdir: VSIFilesystemPluginMkdirCallback,
    pub rmdir: VSIFilesystemPluginRmdirCallback,
    pub read_dir: VSIFilesystemPluginReadDirCallback,
    pub open: VSIFilesystemPluginOpenCallback,
    pub tell: VSIFilesystemPluginTellCallback,
    pub seek: VSIFilesystemPluginSeekCallback,
    pub read: VSIFilesystemPluginReadCallback,
    pub read_multi_range: VSIFilesystemPluginReadMultiRangeCallback,
    pub get_range_status: VSIFilesystemPluginGetRangeStatusCallback,
    pub eof: VSIFilesystemPluginEofCallback,
    pub write: VSIFilesystemPluginWriteCallback,
    pub flush: VSIFilesystemPluginFlushCallback,
    pub truncate: VSIFilesystemPluginTruncateCallback,
    pub close: VSIFilesystemPluginCloseCallback,
    pub nBufferSize: usize,
    pub nCacheSize: usize,
    pub sibling_files: VSIFilesystemPluginSiblingFilesCallback,
}
#[test]
fn bindgen_test_layout_VSIFilesystemPluginCallbacksStruct() {
    assert_eq!(
        ::std::mem::size_of::<VSIFilesystemPluginCallbacksStruct>(),
        168usize,
        concat!("Size of: ", stringify!(VSIFilesystemPluginCallbacksStruct))
    );
    assert_eq!(
        ::std::mem::align_of::<VSIFilesystemPluginCallbacksStruct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VSIFilesystemPluginCallbacksStruct)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VSIFilesystemPluginCallbacksStruct>())).pUserData as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIFilesystemPluginCallbacksStruct),
            "::",
            stringify!(pUserData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VSIFilesystemPluginCallbacksStruct>())).stat as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIFilesystemPluginCallbacksStruct),
            "::",
            stringify!(stat)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VSIFilesystemPluginCallbacksStruct>())).unlink as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIFilesystemPluginCallbacksStruct),
            "::",
            stringify!(unlink)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VSIFilesystemPluginCallbacksStruct>())).rename as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIFilesystemPluginCallbacksStruct),
            "::",
            stringify!(rename)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VSIFilesystemPluginCallbacksStruct>())).mkdir as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIFilesystemPluginCallbacksStruct),
            "::",
            stringify!(mkdir)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VSIFilesystemPluginCallbacksStruct>())).rmdir as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIFilesystemPluginCallbacksStruct),
            "::",
            stringify!(rmdir)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VSIFilesystemPluginCallbacksStruct>())).read_dir as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIFilesystemPluginCallbacksStruct),
            "::",
            stringify!(read_dir)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VSIFilesystemPluginCallbacksStruct>())).open as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIFilesystemPluginCallbacksStruct),
            "::",
            stringify!(open)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VSIFilesystemPluginCallbacksStruct>())).tell as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIFilesystemPluginCallbacksStruct),
            "::",
            stringify!(tell)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VSIFilesystemPluginCallbacksStruct>())).seek as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIFilesystemPluginCallbacksStruct),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VSIFilesystemPluginCallbacksStruct>())).read as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIFilesystemPluginCallbacksStruct),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VSIFilesystemPluginCallbacksStruct>())).read_multi_range
                as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIFilesystemPluginCallbacksStruct),
            "::",
            stringify!(read_multi_range)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VSIFilesystemPluginCallbacksStruct>())).get_range_status
                as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIFilesystemPluginCallbacksStruct),
            "::",
            stringify!(get_range_status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VSIFilesystemPluginCallbacksStruct>())).eof as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIFilesystemPluginCallbacksStruct),
            "::",
            stringify!(eof)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VSIFilesystemPluginCallbacksStruct>())).write as *const _
                as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIFilesystemPluginCallbacksStruct),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VSIFilesystemPluginCallbacksStruct>())).flush as *const _
                as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIFilesystemPluginCallbacksStruct),
            "::",
            stringify!(flush)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VSIFilesystemPluginCallbacksStruct>())).truncate as *const _
                as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIFilesystemPluginCallbacksStruct),
            "::",
            stringify!(truncate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VSIFilesystemPluginCallbacksStruct>())).close as *const _
                as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIFilesystemPluginCallbacksStruct),
            "::",
            stringify!(close)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VSIFilesystemPluginCallbacksStruct>())).nBufferSize as *const _
                as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIFilesystemPluginCallbacksStruct),
            "::",
            stringify!(nBufferSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VSIFilesystemPluginCallbacksStruct>())).nCacheSize as *const _
                as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIFilesystemPluginCallbacksStruct),
            "::",
            stringify!(nCacheSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VSIFilesystemPluginCallbacksStruct>())).sibling_files as *const _
                as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIFilesystemPluginCallbacksStruct),
            "::",
            stringify!(sibling_files)
        )
    );
}
extern "C" {
    pub fn VSIAllocFilesystemPluginCallbacksStruct() -> *mut VSIFilesystemPluginCallbacksStruct;
}
extern "C" {
    pub fn VSIFreeFilesystemPluginCallbacksStruct(poCb: *mut VSIFilesystemPluginCallbacksStruct);
}
extern "C" {
    pub fn VSIInstallPluginHandler(
        pszPrefix: *const libc::c_char,
        poCb: *const VSIFilesystemPluginCallbacksStruct,
    ) -> libc::c_int;
}
extern "C" {
    pub fn VSITime(arg1: *mut libc::c_ulong) -> libc::c_ulong;
}
extern "C" {
    pub fn VSICTime(arg1: libc::c_ulong) -> *const libc::c_char;
}
extern "C" {
    pub fn VSIGMTime(pnTime: *const time_t, poBrokenTime: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn VSILocalTime(pnTime: *const time_t, poBrokenTime: *mut tm) -> *mut tm;
}
pub mod CPLErr {
    pub type Type = libc::c_uint;
    pub const CE_None: Type = 0;
    pub const CE_Debug: Type = 1;
    pub const CE_Warning: Type = 2;
    pub const CE_Failure: Type = 3;
    pub const CE_Fatal: Type = 4;
}
pub type CPLErrorNum = libc::c_int;
extern "C" {
    pub fn CPLError(eErrClass: CPLErr::Type, err_no: CPLErrorNum, fmt: *const libc::c_char, ...);
}
extern "C" {
    pub fn CPLErrorV(
        arg1: CPLErr::Type,
        arg2: CPLErrorNum,
        arg3: *const libc::c_char,
        arg4: *mut __va_list_tag,
    );
}
extern "C" {
    pub fn CPLEmergencyError(arg1: *const libc::c_char);
}
extern "C" {
    pub fn CPLErrorReset();
}
extern "C" {
    pub fn CPLGetLastErrorNo() -> CPLErrorNum;
}
extern "C" {
    pub fn CPLGetLastErrorType() -> CPLErr::Type;
}
extern "C" {
    pub fn CPLGetLastErrorMsg() -> *const libc::c_char;
}
extern "C" {
    pub fn CPLGetErrorCounter() -> GUInt32;
}
extern "C" {
    pub fn CPLGetErrorHandlerUserData() -> *mut libc::c_void;
}
extern "C" {
    pub fn CPLErrorSetState(
        eErrClass: CPLErr::Type,
        err_no: CPLErrorNum,
        pszMsg: *const libc::c_char,
    );
}
extern "C" {
    pub fn CPLCleanupErrorMutex();
}
pub type CPLErrorHandler = ::std::option::Option<
    unsafe extern "C" fn(arg1: CPLErr::Type, arg2: CPLErrorNum, arg3: *const libc::c_char),
>;
extern "C" {
    pub fn CPLLoggingErrorHandler(arg1: CPLErr::Type, arg2: CPLErrorNum, arg3: *const libc::c_char);
}
extern "C" {
    pub fn CPLDefaultErrorHandler(arg1: CPLErr::Type, arg2: CPLErrorNum, arg3: *const libc::c_char);
}
extern "C" {
    pub fn CPLQuietErrorHandler(arg1: CPLErr::Type, arg2: CPLErrorNum, arg3: *const libc::c_char);
}
extern "C" {
    pub fn CPLTurnFailureIntoWarning(bOn: libc::c_int);
}
extern "C" {
    pub fn CPLSetErrorHandler(arg1: CPLErrorHandler) -> CPLErrorHandler;
}
extern "C" {
    pub fn CPLSetErrorHandlerEx(arg1: CPLErrorHandler, arg2: *mut libc::c_void) -> CPLErrorHandler;
}
extern "C" {
    pub fn CPLPushErrorHandler(arg1: CPLErrorHandler);
}
extern "C" {
    pub fn CPLPushErrorHandlerEx(arg1: CPLErrorHandler, arg2: *mut libc::c_void);
}
extern "C" {
    pub fn CPLSetCurrentErrorHandlerCatchDebug(bCatchDebug: libc::c_int);
}
extern "C" {
    pub fn CPLPopErrorHandler();
}
extern "C" {
    pub fn CPLDebug(arg1: *const libc::c_char, arg2: *const libc::c_char, ...);
}
extern "C" {
    pub fn CPLVerifyConfiguration();
}
extern "C" {
    pub fn CPLGetConfigOption(
        arg1: *const libc::c_char,
        arg2: *const libc::c_char,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLGetThreadLocalConfigOption(
        arg1: *const libc::c_char,
        arg2: *const libc::c_char,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLSetConfigOption(arg1: *const libc::c_char, arg2: *const libc::c_char);
}
extern "C" {
    pub fn CPLSetThreadLocalConfigOption(
        pszKey: *const libc::c_char,
        pszValue: *const libc::c_char,
    );
}
extern "C" {
    pub fn CPLFreeConfig();
}
extern "C" {
    pub fn CPLGetConfigOptions() -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn CPLSetConfigOptions(papszConfigOptions: *const *const libc::c_char);
}
extern "C" {
    pub fn CPLGetThreadLocalConfigOptions() -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn CPLSetThreadLocalConfigOptions(papszConfigOptions: *const *const libc::c_char);
}
extern "C" {
    pub fn CPLMalloc(arg1: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn CPLCalloc(arg1: usize, arg2: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn CPLRealloc(arg1: *mut libc::c_void, arg2: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn CPLStrdup(arg1: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn CPLStrlwr(arg1: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn CPLFGets(
        arg1: *mut libc::c_char,
        arg2: libc::c_int,
        arg3: *mut FILE,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn CPLReadLine(arg1: *mut FILE) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLReadLineL(arg1: *mut VSILFILE) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLReadLine2L(
        arg1: *mut VSILFILE,
        arg2: libc::c_int,
        arg3: CSLConstList,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLReadLine3L(
        arg1: *mut VSILFILE,
        arg2: libc::c_int,
        arg3: *mut libc::c_int,
        arg4: CSLConstList,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLAtof(arg1: *const libc::c_char) -> f64;
}
extern "C" {
    pub fn CPLAtofDelim(arg1: *const libc::c_char, arg2: libc::c_char) -> f64;
}
extern "C" {
    pub fn CPLStrtod(arg1: *const libc::c_char, arg2: *mut *mut libc::c_char) -> f64;
}
extern "C" {
    pub fn CPLStrtodDelim(
        arg1: *const libc::c_char,
        arg2: *mut *mut libc::c_char,
        arg3: libc::c_char,
    ) -> f64;
}
extern "C" {
    pub fn CPLStrtof(arg1: *const libc::c_char, arg2: *mut *mut libc::c_char) -> f32;
}
extern "C" {
    pub fn CPLStrtofDelim(
        arg1: *const libc::c_char,
        arg2: *mut *mut libc::c_char,
        arg3: libc::c_char,
    ) -> f32;
}
extern "C" {
    pub fn CPLAtofM(arg1: *const libc::c_char) -> f64;
}
extern "C" {
    pub fn CPLScanString(
        arg1: *const libc::c_char,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn CPLScanDouble(arg1: *const libc::c_char, arg2: libc::c_int) -> f64;
}
extern "C" {
    pub fn CPLScanLong(arg1: *const libc::c_char, arg2: libc::c_int) -> libc::c_long;
}
extern "C" {
    pub fn CPLScanULong(arg1: *const libc::c_char, arg2: libc::c_int) -> libc::c_ulong;
}
extern "C" {
    pub fn CPLScanUIntBig(arg1: *const libc::c_char, arg2: libc::c_int) -> GUIntBig;
}
extern "C" {
    pub fn CPLAtoGIntBig(pszString: *const libc::c_char) -> GIntBig;
}
extern "C" {
    pub fn CPLAtoGIntBigEx(
        pszString: *const libc::c_char,
        bWarn: libc::c_int,
        pbOverflow: *mut libc::c_int,
    ) -> GIntBig;
}
extern "C" {
    pub fn CPLScanPointer(arg1: *const libc::c_char, arg2: libc::c_int) -> *mut libc::c_void;
}
extern "C" {
    pub fn CPLPrintString(
        arg1: *mut libc::c_char,
        arg2: *const libc::c_char,
        arg3: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CPLPrintStringFill(
        arg1: *mut libc::c_char,
        arg2: *const libc::c_char,
        arg3: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CPLPrintInt32(arg1: *mut libc::c_char, arg2: GInt32, arg3: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn CPLPrintUIntBig(
        arg1: *mut libc::c_char,
        arg2: GUIntBig,
        arg3: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CPLPrintDouble(
        arg1: *mut libc::c_char,
        arg2: *const libc::c_char,
        arg3: f64,
        arg4: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CPLPrintTime(
        arg1: *mut libc::c_char,
        arg2: libc::c_int,
        arg3: *const libc::c_char,
        arg4: *const tm,
        arg5: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CPLPrintPointer(
        arg1: *mut libc::c_char,
        arg2: *mut libc::c_void,
        arg3: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CPLGetSymbol(arg1: *const libc::c_char, arg2: *const libc::c_char) -> *mut libc::c_void;
}
extern "C" {
    pub fn CPLGetExecPath(pszPathBuf: *mut libc::c_char, nMaxLength: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn CPLGetPath(arg1: *const libc::c_char) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLGetDirname(arg1: *const libc::c_char) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLGetFilename(arg1: *const libc::c_char) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLGetBasename(arg1: *const libc::c_char) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLGetExtension(arg1: *const libc::c_char) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLGetCurrentDir() -> *mut libc::c_char;
}
extern "C" {
    pub fn CPLFormFilename(
        pszPath: *const libc::c_char,
        pszBasename: *const libc::c_char,
        pszExtension: *const libc::c_char,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLFormCIFilename(
        pszPath: *const libc::c_char,
        pszBasename: *const libc::c_char,
        pszExtension: *const libc::c_char,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLResetExtension(
        arg1: *const libc::c_char,
        arg2: *const libc::c_char,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLProjectRelativeFilename(
        pszProjectDir: *const libc::c_char,
        pszSecondaryFilename: *const libc::c_char,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLIsFilenameRelative(pszFilename: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn CPLExtractRelativePath(
        arg1: *const libc::c_char,
        arg2: *const libc::c_char,
        arg3: *mut libc::c_int,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLCleanTrailingSlash(arg1: *const libc::c_char) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLCorrespondingPaths(
        pszOldFilename: *const libc::c_char,
        pszNewFilename: *const libc::c_char,
        papszFileList: *mut *mut libc::c_char,
    ) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn CPLCheckForFile(
        pszFilename: *mut libc::c_char,
        papszSiblingList: *mut *mut libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CPLGenerateTempFilename(pszStem: *const libc::c_char) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLExpandTilde(pszFilename: *const libc::c_char) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLGetHomeDir() -> *const libc::c_char;
}
extern "C" {
    pub fn CPLLaunderForFilename(
        pszName: *const libc::c_char,
        pszOutputPath: *const libc::c_char,
    ) -> *const libc::c_char;
}
pub type CPLFileFinder = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const libc::c_char,
        arg2: *const libc::c_char,
    ) -> *const libc::c_char,
>;
extern "C" {
    pub fn CPLFindFile(
        pszClass: *const libc::c_char,
        pszBasename: *const libc::c_char,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLDefaultFindFile(
        pszClass: *const libc::c_char,
        pszBasename: *const libc::c_char,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLPushFileFinder(pfnFinder: CPLFileFinder);
}
extern "C" {
    pub fn CPLPopFileFinder() -> CPLFileFinder;
}
extern "C" {
    pub fn CPLPushFinderLocation(arg1: *const libc::c_char);
}
extern "C" {
    pub fn CPLPopFinderLocation();
}
extern "C" {
    pub fn CPLFinderClean();
}
extern "C" {
    pub fn CPLStat(arg1: *const libc::c_char, arg2: *mut VSIStatBuf) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CPLSharedFileInfo {
    pub fp: *mut FILE,
    pub nRefCount: libc::c_int,
    pub bLarge: libc::c_int,
    pub pszFilename: *mut libc::c_char,
    pub pszAccess: *mut libc::c_char,
}
#[test]
fn bindgen_test_layout_CPLSharedFileInfo() {
    assert_eq!(
        ::std::mem::size_of::<CPLSharedFileInfo>(),
        32usize,
        concat!("Size of: ", stringify!(CPLSharedFileInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CPLSharedFileInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CPLSharedFileInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CPLSharedFileInfo>())).fp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CPLSharedFileInfo),
            "::",
            stringify!(fp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CPLSharedFileInfo>())).nRefCount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CPLSharedFileInfo),
            "::",
            stringify!(nRefCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CPLSharedFileInfo>())).bLarge as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CPLSharedFileInfo),
            "::",
            stringify!(bLarge)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CPLSharedFileInfo>())).pszFilename as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CPLSharedFileInfo),
            "::",
            stringify!(pszFilename)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CPLSharedFileInfo>())).pszAccess as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CPLSharedFileInfo),
            "::",
            stringify!(pszAccess)
        )
    );
}
extern "C" {
    pub fn CPLOpenShared(
        arg1: *const libc::c_char,
        arg2: *const libc::c_char,
        arg3: libc::c_int,
    ) -> *mut FILE;
}
extern "C" {
    pub fn CPLCloseShared(arg1: *mut FILE);
}
extern "C" {
    pub fn CPLGetSharedList(arg1: *mut libc::c_int) -> *mut CPLSharedFileInfo;
}
extern "C" {
    pub fn CPLDumpSharedList(arg1: *mut FILE);
}
extern "C" {
    pub fn CPLCleanupSharedFileMutex();
}
extern "C" {
    pub fn CPLDMSToDec(is: *const libc::c_char) -> f64;
}
extern "C" {
    pub fn CPLDecToDMS(
        dfAngle: f64,
        pszAxis: *const libc::c_char,
        nPrecision: libc::c_int,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLPackedDMSToDec(arg1: f64) -> f64;
}
extern "C" {
    pub fn CPLDecToPackedDMS(dfDec: f64) -> f64;
}
extern "C" {
    pub fn CPLStringToComplex(pszString: *const libc::c_char, pdfReal: *mut f64, pdfImag: *mut f64);
}
extern "C" {
    pub fn CPLUnlinkTree(arg1: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn CPLCopyFile(
        pszNewPath: *const libc::c_char,
        pszOldPath: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CPLCopyTree(
        pszNewPath: *const libc::c_char,
        pszOldPath: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CPLMoveFile(
        pszNewPath: *const libc::c_char,
        pszOldPath: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CPLSymlink(
        pszOldPath: *const libc::c_char,
        pszNewPath: *const libc::c_char,
        papszOptions: CSLConstList,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CPLCreateZip(
        pszZipFilename: *const libc::c_char,
        papszOptions: *mut *mut libc::c_char,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn CPLCreateFileInZip(
        hZip: *mut libc::c_void,
        pszFilename: *const libc::c_char,
        papszOptions: *mut *mut libc::c_char,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn CPLWriteFileInZip(
        hZip: *mut libc::c_void,
        pBuffer: *const libc::c_void,
        nBufferSize: libc::c_int,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn CPLCloseFileInZip(hZip: *mut libc::c_void) -> CPLErr::Type;
}
extern "C" {
    pub fn CPLCloseZip(hZip: *mut libc::c_void) -> CPLErr::Type;
}
extern "C" {
    pub fn CPLZLibDeflate(
        ptr: *const libc::c_void,
        nBytes: usize,
        nLevel: libc::c_int,
        outptr: *mut libc::c_void,
        nOutAvailableBytes: usize,
        pnOutBytes: *mut usize,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn CPLZLibInflate(
        ptr: *const libc::c_void,
        nBytes: usize,
        outptr: *mut libc::c_void,
        nOutAvailableBytes: usize,
        pnOutBytes: *mut usize,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn CPLValidateXML(
        pszXMLFilename: *const libc::c_char,
        pszXSDFilename: *const libc::c_char,
        papszOptions: CSLConstList,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CPLsetlocale(category: libc::c_int, locale: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn CPLCleanupSetlocaleMutex();
}
extern "C" {
    pub fn CPLIsPowerOfTwo(i: libc::c_uint) -> libc::c_int;
}
extern "C" {
    pub fn CSLAddString(
        papszStrList: *mut *mut libc::c_char,
        pszNewString: *const libc::c_char,
    ) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn CSLAddStringMayFail(
        papszStrList: *mut *mut libc::c_char,
        pszNewString: *const libc::c_char,
    ) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn CSLCount(papszStrList: CSLConstList) -> libc::c_int;
}
extern "C" {
    pub fn CSLGetField(arg1: CSLConstList, arg2: libc::c_int) -> *const libc::c_char;
}
extern "C" {
    pub fn CSLDestroy(papszStrList: *mut *mut libc::c_char);
}
extern "C" {
    pub fn CSLDuplicate(papszStrList: CSLConstList) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn CSLMerge(
        papszOrig: *mut *mut libc::c_char,
        papszOverride: CSLConstList,
    ) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn CSLTokenizeString(pszString: *const libc::c_char) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn CSLTokenizeStringComplex(
        pszString: *const libc::c_char,
        pszDelimiter: *const libc::c_char,
        bHonourStrings: libc::c_int,
        bAllowEmptyTokens: libc::c_int,
    ) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn CSLTokenizeString2(
        pszString: *const libc::c_char,
        pszDelimiter: *const libc::c_char,
        nCSLTFlags: libc::c_int,
    ) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn CSLPrint(papszStrList: CSLConstList, fpOut: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn CSLLoad(pszFname: *const libc::c_char) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn CSLLoad2(
        pszFname: *const libc::c_char,
        nMaxLines: libc::c_int,
        nMaxCols: libc::c_int,
        papszOptions: CSLConstList,
    ) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn CSLSave(papszStrList: CSLConstList, pszFname: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn CSLInsertStrings(
        papszStrList: *mut *mut libc::c_char,
        nInsertAtLineNo: libc::c_int,
        papszNewLines: CSLConstList,
    ) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn CSLInsertString(
        papszStrList: *mut *mut libc::c_char,
        nInsertAtLineNo: libc::c_int,
        pszNewLine: *const libc::c_char,
    ) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn CSLRemoveStrings(
        papszStrList: *mut *mut libc::c_char,
        nFirstLineToDelete: libc::c_int,
        nNumToRemove: libc::c_int,
        ppapszRetStrings: *mut *mut *mut libc::c_char,
    ) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn CSLFindString(papszList: CSLConstList, pszTarget: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn CSLFindStringCaseSensitive(
        papszList: CSLConstList,
        pszTarget: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CSLPartialFindString(
        papszHaystack: CSLConstList,
        pszNeedle: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CSLFindName(papszStrList: CSLConstList, pszName: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn CSLFetchBoolean(
        papszStrList: CSLConstList,
        pszKey: *const libc::c_char,
        bDefault: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CSLTestBoolean(pszValue: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn CPLTestBoolean(pszValue: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn CPLParseNameValue(
        pszNameValue: *const libc::c_char,
        ppszKey: *mut *mut libc::c_char,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn CSLFetchNameValue(
        papszStrList: CSLConstList,
        pszName: *const libc::c_char,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn CSLFetchNameValueDef(
        papszStrList: CSLConstList,
        pszName: *const libc::c_char,
        pszDefault: *const libc::c_char,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn CSLFetchNameValueMultiple(
        papszStrList: CSLConstList,
        pszName: *const libc::c_char,
    ) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn CSLAddNameValue(
        papszStrList: *mut *mut libc::c_char,
        pszName: *const libc::c_char,
        pszValue: *const libc::c_char,
    ) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn CSLSetNameValue(
        papszStrList: *mut *mut libc::c_char,
        pszName: *const libc::c_char,
        pszValue: *const libc::c_char,
    ) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn CSLSetNameValueSeparator(
        papszStrList: *mut *mut libc::c_char,
        pszSeparator: *const libc::c_char,
    );
}
extern "C" {
    pub fn CSLParseCommandLine(pszCommandLine: *const libc::c_char) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn CPLEscapeString(
        pszString: *const libc::c_char,
        nLength: libc::c_int,
        nScheme: libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn CPLUnescapeString(
        pszString: *const libc::c_char,
        pnLength: *mut libc::c_int,
        nScheme: libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn CPLBinaryToHex(nBytes: libc::c_int, pabyData: *const GByte) -> *mut libc::c_char;
}
extern "C" {
    pub fn CPLHexToBinary(pszHex: *const libc::c_char, pnBytes: *mut libc::c_int) -> *mut GByte;
}
extern "C" {
    pub fn CPLBase64Encode(nBytes: libc::c_int, pabyData: *const GByte) -> *mut libc::c_char;
}
extern "C" {
    pub fn CPLBase64DecodeInPlace(pszBase64: *mut GByte) -> libc::c_int;
}
pub mod CPLValueType {
    pub type Type = libc::c_uint;
    pub const CPL_VALUE_STRING: Type = 0;
    pub const CPL_VALUE_REAL: Type = 1;
    pub const CPL_VALUE_INTEGER: Type = 2;
}
extern "C" {
    pub fn CPLGetValueType(pszValue: *const libc::c_char) -> CPLValueType::Type;
}
extern "C" {
    pub fn CPLStrlcpy(
        pszDest: *mut libc::c_char,
        pszSrc: *const libc::c_char,
        nDestSize: usize,
    ) -> usize;
}
extern "C" {
    pub fn CPLStrlcat(
        pszDest: *mut libc::c_char,
        pszSrc: *const libc::c_char,
        nDestSize: usize,
    ) -> usize;
}
extern "C" {
    pub fn CPLStrnlen(pszStr: *const libc::c_char, nMaxLen: usize) -> usize;
}
extern "C" {
    pub fn CPLvsnprintf(
        str_: *mut libc::c_char,
        size: usize,
        fmt: *const libc::c_char,
        args: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CPLsnprintf(
        str_: *mut libc::c_char,
        size: usize,
        fmt: *const libc::c_char,
        ...
    ) -> libc::c_int;
}
extern "C" {
    pub fn CPLsprintf(str_: *mut libc::c_char, fmt: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn CPLprintf(fmt: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn CPLsscanf(str_: *const libc::c_char, fmt: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn CPLSPrintf(fmt: *const libc::c_char, ...) -> *const libc::c_char;
}
extern "C" {
    pub fn CSLAppendPrintf(
        papszStrList: *mut *mut libc::c_char,
        fmt: *const libc::c_char,
        ...
    ) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn CPLVASPrintf(
        buf: *mut *mut libc::c_char,
        fmt: *const libc::c_char,
        args: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CPLEncodingCharSize(pszEncoding: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn CPLClearRecodeWarningFlags();
}
extern "C" {
    pub fn CPLRecode(
        pszSource: *const libc::c_char,
        pszSrcEncoding: *const libc::c_char,
        pszDstEncoding: *const libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn CPLRecodeFromWChar(
        pwszSource: *const wchar_t,
        pszSrcEncoding: *const libc::c_char,
        pszDstEncoding: *const libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn CPLRecodeToWChar(
        pszSource: *const libc::c_char,
        pszSrcEncoding: *const libc::c_char,
        pszDstEncoding: *const libc::c_char,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn CPLIsUTF8(pabyData: *const libc::c_char, nLen: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn CPLForceToASCII(
        pabyData: *const libc::c_char,
        nLen: libc::c_int,
        chReplacementChar: libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn CPLStrlenUTF8(pszUTF8Str: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn CPLCanRecode(
        pszTestStr: *const libc::c_char,
        pszSrcEncoding: *const libc::c_char,
        pszDstEncoding: *const libc::c_char,
    ) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CPLHashSet {
    _unused: [u8; 0],
}
pub type CPLHashSet = _CPLHashSet;
pub type CPLHashSetHashFunc =
    ::std::option::Option<unsafe extern "C" fn(elt: *const libc::c_void) -> libc::c_ulong>;
pub type CPLHashSetEqualFunc = ::std::option::Option<
    unsafe extern "C" fn(elt1: *const libc::c_void, elt2: *const libc::c_void) -> libc::c_int,
>;
pub type CPLHashSetFreeEltFunc =
    ::std::option::Option<unsafe extern "C" fn(elt: *mut libc::c_void)>;
pub type CPLHashSetIterEltFunc = ::std::option::Option<
    unsafe extern "C" fn(elt: *mut libc::c_void, user_data: *mut libc::c_void) -> libc::c_int,
>;
extern "C" {
    pub fn CPLHashSetNew(
        fnHashFunc: CPLHashSetHashFunc,
        fnEqualFunc: CPLHashSetEqualFunc,
        fnFreeEltFunc: CPLHashSetFreeEltFunc,
    ) -> *mut CPLHashSet;
}
extern "C" {
    pub fn CPLHashSetDestroy(set: *mut CPLHashSet);
}
extern "C" {
    pub fn CPLHashSetClear(set: *mut CPLHashSet);
}
extern "C" {
    pub fn CPLHashSetSize(set: *const CPLHashSet) -> libc::c_int;
}
extern "C" {
    pub fn CPLHashSetForeach(
        set: *mut CPLHashSet,
        fnIterFunc: CPLHashSetIterEltFunc,
        user_data: *mut libc::c_void,
    );
}
extern "C" {
    pub fn CPLHashSetInsert(set: *mut CPLHashSet, elt: *mut libc::c_void) -> libc::c_int;
}
extern "C" {
    pub fn CPLHashSetLookup(set: *mut CPLHashSet, elt: *const libc::c_void) -> *mut libc::c_void;
}
extern "C" {
    pub fn CPLHashSetRemove(set: *mut CPLHashSet, elt: *const libc::c_void) -> libc::c_int;
}
extern "C" {
    pub fn CPLHashSetRemoveDeferRehash(
        set: *mut CPLHashSet,
        elt: *const libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CPLHashSetHashPointer(elt: *const libc::c_void) -> libc::c_ulong;
}
extern "C" {
    pub fn CPLHashSetEqualPointer(
        elt1: *const libc::c_void,
        elt2: *const libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CPLHashSetHashStr(pszStr: *const libc::c_void) -> libc::c_ulong;
}
extern "C" {
    pub fn CPLHashSetEqualStr(
        pszStr1: *const libc::c_void,
        pszStr2: *const libc::c_void,
    ) -> libc::c_int;
}
pub type CPLList = _CPLList;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CPLList {
    pub pData: *mut libc::c_void,
    pub psNext: *mut _CPLList,
}
#[test]
fn bindgen_test_layout__CPLList() {
    assert_eq!(
        ::std::mem::size_of::<_CPLList>(),
        16usize,
        concat!("Size of: ", stringify!(_CPLList))
    );
    assert_eq!(
        ::std::mem::align_of::<_CPLList>(),
        8usize,
        concat!("Alignment of ", stringify!(_CPLList))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CPLList>())).pData as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CPLList),
            "::",
            stringify!(pData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CPLList>())).psNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CPLList),
            "::",
            stringify!(psNext)
        )
    );
}
extern "C" {
    pub fn CPLListAppend(psList: *mut CPLList, pData: *mut libc::c_void) -> *mut CPLList;
}
extern "C" {
    pub fn CPLListInsert(
        psList: *mut CPLList,
        pData: *mut libc::c_void,
        nPosition: libc::c_int,
    ) -> *mut CPLList;
}
extern "C" {
    pub fn CPLListGetLast(psList: *mut CPLList) -> *mut CPLList;
}
extern "C" {
    pub fn CPLListGet(psList: *mut CPLList, nPosition: libc::c_int) -> *mut CPLList;
}
extern "C" {
    pub fn CPLListCount(psList: *const CPLList) -> libc::c_int;
}
extern "C" {
    pub fn CPLListRemove(psList: *mut CPLList, nPosition: libc::c_int) -> *mut CPLList;
}
extern "C" {
    pub fn CPLListDestroy(psList: *mut CPLList);
}
extern "C" {
    pub fn CPLListGetNext(psElement: *const CPLList) -> *mut CPLList;
}
extern "C" {
    pub fn CPLListGetData(psElement: *const CPLList) -> *mut libc::c_void;
}
pub mod CPLXMLNodeType {
    pub type Type = libc::c_uint;
    pub const CXT_Element: Type = 0;
    pub const CXT_Text: Type = 1;
    pub const CXT_Attribute: Type = 2;
    pub const CXT_Comment: Type = 3;
    pub const CXT_Literal: Type = 4;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CPLXMLNode {
    pub eType: CPLXMLNodeType::Type,
    pub pszValue: *mut libc::c_char,
    pub psNext: *mut CPLXMLNode,
    pub psChild: *mut CPLXMLNode,
}
#[test]
fn bindgen_test_layout_CPLXMLNode() {
    assert_eq!(
        ::std::mem::size_of::<CPLXMLNode>(),
        32usize,
        concat!("Size of: ", stringify!(CPLXMLNode))
    );
    assert_eq!(
        ::std::mem::align_of::<CPLXMLNode>(),
        8usize,
        concat!("Alignment of ", stringify!(CPLXMLNode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CPLXMLNode>())).eType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CPLXMLNode),
            "::",
            stringify!(eType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CPLXMLNode>())).pszValue as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CPLXMLNode),
            "::",
            stringify!(pszValue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CPLXMLNode>())).psNext as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CPLXMLNode),
            "::",
            stringify!(psNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CPLXMLNode>())).psChild as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CPLXMLNode),
            "::",
            stringify!(psChild)
        )
    );
}
extern "C" {
    pub fn CPLParseXMLString(arg1: *const libc::c_char) -> *mut CPLXMLNode;
}
extern "C" {
    pub fn CPLDestroyXMLNode(arg1: *mut CPLXMLNode);
}
extern "C" {
    pub fn CPLGetXMLNode(poRoot: *mut CPLXMLNode, pszPath: *const libc::c_char) -> *mut CPLXMLNode;
}
extern "C" {
    pub fn CPLSearchXMLNode(
        poRoot: *mut CPLXMLNode,
        pszTarget: *const libc::c_char,
    ) -> *mut CPLXMLNode;
}
extern "C" {
    pub fn CPLGetXMLValue(
        poRoot: *const CPLXMLNode,
        pszPath: *const libc::c_char,
        pszDefault: *const libc::c_char,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLCreateXMLNode(
        poParent: *mut CPLXMLNode,
        eType: CPLXMLNodeType::Type,
        pszText: *const libc::c_char,
    ) -> *mut CPLXMLNode;
}
extern "C" {
    pub fn CPLSerializeXMLTree(psNode: *const CPLXMLNode) -> *mut libc::c_char;
}
extern "C" {
    pub fn CPLAddXMLChild(psParent: *mut CPLXMLNode, psChild: *mut CPLXMLNode);
}
extern "C" {
    pub fn CPLRemoveXMLChild(psParent: *mut CPLXMLNode, psChild: *mut CPLXMLNode) -> libc::c_int;
}
extern "C" {
    pub fn CPLAddXMLSibling(psOlderSibling: *mut CPLXMLNode, psNewSibling: *mut CPLXMLNode);
}
extern "C" {
    pub fn CPLCreateXMLElementAndValue(
        psParent: *mut CPLXMLNode,
        pszName: *const libc::c_char,
        pszValue: *const libc::c_char,
    ) -> *mut CPLXMLNode;
}
extern "C" {
    pub fn CPLAddXMLAttributeAndValue(
        psParent: *mut CPLXMLNode,
        pszName: *const libc::c_char,
        pszValue: *const libc::c_char,
    );
}
extern "C" {
    pub fn CPLCloneXMLTree(psTree: *const CPLXMLNode) -> *mut CPLXMLNode;
}
extern "C" {
    pub fn CPLSetXMLValue(
        psRoot: *mut CPLXMLNode,
        pszPath: *const libc::c_char,
        pszValue: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CPLStripXMLNamespace(
        psRoot: *mut CPLXMLNode,
        pszNameSpace: *const libc::c_char,
        bRecurse: libc::c_int,
    );
}
extern "C" {
    pub fn CPLCleanXMLElementName(arg1: *mut libc::c_char);
}
extern "C" {
    pub fn CPLParseXMLFile(pszFilename: *const libc::c_char) -> *mut CPLXMLNode;
}
extern "C" {
    pub fn CPLSerializeXMLTreeToFile(
        psTree: *const CPLXMLNode,
        pszFilename: *const libc::c_char,
    ) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CPLRectObj {
    pub minx: f64,
    pub miny: f64,
    pub maxx: f64,
    pub maxy: f64,
}
#[test]
fn bindgen_test_layout_CPLRectObj() {
    assert_eq!(
        ::std::mem::size_of::<CPLRectObj>(),
        32usize,
        concat!("Size of: ", stringify!(CPLRectObj))
    );
    assert_eq!(
        ::std::mem::align_of::<CPLRectObj>(),
        8usize,
        concat!("Alignment of ", stringify!(CPLRectObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CPLRectObj>())).minx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CPLRectObj),
            "::",
            stringify!(minx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CPLRectObj>())).miny as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CPLRectObj),
            "::",
            stringify!(miny)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CPLRectObj>())).maxx as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CPLRectObj),
            "::",
            stringify!(maxx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CPLRectObj>())).maxy as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CPLRectObj),
            "::",
            stringify!(maxy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CPLQuadTree {
    _unused: [u8; 0],
}
pub type CPLQuadTree = _CPLQuadTree;
pub type CPLQuadTreeGetBoundsFunc = ::std::option::Option<
    unsafe extern "C" fn(hFeature: *const libc::c_void, pBounds: *mut CPLRectObj),
>;
pub type CPLQuadTreeForeachFunc = ::std::option::Option<
    unsafe extern "C" fn(pElt: *mut libc::c_void, pUserData: *mut libc::c_void) -> libc::c_int,
>;
pub type CPLQuadTreeDumpFeatureFunc = ::std::option::Option<
    unsafe extern "C" fn(
        hFeature: *const libc::c_void,
        nIndentLevel: libc::c_int,
        pUserData: *mut libc::c_void,
    ),
>;
extern "C" {
    pub fn CPLQuadTreeCreate(
        pGlobalBounds: *const CPLRectObj,
        pfnGetBounds: CPLQuadTreeGetBoundsFunc,
    ) -> *mut CPLQuadTree;
}
extern "C" {
    pub fn CPLQuadTreeDestroy(hQuadtree: *mut CPLQuadTree);
}
extern "C" {
    pub fn CPLQuadTreeSetBucketCapacity(hQuadtree: *mut CPLQuadTree, nBucketCapacity: libc::c_int);
}
extern "C" {
    pub fn CPLQuadTreeGetAdvisedMaxDepth(nExpectedFeatures: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn CPLQuadTreeSetMaxDepth(hQuadtree: *mut CPLQuadTree, nMaxDepth: libc::c_int);
}
extern "C" {
    pub fn CPLQuadTreeInsert(hQuadtree: *mut CPLQuadTree, hFeature: *mut libc::c_void);
}
extern "C" {
    pub fn CPLQuadTreeInsertWithBounds(
        hQuadtree: *mut CPLQuadTree,
        hFeature: *mut libc::c_void,
        psBounds: *const CPLRectObj,
    );
}
extern "C" {
    pub fn CPLQuadTreeSearch(
        hQuadtree: *const CPLQuadTree,
        pAoi: *const CPLRectObj,
        pnFeatureCount: *mut libc::c_int,
    ) -> *mut *mut libc::c_void;
}
extern "C" {
    pub fn CPLQuadTreeForeach(
        hQuadtree: *const CPLQuadTree,
        pfnForeach: CPLQuadTreeForeachFunc,
        pUserData: *mut libc::c_void,
    );
}
extern "C" {
    pub fn CPLQuadTreeDump(
        hQuadtree: *const CPLQuadTree,
        pfnDumpFeatureFunc: CPLQuadTreeDumpFeatureFunc,
        pUserData: *mut libc::c_void,
    );
}
extern "C" {
    pub fn CPLQuadTreeGetStats(
        hQuadtree: *const CPLQuadTree,
        pnFeatureCount: *mut libc::c_int,
        pnNodeCount: *mut libc::c_int,
        pnMaxDepth: *mut libc::c_int,
        pnMaxBucketCapacity: *mut libc::c_int,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CPLVirtualMem {
    _unused: [u8; 0],
}
pub type CPLVirtualMemCachePageCbk = ::std::option::Option<
    unsafe extern "C" fn(
        ctxt: *mut CPLVirtualMem,
        nOffset: usize,
        pPageToFill: *mut libc::c_void,
        nToFill: usize,
        pUserData: *mut libc::c_void,
    ),
>;
pub type CPLVirtualMemUnCachePageCbk = ::std::option::Option<
    unsafe extern "C" fn(
        ctxt: *mut CPLVirtualMem,
        nOffset: usize,
        pPageToBeEvicted: *const libc::c_void,
        nToBeEvicted: usize,
        pUserData: *mut libc::c_void,
    ),
>;
pub type CPLVirtualMemFreeUserData =
    ::std::option::Option<unsafe extern "C" fn(pUserData: *mut libc::c_void)>;
pub mod CPLVirtualMemAccessMode {
    pub type Type = libc::c_uint;
    pub const VIRTUALMEM_READONLY: Type = 0;
    pub const VIRTUALMEM_READONLY_ENFORCED: Type = 1;
    pub const VIRTUALMEM_READWRITE: Type = 2;
}
extern "C" {
    pub fn CPLGetPageSize() -> usize;
}
extern "C" {
    pub fn CPLVirtualMemNew(
        nSize: usize,
        nCacheSize: usize,
        nPageSizeHint: usize,
        bSingleThreadUsage: libc::c_int,
        eAccessMode: CPLVirtualMemAccessMode::Type,
        pfnCachePage: CPLVirtualMemCachePageCbk,
        pfnUnCachePage: CPLVirtualMemUnCachePageCbk,
        pfnFreeUserData: CPLVirtualMemFreeUserData,
        pCbkUserData: *mut libc::c_void,
    ) -> *mut CPLVirtualMem;
}
extern "C" {
    pub fn CPLIsVirtualMemFileMapAvailable() -> libc::c_int;
}
extern "C" {
    pub fn CPLVirtualMemFileMapNew(
        fp: *mut VSILFILE,
        nOffset: vsi_l_offset,
        nLength: vsi_l_offset,
        eAccessMode: CPLVirtualMemAccessMode::Type,
        pfnFreeUserData: CPLVirtualMemFreeUserData,
        pCbkUserData: *mut libc::c_void,
    ) -> *mut CPLVirtualMem;
}
extern "C" {
    pub fn CPLVirtualMemDerivedNew(
        pVMemBase: *mut CPLVirtualMem,
        nOffset: vsi_l_offset,
        nSize: vsi_l_offset,
        pfnFreeUserData: CPLVirtualMemFreeUserData,
        pCbkUserData: *mut libc::c_void,
    ) -> *mut CPLVirtualMem;
}
extern "C" {
    pub fn CPLVirtualMemFree(ctxt: *mut CPLVirtualMem);
}
extern "C" {
    pub fn CPLVirtualMemGetAddr(ctxt: *mut CPLVirtualMem) -> *mut libc::c_void;
}
extern "C" {
    pub fn CPLVirtualMemGetSize(ctxt: *mut CPLVirtualMem) -> usize;
}
extern "C" {
    pub fn CPLVirtualMemIsFileMapping(ctxt: *mut CPLVirtualMem) -> libc::c_int;
}
extern "C" {
    pub fn CPLVirtualMemGetAccessMode(ctxt: *mut CPLVirtualMem) -> CPLVirtualMemAccessMode::Type;
}
extern "C" {
    pub fn CPLVirtualMemGetPageSize(ctxt: *mut CPLVirtualMem) -> usize;
}
extern "C" {
    pub fn CPLVirtualMemIsAccessThreadSafe(ctxt: *mut CPLVirtualMem) -> libc::c_int;
}
extern "C" {
    pub fn CPLVirtualMemDeclareThread(ctxt: *mut CPLVirtualMem);
}
extern "C" {
    pub fn CPLVirtualMemUnDeclareThread(ctxt: *mut CPLVirtualMem);
}
extern "C" {
    pub fn CPLVirtualMemPin(
        ctxt: *mut CPLVirtualMem,
        pAddr: *mut libc::c_void,
        nSize: usize,
        bWriteOp: libc::c_int,
    );
}
extern "C" {
    pub fn CPLVirtualMemManagerTerminate();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OGREnvelope {
    pub MinX: f64,
    pub MaxX: f64,
    pub MinY: f64,
    pub MaxY: f64,
}
#[test]
fn bindgen_test_layout_OGREnvelope() {
    assert_eq!(
        ::std::mem::size_of::<OGREnvelope>(),
        32usize,
        concat!("Size of: ", stringify!(OGREnvelope))
    );
    assert_eq!(
        ::std::mem::align_of::<OGREnvelope>(),
        8usize,
        concat!("Alignment of ", stringify!(OGREnvelope))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGREnvelope>())).MinX as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGREnvelope),
            "::",
            stringify!(MinX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGREnvelope>())).MaxX as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OGREnvelope),
            "::",
            stringify!(MaxX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGREnvelope>())).MinY as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OGREnvelope),
            "::",
            stringify!(MinY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGREnvelope>())).MaxY as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(OGREnvelope),
            "::",
            stringify!(MaxY)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OGREnvelope3D {
    pub MinX: f64,
    pub MaxX: f64,
    pub MinY: f64,
    pub MaxY: f64,
    pub MinZ: f64,
    pub MaxZ: f64,
}
#[test]
fn bindgen_test_layout_OGREnvelope3D() {
    assert_eq!(
        ::std::mem::size_of::<OGREnvelope3D>(),
        48usize,
        concat!("Size of: ", stringify!(OGREnvelope3D))
    );
    assert_eq!(
        ::std::mem::align_of::<OGREnvelope3D>(),
        8usize,
        concat!("Alignment of ", stringify!(OGREnvelope3D))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGREnvelope3D>())).MinX as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGREnvelope3D),
            "::",
            stringify!(MinX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGREnvelope3D>())).MaxX as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OGREnvelope3D),
            "::",
            stringify!(MaxX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGREnvelope3D>())).MinY as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OGREnvelope3D),
            "::",
            stringify!(MinY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGREnvelope3D>())).MaxY as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(OGREnvelope3D),
            "::",
            stringify!(MaxY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGREnvelope3D>())).MinZ as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(OGREnvelope3D),
            "::",
            stringify!(MinZ)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGREnvelope3D>())).MaxZ as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(OGREnvelope3D),
            "::",
            stringify!(MaxZ)
        )
    );
}
extern "C" {
    pub fn OGRMalloc(arg1: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn OGRCalloc(arg1: usize, arg2: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn OGRRealloc(arg1: *mut libc::c_void, arg2: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn OGRStrdup(arg1: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn OGRFree(arg1: *mut libc::c_void);
}
pub mod OGRwkbGeometryType {
    pub type Type = libc::c_uint;
    pub const wkbUnknown: Type = 0;
    pub const wkbPoint: Type = 1;
    pub const wkbLineString: Type = 2;
    pub const wkbPolygon: Type = 3;
    pub const wkbMultiPoint: Type = 4;
    pub const wkbMultiLineString: Type = 5;
    pub const wkbMultiPolygon: Type = 6;
    pub const wkbGeometryCollection: Type = 7;
    pub const wkbCircularString: Type = 8;
    pub const wkbCompoundCurve: Type = 9;
    pub const wkbCurvePolygon: Type = 10;
    pub const wkbMultiCurve: Type = 11;
    pub const wkbMultiSurface: Type = 12;
    pub const wkbCurve: Type = 13;
    pub const wkbSurface: Type = 14;
    pub const wkbPolyhedralSurface: Type = 15;
    pub const wkbTIN: Type = 16;
    pub const wkbTriangle: Type = 17;
    pub const wkbNone: Type = 100;
    pub const wkbLinearRing: Type = 101;
    pub const wkbCircularStringZ: Type = 1008;
    pub const wkbCompoundCurveZ: Type = 1009;
    pub const wkbCurvePolygonZ: Type = 1010;
    pub const wkbMultiCurveZ: Type = 1011;
    pub const wkbMultiSurfaceZ: Type = 1012;
    pub const wkbCurveZ: Type = 1013;
    pub const wkbSurfaceZ: Type = 1014;
    pub const wkbPolyhedralSurfaceZ: Type = 1015;
    pub const wkbTINZ: Type = 1016;
    pub const wkbTriangleZ: Type = 1017;
    pub const wkbPointM: Type = 2001;
    pub const wkbLineStringM: Type = 2002;
    pub const wkbPolygonM: Type = 2003;
    pub const wkbMultiPointM: Type = 2004;
    pub const wkbMultiLineStringM: Type = 2005;
    pub const wkbMultiPolygonM: Type = 2006;
    pub const wkbGeometryCollectionM: Type = 2007;
    pub const wkbCircularStringM: Type = 2008;
    pub const wkbCompoundCurveM: Type = 2009;
    pub const wkbCurvePolygonM: Type = 2010;
    pub const wkbMultiCurveM: Type = 2011;
    pub const wkbMultiSurfaceM: Type = 2012;
    pub const wkbCurveM: Type = 2013;
    pub const wkbSurfaceM: Type = 2014;
    pub const wkbPolyhedralSurfaceM: Type = 2015;
    pub const wkbTINM: Type = 2016;
    pub const wkbTriangleM: Type = 2017;
    pub const wkbPointZM: Type = 3001;
    pub const wkbLineStringZM: Type = 3002;
    pub const wkbPolygonZM: Type = 3003;
    pub const wkbMultiPointZM: Type = 3004;
    pub const wkbMultiLineStringZM: Type = 3005;
    pub const wkbMultiPolygonZM: Type = 3006;
    pub const wkbGeometryCollectionZM: Type = 3007;
    pub const wkbCircularStringZM: Type = 3008;
    pub const wkbCompoundCurveZM: Type = 3009;
    pub const wkbCurvePolygonZM: Type = 3010;
    pub const wkbMultiCurveZM: Type = 3011;
    pub const wkbMultiSurfaceZM: Type = 3012;
    pub const wkbCurveZM: Type = 3013;
    pub const wkbSurfaceZM: Type = 3014;
    pub const wkbPolyhedralSurfaceZM: Type = 3015;
    pub const wkbTINZM: Type = 3016;
    pub const wkbTriangleZM: Type = 3017;
    pub const wkbPoint25D: Type = 2147483649;
    pub const wkbLineString25D: Type = 2147483650;
    pub const wkbPolygon25D: Type = 2147483651;
    pub const wkbMultiPoint25D: Type = 2147483652;
    pub const wkbMultiLineString25D: Type = 2147483653;
    pub const wkbMultiPolygon25D: Type = 2147483654;
    pub const wkbGeometryCollection25D: Type = 2147483655;
}
extern "C" {
    pub fn OGRGeometryTypeToName(eType: OGRwkbGeometryType::Type) -> *const libc::c_char;
}
extern "C" {
    pub fn OGRMergeGeometryTypes(
        eMain: OGRwkbGeometryType::Type,
        eExtra: OGRwkbGeometryType::Type,
    ) -> OGRwkbGeometryType::Type;
}
extern "C" {
    pub fn OGRMergeGeometryTypesEx(
        eMain: OGRwkbGeometryType::Type,
        eExtra: OGRwkbGeometryType::Type,
        bAllowPromotingToCurves: libc::c_int,
    ) -> OGRwkbGeometryType::Type;
}
extern "C" {
    pub fn OGR_GT_Flatten(eType: OGRwkbGeometryType::Type) -> OGRwkbGeometryType::Type;
}
extern "C" {
    pub fn OGR_GT_SetZ(eType: OGRwkbGeometryType::Type) -> OGRwkbGeometryType::Type;
}
extern "C" {
    pub fn OGR_GT_SetM(eType: OGRwkbGeometryType::Type) -> OGRwkbGeometryType::Type;
}
extern "C" {
    pub fn OGR_GT_SetModifier(
        eType: OGRwkbGeometryType::Type,
        bSetZ: libc::c_int,
        bSetM: libc::c_int,
    ) -> OGRwkbGeometryType::Type;
}
extern "C" {
    pub fn OGR_GT_HasZ(eType: OGRwkbGeometryType::Type) -> libc::c_int;
}
extern "C" {
    pub fn OGR_GT_HasM(eType: OGRwkbGeometryType::Type) -> libc::c_int;
}
extern "C" {
    pub fn OGR_GT_IsSubClassOf(
        eType: OGRwkbGeometryType::Type,
        eSuperType: OGRwkbGeometryType::Type,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OGR_GT_IsCurve(arg1: OGRwkbGeometryType::Type) -> libc::c_int;
}
extern "C" {
    pub fn OGR_GT_IsSurface(arg1: OGRwkbGeometryType::Type) -> libc::c_int;
}
extern "C" {
    pub fn OGR_GT_IsNonLinear(arg1: OGRwkbGeometryType::Type) -> libc::c_int;
}
extern "C" {
    pub fn OGR_GT_GetCollection(eType: OGRwkbGeometryType::Type) -> OGRwkbGeometryType::Type;
}
extern "C" {
    pub fn OGR_GT_GetCurve(eType: OGRwkbGeometryType::Type) -> OGRwkbGeometryType::Type;
}
extern "C" {
    pub fn OGR_GT_GetLinear(eType: OGRwkbGeometryType::Type) -> OGRwkbGeometryType::Type;
}
pub mod OGRwkbByteOrder {
    pub type Type = libc::c_uint;
    pub const wkbXDR: Type = 0;
    pub const wkbNDR: Type = 1;
}
pub mod OGRFieldType {
    pub type Type = libc::c_uint;
    pub const OFTInteger: Type = 0;
    pub const OFTIntegerList: Type = 1;
    pub const OFTReal: Type = 2;
    pub const OFTRealList: Type = 3;
    pub const OFTString: Type = 4;
    pub const OFTStringList: Type = 5;
    pub const OFTWideString: Type = 6;
    pub const OFTWideStringList: Type = 7;
    pub const OFTBinary: Type = 8;
    pub const OFTDate: Type = 9;
    pub const OFTTime: Type = 10;
    pub const OFTDateTime: Type = 11;
    pub const OFTInteger64: Type = 12;
    pub const OFTInteger64List: Type = 13;
    pub const OFTMaxType: Type = 13;
}
pub mod OGRFieldSubType {
    pub type Type = libc::c_uint;
    pub const OFSTNone: Type = 0;
    pub const OFSTBoolean: Type = 1;
    pub const OFSTInt16: Type = 2;
    pub const OFSTFloat32: Type = 3;
    pub const OFSTJSON: Type = 4;
    pub const OFSTMaxSubType: Type = 4;
}
pub mod OGRJustification {
    pub type Type = libc::c_uint;
    pub const OJUndefined: Type = 0;
    pub const OJLeft: Type = 1;
    pub const OJRight: Type = 2;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union OGRField {
    pub Integer: libc::c_int,
    pub Integer64: GIntBig,
    pub Real: f64,
    pub String: *mut libc::c_char,
    pub IntegerList: OGRField__bindgen_ty_1,
    pub Integer64List: OGRField__bindgen_ty_2,
    pub RealList: OGRField__bindgen_ty_3,
    pub StringList: OGRField__bindgen_ty_4,
    pub Binary: OGRField__bindgen_ty_5,
    pub Set: OGRField__bindgen_ty_6,
    pub Date: OGRField__bindgen_ty_7,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OGRField__bindgen_ty_1 {
    pub nCount: libc::c_int,
    pub paList: *mut libc::c_int,
}
#[test]
fn bindgen_test_layout_OGRField__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<OGRField__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(OGRField__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<OGRField__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(OGRField__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField__bindgen_ty_1>())).nCount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_1),
            "::",
            stringify!(nCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField__bindgen_ty_1>())).paList as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_1),
            "::",
            stringify!(paList)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OGRField__bindgen_ty_2 {
    pub nCount: libc::c_int,
    pub paList: *mut GIntBig,
}
#[test]
fn bindgen_test_layout_OGRField__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<OGRField__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(OGRField__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<OGRField__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(OGRField__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField__bindgen_ty_2>())).nCount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_2),
            "::",
            stringify!(nCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField__bindgen_ty_2>())).paList as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_2),
            "::",
            stringify!(paList)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OGRField__bindgen_ty_3 {
    pub nCount: libc::c_int,
    pub paList: *mut f64,
}
#[test]
fn bindgen_test_layout_OGRField__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<OGRField__bindgen_ty_3>(),
        16usize,
        concat!("Size of: ", stringify!(OGRField__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<OGRField__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(OGRField__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField__bindgen_ty_3>())).nCount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_3),
            "::",
            stringify!(nCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField__bindgen_ty_3>())).paList as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_3),
            "::",
            stringify!(paList)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OGRField__bindgen_ty_4 {
    pub nCount: libc::c_int,
    pub paList: *mut *mut libc::c_char,
}
#[test]
fn bindgen_test_layout_OGRField__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<OGRField__bindgen_ty_4>(),
        16usize,
        concat!("Size of: ", stringify!(OGRField__bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<OGRField__bindgen_ty_4>(),
        8usize,
        concat!("Alignment of ", stringify!(OGRField__bindgen_ty_4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField__bindgen_ty_4>())).nCount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_4),
            "::",
            stringify!(nCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField__bindgen_ty_4>())).paList as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_4),
            "::",
            stringify!(paList)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OGRField__bindgen_ty_5 {
    pub nCount: libc::c_int,
    pub paData: *mut GByte,
}
#[test]
fn bindgen_test_layout_OGRField__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<OGRField__bindgen_ty_5>(),
        16usize,
        concat!("Size of: ", stringify!(OGRField__bindgen_ty_5))
    );
    assert_eq!(
        ::std::mem::align_of::<OGRField__bindgen_ty_5>(),
        8usize,
        concat!("Alignment of ", stringify!(OGRField__bindgen_ty_5))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField__bindgen_ty_5>())).nCount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_5),
            "::",
            stringify!(nCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField__bindgen_ty_5>())).paData as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_5),
            "::",
            stringify!(paData)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OGRField__bindgen_ty_6 {
    pub nMarker1: libc::c_int,
    pub nMarker2: libc::c_int,
    pub nMarker3: libc::c_int,
}
#[test]
fn bindgen_test_layout_OGRField__bindgen_ty_6() {
    assert_eq!(
        ::std::mem::size_of::<OGRField__bindgen_ty_6>(),
        12usize,
        concat!("Size of: ", stringify!(OGRField__bindgen_ty_6))
    );
    assert_eq!(
        ::std::mem::align_of::<OGRField__bindgen_ty_6>(),
        4usize,
        concat!("Alignment of ", stringify!(OGRField__bindgen_ty_6))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField__bindgen_ty_6>())).nMarker1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_6),
            "::",
            stringify!(nMarker1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField__bindgen_ty_6>())).nMarker2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_6),
            "::",
            stringify!(nMarker2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField__bindgen_ty_6>())).nMarker3 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_6),
            "::",
            stringify!(nMarker3)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OGRField__bindgen_ty_7 {
    pub Year: GInt16,
    pub Month: GByte,
    pub Day: GByte,
    pub Hour: GByte,
    pub Minute: GByte,
    pub TZFlag: GByte,
    pub Reserved: GByte,
    pub Second: f32,
}
#[test]
fn bindgen_test_layout_OGRField__bindgen_ty_7() {
    assert_eq!(
        ::std::mem::size_of::<OGRField__bindgen_ty_7>(),
        12usize,
        concat!("Size of: ", stringify!(OGRField__bindgen_ty_7))
    );
    assert_eq!(
        ::std::mem::align_of::<OGRField__bindgen_ty_7>(),
        4usize,
        concat!("Alignment of ", stringify!(OGRField__bindgen_ty_7))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField__bindgen_ty_7>())).Year as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_7),
            "::",
            stringify!(Year)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField__bindgen_ty_7>())).Month as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_7),
            "::",
            stringify!(Month)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField__bindgen_ty_7>())).Day as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_7),
            "::",
            stringify!(Day)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField__bindgen_ty_7>())).Hour as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_7),
            "::",
            stringify!(Hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField__bindgen_ty_7>())).Minute as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_7),
            "::",
            stringify!(Minute)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField__bindgen_ty_7>())).TZFlag as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_7),
            "::",
            stringify!(TZFlag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField__bindgen_ty_7>())).Reserved as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_7),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField__bindgen_ty_7>())).Second as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_7),
            "::",
            stringify!(Second)
        )
    );
}
#[test]
fn bindgen_test_layout_OGRField() {
    assert_eq!(
        ::std::mem::size_of::<OGRField>(),
        16usize,
        concat!("Size of: ", stringify!(OGRField))
    );
    assert_eq!(
        ::std::mem::align_of::<OGRField>(),
        8usize,
        concat!("Alignment of ", stringify!(OGRField))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField>())).Integer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField),
            "::",
            stringify!(Integer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField>())).Integer64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField),
            "::",
            stringify!(Integer64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField>())).Real as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField),
            "::",
            stringify!(Real)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField>())).String as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField),
            "::",
            stringify!(String)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField>())).IntegerList as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField),
            "::",
            stringify!(IntegerList)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField>())).Integer64List as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField),
            "::",
            stringify!(Integer64List)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField>())).RealList as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField),
            "::",
            stringify!(RealList)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField>())).StringList as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField),
            "::",
            stringify!(StringList)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField>())).Binary as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField),
            "::",
            stringify!(Binary)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField>())).Set as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField),
            "::",
            stringify!(Set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField>())).Date as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField),
            "::",
            stringify!(Date)
        )
    );
}
extern "C" {
    pub fn OGRParseDate(
        pszInput: *const libc::c_char,
        psOutput: *mut OGRField,
        nOptions: libc::c_int,
    ) -> libc::c_int;
}
pub mod ogr_style_tool_class_id {
    pub type Type = libc::c_uint;
    pub const OGRSTCNone: Type = 0;
    pub const OGRSTCPen: Type = 1;
    pub const OGRSTCBrush: Type = 2;
    pub const OGRSTCSymbol: Type = 3;
    pub const OGRSTCLabel: Type = 4;
    pub const OGRSTCVector: Type = 5;
}
pub use self::ogr_style_tool_class_id::Type as OGRSTClassId;
pub mod ogr_style_tool_units_id {
    pub type Type = libc::c_uint;
    pub const OGRSTUGround: Type = 0;
    pub const OGRSTUPixel: Type = 1;
    pub const OGRSTUPoints: Type = 2;
    pub const OGRSTUMM: Type = 3;
    pub const OGRSTUCM: Type = 4;
    pub const OGRSTUInches: Type = 5;
}
pub use self::ogr_style_tool_units_id::Type as OGRSTUnitId;
extern "C" {
    pub fn GDALVersionInfo(arg1: *const libc::c_char) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALCheckVersion(
        nVersionMajor: libc::c_int,
        nVersionMinor: libc::c_int,
        pszCallingComponentName: *const libc::c_char,
    ) -> libc::c_int;
}
pub type OGRGeometryH = *mut libc::c_void;
pub type OGRSpatialReferenceH = *mut libc::c_void;
pub type OGRCoordinateTransformationH = *mut libc::c_void;
extern "C" {
    pub fn OGR_G_CreateFromWkb(
        arg1: *const libc::c_void,
        arg2: OGRSpatialReferenceH,
        arg3: *mut OGRGeometryH,
        arg4: libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_G_CreateFromWkt(
        arg1: *mut *mut libc::c_char,
        arg2: OGRSpatialReferenceH,
        arg3: *mut OGRGeometryH,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_G_CreateFromFgf(
        arg1: *const libc::c_void,
        arg2: OGRSpatialReferenceH,
        arg3: *mut OGRGeometryH,
        arg4: libc::c_int,
        arg5: *mut libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_G_DestroyGeometry(arg1: OGRGeometryH);
}
extern "C" {
    pub fn OGR_G_CreateGeometry(arg1: OGRwkbGeometryType::Type) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_ApproximateArcAngles(
        dfCenterX: f64,
        dfCenterY: f64,
        dfZ: f64,
        dfPrimaryRadius: f64,
        dfSecondaryAxis: f64,
        dfRotation: f64,
        dfStartAngle: f64,
        dfEndAngle: f64,
        dfMaxAngleStepSizeDegrees: f64,
    ) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_ForceToPolygon(arg1: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_ForceToLineString(arg1: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_ForceToMultiPolygon(arg1: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_ForceToMultiPoint(arg1: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_ForceToMultiLineString(arg1: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_ForceTo(
        hGeom: OGRGeometryH,
        eTargetType: OGRwkbGeometryType::Type,
        papszOptions: *mut *mut libc::c_char,
    ) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_RemoveLowerDimensionSubGeoms(hGeom: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_GetDimension(arg1: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_GetCoordinateDimension(arg1: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_CoordinateDimension(arg1: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_SetCoordinateDimension(arg1: OGRGeometryH, arg2: libc::c_int);
}
extern "C" {
    pub fn OGR_G_Is3D(arg1: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_IsMeasured(arg1: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_Set3D(arg1: OGRGeometryH, arg2: libc::c_int);
}
extern "C" {
    pub fn OGR_G_SetMeasured(arg1: OGRGeometryH, arg2: libc::c_int);
}
extern "C" {
    pub fn OGR_G_Clone(arg1: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_GetEnvelope(arg1: OGRGeometryH, arg2: *mut OGREnvelope);
}
extern "C" {
    pub fn OGR_G_GetEnvelope3D(arg1: OGRGeometryH, arg2: *mut OGREnvelope3D);
}
extern "C" {
    pub fn OGR_G_ImportFromWkb(
        arg1: OGRGeometryH,
        arg2: *const libc::c_void,
        arg3: libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_G_ExportToWkb(
        arg1: OGRGeometryH,
        arg2: OGRwkbByteOrder::Type,
        arg3: *mut libc::c_uchar,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_G_ExportToIsoWkb(
        arg1: OGRGeometryH,
        arg2: OGRwkbByteOrder::Type,
        arg3: *mut libc::c_uchar,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_G_WkbSize(hGeom: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_ImportFromWkt(arg1: OGRGeometryH, arg2: *mut *mut libc::c_char) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_G_ExportToWkt(arg1: OGRGeometryH, arg2: *mut *mut libc::c_char) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_G_ExportToIsoWkt(arg1: OGRGeometryH, arg2: *mut *mut libc::c_char) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_G_GetGeometryType(arg1: OGRGeometryH) -> OGRwkbGeometryType::Type;
}
extern "C" {
    pub fn OGR_G_GetGeometryName(arg1: OGRGeometryH) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_G_DumpReadable(arg1: OGRGeometryH, arg2: *mut FILE, arg3: *const libc::c_char);
}
extern "C" {
    pub fn OGR_G_FlattenTo2D(arg1: OGRGeometryH);
}
extern "C" {
    pub fn OGR_G_CloseRings(arg1: OGRGeometryH);
}
extern "C" {
    pub fn OGR_G_CreateFromGML(arg1: *const libc::c_char) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_ExportToGML(arg1: OGRGeometryH) -> *mut libc::c_char;
}
extern "C" {
    pub fn OGR_G_ExportToGMLEx(
        arg1: OGRGeometryH,
        papszOptions: *mut *mut libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn OGR_G_CreateFromGMLTree(arg1: *const CPLXMLNode) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_ExportToGMLTree(arg1: OGRGeometryH) -> *mut CPLXMLNode;
}
extern "C" {
    pub fn OGR_G_ExportEnvelopeToGMLTree(arg1: OGRGeometryH) -> *mut CPLXMLNode;
}
extern "C" {
    pub fn OGR_G_ExportToKML(
        arg1: OGRGeometryH,
        pszAltitudeMode: *const libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn OGR_G_ExportToJson(arg1: OGRGeometryH) -> *mut libc::c_char;
}
extern "C" {
    pub fn OGR_G_ExportToJsonEx(
        arg1: OGRGeometryH,
        papszOptions: *mut *mut libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn OGR_G_CreateGeometryFromJson(arg1: *const libc::c_char) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_CreateGeometryFromEsriJson(arg1: *const libc::c_char) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_AssignSpatialReference(arg1: OGRGeometryH, arg2: OGRSpatialReferenceH);
}
extern "C" {
    pub fn OGR_G_GetSpatialReference(arg1: OGRGeometryH) -> OGRSpatialReferenceH;
}
extern "C" {
    pub fn OGR_G_Transform(arg1: OGRGeometryH, arg2: OGRCoordinateTransformationH) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_G_TransformTo(arg1: OGRGeometryH, arg2: OGRSpatialReferenceH) -> OGRErr::Type;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OGRGeomTransformer {
    _unused: [u8; 0],
}
pub type OGRGeomTransformerH = *mut OGRGeomTransformer;
extern "C" {
    pub fn OGR_GeomTransformer_Create(
        arg1: OGRCoordinateTransformationH,
        papszOptions: CSLConstList,
    ) -> OGRGeomTransformerH;
}
extern "C" {
    pub fn OGR_GeomTransformer_Transform(
        hTransformer: OGRGeomTransformerH,
        hGeom: OGRGeometryH,
    ) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_GeomTransformer_Destroy(hTransformer: OGRGeomTransformerH);
}
extern "C" {
    pub fn OGR_G_Simplify(hThis: OGRGeometryH, tolerance: f64) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_SimplifyPreserveTopology(hThis: OGRGeometryH, tolerance: f64) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_DelaunayTriangulation(
        hThis: OGRGeometryH,
        dfTolerance: f64,
        bOnlyEdges: libc::c_int,
    ) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_Segmentize(hGeom: OGRGeometryH, dfMaxLength: f64);
}
extern "C" {
    pub fn OGR_G_Intersects(arg1: OGRGeometryH, arg2: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_Equals(arg1: OGRGeometryH, arg2: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_Disjoint(arg1: OGRGeometryH, arg2: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_Touches(arg1: OGRGeometryH, arg2: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_Crosses(arg1: OGRGeometryH, arg2: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_Within(arg1: OGRGeometryH, arg2: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_Contains(arg1: OGRGeometryH, arg2: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_Overlaps(arg1: OGRGeometryH, arg2: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_Boundary(arg1: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_ConvexHull(arg1: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_Buffer(arg1: OGRGeometryH, arg2: f64, arg3: libc::c_int) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_Intersection(arg1: OGRGeometryH, arg2: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_Union(arg1: OGRGeometryH, arg2: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_UnionCascaded(arg1: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_PointOnSurface(arg1: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_Difference(arg1: OGRGeometryH, arg2: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_SymDifference(arg1: OGRGeometryH, arg2: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_Distance(arg1: OGRGeometryH, arg2: OGRGeometryH) -> f64;
}
extern "C" {
    pub fn OGR_G_Distance3D(arg1: OGRGeometryH, arg2: OGRGeometryH) -> f64;
}
extern "C" {
    pub fn OGR_G_Length(arg1: OGRGeometryH) -> f64;
}
extern "C" {
    pub fn OGR_G_Area(arg1: OGRGeometryH) -> f64;
}
extern "C" {
    pub fn OGR_G_Centroid(arg1: OGRGeometryH, arg2: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_Value(arg1: OGRGeometryH, dfDistance: f64) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_Empty(arg1: OGRGeometryH);
}
extern "C" {
    pub fn OGR_G_IsEmpty(arg1: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_IsValid(arg1: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_MakeValid(arg1: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_IsSimple(arg1: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_IsRing(arg1: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_Polygonize(arg1: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_Intersect(arg1: OGRGeometryH, arg2: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_Equal(arg1: OGRGeometryH, arg2: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_SymmetricDifference(arg1: OGRGeometryH, arg2: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_GetArea(arg1: OGRGeometryH) -> f64;
}
extern "C" {
    pub fn OGR_G_GetBoundary(arg1: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_GetPointCount(arg1: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_GetPoints(
        hGeom: OGRGeometryH,
        pabyX: *mut libc::c_void,
        nXStride: libc::c_int,
        pabyY: *mut libc::c_void,
        nYStride: libc::c_int,
        pabyZ: *mut libc::c_void,
        nZStride: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_GetPointsZM(
        hGeom: OGRGeometryH,
        pabyX: *mut libc::c_void,
        nXStride: libc::c_int,
        pabyY: *mut libc::c_void,
        nYStride: libc::c_int,
        pabyZ: *mut libc::c_void,
        nZStride: libc::c_int,
        pabyM: *mut libc::c_void,
        nMStride: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_GetX(arg1: OGRGeometryH, arg2: libc::c_int) -> f64;
}
extern "C" {
    pub fn OGR_G_GetY(arg1: OGRGeometryH, arg2: libc::c_int) -> f64;
}
extern "C" {
    pub fn OGR_G_GetZ(arg1: OGRGeometryH, arg2: libc::c_int) -> f64;
}
extern "C" {
    pub fn OGR_G_GetM(arg1: OGRGeometryH, arg2: libc::c_int) -> f64;
}
extern "C" {
    pub fn OGR_G_GetPoint(
        arg1: OGRGeometryH,
        iPoint: libc::c_int,
        arg2: *mut f64,
        arg3: *mut f64,
        arg4: *mut f64,
    );
}
extern "C" {
    pub fn OGR_G_GetPointZM(
        arg1: OGRGeometryH,
        iPoint: libc::c_int,
        arg2: *mut f64,
        arg3: *mut f64,
        arg4: *mut f64,
        arg5: *mut f64,
    );
}
extern "C" {
    pub fn OGR_G_SetPointCount(hGeom: OGRGeometryH, nNewPointCount: libc::c_int);
}
extern "C" {
    pub fn OGR_G_SetPoint(arg1: OGRGeometryH, iPoint: libc::c_int, arg2: f64, arg3: f64, arg4: f64);
}
extern "C" {
    pub fn OGR_G_SetPoint_2D(arg1: OGRGeometryH, iPoint: libc::c_int, arg2: f64, arg3: f64);
}
extern "C" {
    pub fn OGR_G_SetPointM(
        arg1: OGRGeometryH,
        iPoint: libc::c_int,
        arg2: f64,
        arg3: f64,
        arg4: f64,
    );
}
extern "C" {
    pub fn OGR_G_SetPointZM(
        arg1: OGRGeometryH,
        iPoint: libc::c_int,
        arg2: f64,
        arg3: f64,
        arg4: f64,
        arg5: f64,
    );
}
extern "C" {
    pub fn OGR_G_AddPoint(arg1: OGRGeometryH, arg2: f64, arg3: f64, arg4: f64);
}
extern "C" {
    pub fn OGR_G_AddPoint_2D(arg1: OGRGeometryH, arg2: f64, arg3: f64);
}
extern "C" {
    pub fn OGR_G_AddPointM(arg1: OGRGeometryH, arg2: f64, arg3: f64, arg4: f64);
}
extern "C" {
    pub fn OGR_G_AddPointZM(arg1: OGRGeometryH, arg2: f64, arg3: f64, arg4: f64, arg5: f64);
}
extern "C" {
    pub fn OGR_G_SetPoints(
        hGeom: OGRGeometryH,
        nPointsIn: libc::c_int,
        pabyX: *const libc::c_void,
        nXStride: libc::c_int,
        pabyY: *const libc::c_void,
        nYStride: libc::c_int,
        pabyZ: *const libc::c_void,
        nZStride: libc::c_int,
    );
}
extern "C" {
    pub fn OGR_G_SetPointsZM(
        hGeom: OGRGeometryH,
        nPointsIn: libc::c_int,
        pabyX: *const libc::c_void,
        nXStride: libc::c_int,
        pabyY: *const libc::c_void,
        nYStride: libc::c_int,
        pabyZ: *const libc::c_void,
        nZStride: libc::c_int,
        pabyM: *const libc::c_void,
        nMStride: libc::c_int,
    );
}
extern "C" {
    pub fn OGR_G_SwapXY(hGeom: OGRGeometryH);
}
extern "C" {
    pub fn OGR_G_GetGeometryCount(arg1: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_GetGeometryRef(arg1: OGRGeometryH, arg2: libc::c_int) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_AddGeometry(arg1: OGRGeometryH, arg2: OGRGeometryH) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_G_AddGeometryDirectly(arg1: OGRGeometryH, arg2: OGRGeometryH) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_G_RemoveGeometry(
        arg1: OGRGeometryH,
        arg2: libc::c_int,
        arg3: libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_G_HasCurveGeometry(
        arg1: OGRGeometryH,
        bLookForNonLinear: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_GetLinearGeometry(
        hGeom: OGRGeometryH,
        dfMaxAngleStepSizeDegrees: f64,
        papszOptions: *mut *mut libc::c_char,
    ) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_GetCurveGeometry(
        hGeom: OGRGeometryH,
        papszOptions: *mut *mut libc::c_char,
    ) -> OGRGeometryH;
}
extern "C" {
    pub fn OGRBuildPolygonFromEdges(
        hLinesAsCollection: OGRGeometryH,
        bBestEffort: libc::c_int,
        bAutoClose: libc::c_int,
        dfTolerance: f64,
        peErr: *mut OGRErr::Type,
    ) -> OGRGeometryH;
}
extern "C" {
    pub fn OGRSetGenerate_DB2_V72_BYTE_ORDER(
        bGenerate_DB2_V72_BYTE_ORDER: libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGRGetGenerate_DB2_V72_BYTE_ORDER() -> libc::c_int;
}
extern "C" {
    pub fn OGRSetNonLinearGeometriesEnabledFlag(bFlag: libc::c_int);
}
extern "C" {
    pub fn OGRGetNonLinearGeometriesEnabledFlag() -> libc::c_int;
}
pub type OGRFieldDefnH = *mut libc::c_void;
pub type OGRFeatureDefnH = *mut libc::c_void;
pub type OGRFeatureH = *mut libc::c_void;
pub type OGRStyleTableH = *mut libc::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OGRGeomFieldDefnHS {
    _unused: [u8; 0],
}
pub type OGRGeomFieldDefnH = *mut OGRGeomFieldDefnHS;
extern "C" {
    pub fn OGR_Fld_Create(arg1: *const libc::c_char, arg2: OGRFieldType::Type) -> OGRFieldDefnH;
}
extern "C" {
    pub fn OGR_Fld_Destroy(arg1: OGRFieldDefnH);
}
extern "C" {
    pub fn OGR_Fld_SetName(arg1: OGRFieldDefnH, arg2: *const libc::c_char);
}
extern "C" {
    pub fn OGR_Fld_GetNameRef(arg1: OGRFieldDefnH) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_Fld_SetAlternativeName(arg1: OGRFieldDefnH, arg2: *const libc::c_char);
}
extern "C" {
    pub fn OGR_Fld_GetAlternativeNameRef(arg1: OGRFieldDefnH) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_Fld_GetType(arg1: OGRFieldDefnH) -> OGRFieldType::Type;
}
extern "C" {
    pub fn OGR_Fld_SetType(arg1: OGRFieldDefnH, arg2: OGRFieldType::Type);
}
extern "C" {
    pub fn OGR_Fld_GetSubType(arg1: OGRFieldDefnH) -> OGRFieldSubType::Type;
}
extern "C" {
    pub fn OGR_Fld_SetSubType(arg1: OGRFieldDefnH, arg2: OGRFieldSubType::Type);
}
extern "C" {
    pub fn OGR_Fld_GetJustify(arg1: OGRFieldDefnH) -> OGRJustification::Type;
}
extern "C" {
    pub fn OGR_Fld_SetJustify(arg1: OGRFieldDefnH, arg2: OGRJustification::Type);
}
extern "C" {
    pub fn OGR_Fld_GetWidth(arg1: OGRFieldDefnH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_Fld_SetWidth(arg1: OGRFieldDefnH, arg2: libc::c_int);
}
extern "C" {
    pub fn OGR_Fld_GetPrecision(arg1: OGRFieldDefnH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_Fld_SetPrecision(arg1: OGRFieldDefnH, arg2: libc::c_int);
}
extern "C" {
    pub fn OGR_Fld_Set(
        arg1: OGRFieldDefnH,
        arg2: *const libc::c_char,
        arg3: OGRFieldType::Type,
        arg4: libc::c_int,
        arg5: libc::c_int,
        arg6: OGRJustification::Type,
    );
}
extern "C" {
    pub fn OGR_Fld_IsIgnored(hDefn: OGRFieldDefnH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_Fld_SetIgnored(hDefn: OGRFieldDefnH, arg1: libc::c_int);
}
extern "C" {
    pub fn OGR_Fld_IsNullable(hDefn: OGRFieldDefnH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_Fld_SetNullable(hDefn: OGRFieldDefnH, arg1: libc::c_int);
}
extern "C" {
    pub fn OGR_Fld_IsUnique(hDefn: OGRFieldDefnH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_Fld_SetUnique(hDefn: OGRFieldDefnH, arg1: libc::c_int);
}
extern "C" {
    pub fn OGR_Fld_GetDefault(hDefn: OGRFieldDefnH) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_Fld_SetDefault(hDefn: OGRFieldDefnH, arg1: *const libc::c_char);
}
extern "C" {
    pub fn OGR_Fld_IsDefaultDriverSpecific(hDefn: OGRFieldDefnH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_GetFieldTypeName(arg1: OGRFieldType::Type) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_GetFieldSubTypeName(arg1: OGRFieldSubType::Type) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_AreTypeSubTypeCompatible(
        eType: OGRFieldType::Type,
        eSubType: OGRFieldSubType::Type,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OGR_GFld_Create(
        arg1: *const libc::c_char,
        arg2: OGRwkbGeometryType::Type,
    ) -> OGRGeomFieldDefnH;
}
extern "C" {
    pub fn OGR_GFld_Destroy(arg1: OGRGeomFieldDefnH);
}
extern "C" {
    pub fn OGR_GFld_SetName(arg1: OGRGeomFieldDefnH, arg2: *const libc::c_char);
}
extern "C" {
    pub fn OGR_GFld_GetNameRef(arg1: OGRGeomFieldDefnH) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_GFld_GetType(arg1: OGRGeomFieldDefnH) -> OGRwkbGeometryType::Type;
}
extern "C" {
    pub fn OGR_GFld_SetType(arg1: OGRGeomFieldDefnH, arg2: OGRwkbGeometryType::Type);
}
extern "C" {
    pub fn OGR_GFld_GetSpatialRef(arg1: OGRGeomFieldDefnH) -> OGRSpatialReferenceH;
}
extern "C" {
    pub fn OGR_GFld_SetSpatialRef(arg1: OGRGeomFieldDefnH, hSRS: OGRSpatialReferenceH);
}
extern "C" {
    pub fn OGR_GFld_IsNullable(hDefn: OGRGeomFieldDefnH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_GFld_SetNullable(hDefn: OGRGeomFieldDefnH, arg1: libc::c_int);
}
extern "C" {
    pub fn OGR_GFld_IsIgnored(hDefn: OGRGeomFieldDefnH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_GFld_SetIgnored(hDefn: OGRGeomFieldDefnH, arg1: libc::c_int);
}
extern "C" {
    pub fn OGR_FD_Create(arg1: *const libc::c_char) -> OGRFeatureDefnH;
}
extern "C" {
    pub fn OGR_FD_Destroy(arg1: OGRFeatureDefnH);
}
extern "C" {
    pub fn OGR_FD_Release(arg1: OGRFeatureDefnH);
}
extern "C" {
    pub fn OGR_FD_GetName(arg1: OGRFeatureDefnH) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_FD_GetFieldCount(arg1: OGRFeatureDefnH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_FD_GetFieldDefn(arg1: OGRFeatureDefnH, arg2: libc::c_int) -> OGRFieldDefnH;
}
extern "C" {
    pub fn OGR_FD_GetFieldIndex(arg1: OGRFeatureDefnH, arg2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn OGR_FD_AddFieldDefn(arg1: OGRFeatureDefnH, arg2: OGRFieldDefnH);
}
extern "C" {
    pub fn OGR_FD_DeleteFieldDefn(hDefn: OGRFeatureDefnH, iField: libc::c_int) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_FD_ReorderFieldDefns(
        hDefn: OGRFeatureDefnH,
        panMap: *mut libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_FD_GetGeomType(arg1: OGRFeatureDefnH) -> OGRwkbGeometryType::Type;
}
extern "C" {
    pub fn OGR_FD_SetGeomType(arg1: OGRFeatureDefnH, arg2: OGRwkbGeometryType::Type);
}
extern "C" {
    pub fn OGR_FD_IsGeometryIgnored(arg1: OGRFeatureDefnH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_FD_SetGeometryIgnored(arg1: OGRFeatureDefnH, arg2: libc::c_int);
}
extern "C" {
    pub fn OGR_FD_IsStyleIgnored(arg1: OGRFeatureDefnH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_FD_SetStyleIgnored(arg1: OGRFeatureDefnH, arg2: libc::c_int);
}
extern "C" {
    pub fn OGR_FD_Reference(arg1: OGRFeatureDefnH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_FD_Dereference(arg1: OGRFeatureDefnH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_FD_GetReferenceCount(arg1: OGRFeatureDefnH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_FD_GetGeomFieldCount(hFDefn: OGRFeatureDefnH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_FD_GetGeomFieldDefn(hFDefn: OGRFeatureDefnH, i: libc::c_int) -> OGRGeomFieldDefnH;
}
extern "C" {
    pub fn OGR_FD_GetGeomFieldIndex(
        hFDefn: OGRFeatureDefnH,
        pszName: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OGR_FD_AddGeomFieldDefn(hFDefn: OGRFeatureDefnH, hGFldDefn: OGRGeomFieldDefnH);
}
extern "C" {
    pub fn OGR_FD_DeleteGeomFieldDefn(
        hFDefn: OGRFeatureDefnH,
        iGeomField: libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_FD_IsSame(hFDefn: OGRFeatureDefnH, hOtherFDefn: OGRFeatureDefnH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_F_Create(arg1: OGRFeatureDefnH) -> OGRFeatureH;
}
extern "C" {
    pub fn OGR_F_Destroy(arg1: OGRFeatureH);
}
extern "C" {
    pub fn OGR_F_GetDefnRef(arg1: OGRFeatureH) -> OGRFeatureDefnH;
}
extern "C" {
    pub fn OGR_F_SetGeometryDirectly(arg1: OGRFeatureH, arg2: OGRGeometryH) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_F_SetGeometry(arg1: OGRFeatureH, arg2: OGRGeometryH) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_F_GetGeometryRef(arg1: OGRFeatureH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_F_StealGeometry(arg1: OGRFeatureH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_F_Clone(arg1: OGRFeatureH) -> OGRFeatureH;
}
extern "C" {
    pub fn OGR_F_Equal(arg1: OGRFeatureH, arg2: OGRFeatureH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_F_GetFieldCount(arg1: OGRFeatureH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_F_GetFieldDefnRef(arg1: OGRFeatureH, arg2: libc::c_int) -> OGRFieldDefnH;
}
extern "C" {
    pub fn OGR_F_GetFieldIndex(arg1: OGRFeatureH, arg2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn OGR_F_IsFieldSet(arg1: OGRFeatureH, arg2: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn OGR_F_UnsetField(arg1: OGRFeatureH, arg2: libc::c_int);
}
extern "C" {
    pub fn OGR_F_IsFieldNull(arg1: OGRFeatureH, arg2: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn OGR_F_IsFieldSetAndNotNull(arg1: OGRFeatureH, arg2: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn OGR_F_SetFieldNull(arg1: OGRFeatureH, arg2: libc::c_int);
}
extern "C" {
    pub fn OGR_F_GetRawFieldRef(arg1: OGRFeatureH, arg2: libc::c_int) -> *mut OGRField;
}
extern "C" {
    pub fn OGR_RawField_IsUnset(arg1: *const OGRField) -> libc::c_int;
}
extern "C" {
    pub fn OGR_RawField_IsNull(arg1: *const OGRField) -> libc::c_int;
}
extern "C" {
    pub fn OGR_RawField_SetUnset(arg1: *mut OGRField);
}
extern "C" {
    pub fn OGR_RawField_SetNull(arg1: *mut OGRField);
}
extern "C" {
    pub fn OGR_F_GetFieldAsInteger(arg1: OGRFeatureH, arg2: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn OGR_F_GetFieldAsInteger64(arg1: OGRFeatureH, arg2: libc::c_int) -> GIntBig;
}
extern "C" {
    pub fn OGR_F_GetFieldAsDouble(arg1: OGRFeatureH, arg2: libc::c_int) -> f64;
}
extern "C" {
    pub fn OGR_F_GetFieldAsString(arg1: OGRFeatureH, arg2: libc::c_int) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_F_GetFieldAsIntegerList(
        arg1: OGRFeatureH,
        arg2: libc::c_int,
        arg3: *mut libc::c_int,
    ) -> *const libc::c_int;
}
extern "C" {
    pub fn OGR_F_GetFieldAsInteger64List(
        arg1: OGRFeatureH,
        arg2: libc::c_int,
        arg3: *mut libc::c_int,
    ) -> *const GIntBig;
}
extern "C" {
    pub fn OGR_F_GetFieldAsDoubleList(
        arg1: OGRFeatureH,
        arg2: libc::c_int,
        arg3: *mut libc::c_int,
    ) -> *const f64;
}
extern "C" {
    pub fn OGR_F_GetFieldAsStringList(
        arg1: OGRFeatureH,
        arg2: libc::c_int,
    ) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn OGR_F_GetFieldAsBinary(
        arg1: OGRFeatureH,
        arg2: libc::c_int,
        arg3: *mut libc::c_int,
    ) -> *mut GByte;
}
extern "C" {
    pub fn OGR_F_GetFieldAsDateTime(
        arg1: OGRFeatureH,
        arg2: libc::c_int,
        arg3: *mut libc::c_int,
        arg4: *mut libc::c_int,
        arg5: *mut libc::c_int,
        arg6: *mut libc::c_int,
        arg7: *mut libc::c_int,
        arg8: *mut libc::c_int,
        arg9: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OGR_F_GetFieldAsDateTimeEx(
        hFeat: OGRFeatureH,
        iField: libc::c_int,
        pnYear: *mut libc::c_int,
        pnMonth: *mut libc::c_int,
        pnDay: *mut libc::c_int,
        pnHour: *mut libc::c_int,
        pnMinute: *mut libc::c_int,
        pfSecond: *mut f32,
        pnTZFlag: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OGR_F_SetFieldInteger(arg1: OGRFeatureH, arg2: libc::c_int, arg3: libc::c_int);
}
extern "C" {
    pub fn OGR_F_SetFieldInteger64(arg1: OGRFeatureH, arg2: libc::c_int, arg3: GIntBig);
}
extern "C" {
    pub fn OGR_F_SetFieldDouble(arg1: OGRFeatureH, arg2: libc::c_int, arg3: f64);
}
extern "C" {
    pub fn OGR_F_SetFieldString(arg1: OGRFeatureH, arg2: libc::c_int, arg3: *const libc::c_char);
}
extern "C" {
    pub fn OGR_F_SetFieldIntegerList(
        arg1: OGRFeatureH,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: *const libc::c_int,
    );
}
extern "C" {
    pub fn OGR_F_SetFieldInteger64List(
        arg1: OGRFeatureH,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: *const GIntBig,
    );
}
extern "C" {
    pub fn OGR_F_SetFieldDoubleList(
        arg1: OGRFeatureH,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: *const f64,
    );
}
extern "C" {
    pub fn OGR_F_SetFieldStringList(arg1: OGRFeatureH, arg2: libc::c_int, arg3: CSLConstList);
}
extern "C" {
    pub fn OGR_F_SetFieldRaw(arg1: OGRFeatureH, arg2: libc::c_int, arg3: *mut OGRField);
}
extern "C" {
    pub fn OGR_F_SetFieldBinary(
        arg1: OGRFeatureH,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: *const libc::c_void,
    );
}
extern "C" {
    pub fn OGR_F_SetFieldDateTime(
        arg1: OGRFeatureH,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: libc::c_int,
        arg5: libc::c_int,
        arg6: libc::c_int,
        arg7: libc::c_int,
        arg8: libc::c_int,
        arg9: libc::c_int,
    );
}
extern "C" {
    pub fn OGR_F_SetFieldDateTimeEx(
        arg1: OGRFeatureH,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: libc::c_int,
        arg5: libc::c_int,
        arg6: libc::c_int,
        arg7: libc::c_int,
        arg8: f32,
        arg9: libc::c_int,
    );
}
extern "C" {
    pub fn OGR_F_GetGeomFieldCount(hFeat: OGRFeatureH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_F_GetGeomFieldDefnRef(hFeat: OGRFeatureH, iField: libc::c_int) -> OGRGeomFieldDefnH;
}
extern "C" {
    pub fn OGR_F_GetGeomFieldIndex(hFeat: OGRFeatureH, pszName: *const libc::c_char)
        -> libc::c_int;
}
extern "C" {
    pub fn OGR_F_GetGeomFieldRef(hFeat: OGRFeatureH, iField: libc::c_int) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_F_SetGeomFieldDirectly(
        hFeat: OGRFeatureH,
        iField: libc::c_int,
        hGeom: OGRGeometryH,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_F_SetGeomField(
        hFeat: OGRFeatureH,
        iField: libc::c_int,
        hGeom: OGRGeometryH,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_F_GetFID(arg1: OGRFeatureH) -> GIntBig;
}
extern "C" {
    pub fn OGR_F_SetFID(arg1: OGRFeatureH, arg2: GIntBig) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_F_DumpReadable(arg1: OGRFeatureH, arg2: *mut FILE);
}
extern "C" {
    pub fn OGR_F_SetFrom(arg1: OGRFeatureH, arg2: OGRFeatureH, arg3: libc::c_int) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_F_SetFromWithMap(
        arg1: OGRFeatureH,
        arg2: OGRFeatureH,
        arg3: libc::c_int,
        arg4: *const libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_F_GetStyleString(arg1: OGRFeatureH) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_F_SetStyleString(arg1: OGRFeatureH, arg2: *const libc::c_char);
}
extern "C" {
    pub fn OGR_F_SetStyleStringDirectly(arg1: OGRFeatureH, arg2: *mut libc::c_char);
}
extern "C" {
    pub fn OGR_F_GetStyleTable(arg1: OGRFeatureH) -> OGRStyleTableH;
}
extern "C" {
    pub fn OGR_F_SetStyleTableDirectly(arg1: OGRFeatureH, arg2: OGRStyleTableH);
}
extern "C" {
    pub fn OGR_F_SetStyleTable(arg1: OGRFeatureH, arg2: OGRStyleTableH);
}
extern "C" {
    pub fn OGR_F_GetNativeData(arg1: OGRFeatureH) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_F_SetNativeData(arg1: OGRFeatureH, arg2: *const libc::c_char);
}
extern "C" {
    pub fn OGR_F_GetNativeMediaType(arg1: OGRFeatureH) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_F_SetNativeMediaType(arg1: OGRFeatureH, arg2: *const libc::c_char);
}
extern "C" {
    pub fn OGR_F_FillUnsetWithDefault(
        hFeat: OGRFeatureH,
        bNotNullableOnly: libc::c_int,
        papszOptions: *mut *mut libc::c_char,
    );
}
extern "C" {
    pub fn OGR_F_Validate(
        arg1: OGRFeatureH,
        nValidateFlags: libc::c_int,
        bEmitError: libc::c_int,
    ) -> libc::c_int;
}
pub type OGRLayerH = *mut libc::c_void;
pub type OGRDataSourceH = *mut libc::c_void;
pub type OGRSFDriverH = *mut libc::c_void;
extern "C" {
    pub fn OGR_L_GetName(arg1: OGRLayerH) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_L_GetGeomType(arg1: OGRLayerH) -> OGRwkbGeometryType::Type;
}
extern "C" {
    pub fn OGR_L_GetSpatialFilter(arg1: OGRLayerH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_L_SetSpatialFilter(arg1: OGRLayerH, arg2: OGRGeometryH);
}
extern "C" {
    pub fn OGR_L_SetSpatialFilterRect(arg1: OGRLayerH, arg2: f64, arg3: f64, arg4: f64, arg5: f64);
}
extern "C" {
    pub fn OGR_L_SetSpatialFilterEx(arg1: OGRLayerH, iGeomField: libc::c_int, hGeom: OGRGeometryH);
}
extern "C" {
    pub fn OGR_L_SetSpatialFilterRectEx(
        arg1: OGRLayerH,
        iGeomField: libc::c_int,
        dfMinX: f64,
        dfMinY: f64,
        dfMaxX: f64,
        dfMaxY: f64,
    );
}
extern "C" {
    pub fn OGR_L_SetAttributeFilter(arg1: OGRLayerH, arg2: *const libc::c_char) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_ResetReading(arg1: OGRLayerH);
}
extern "C" {
    pub fn OGR_L_GetNextFeature(arg1: OGRLayerH) -> OGRFeatureH;
}
extern "C" {
    pub fn OGR_L_SetNextByIndex(arg1: OGRLayerH, arg2: GIntBig) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_GetFeature(arg1: OGRLayerH, arg2: GIntBig) -> OGRFeatureH;
}
extern "C" {
    pub fn OGR_L_SetFeature(arg1: OGRLayerH, arg2: OGRFeatureH) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_CreateFeature(arg1: OGRLayerH, arg2: OGRFeatureH) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_DeleteFeature(arg1: OGRLayerH, arg2: GIntBig) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_GetLayerDefn(arg1: OGRLayerH) -> OGRFeatureDefnH;
}
extern "C" {
    pub fn OGR_L_GetSpatialRef(arg1: OGRLayerH) -> OGRSpatialReferenceH;
}
extern "C" {
    pub fn OGR_L_FindFieldIndex(
        arg1: OGRLayerH,
        arg2: *const libc::c_char,
        bExactMatch: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OGR_L_GetFeatureCount(arg1: OGRLayerH, arg2: libc::c_int) -> GIntBig;
}
extern "C" {
    pub fn OGR_L_GetExtent(
        arg1: OGRLayerH,
        arg2: *mut OGREnvelope,
        arg3: libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_GetExtentEx(
        arg1: OGRLayerH,
        iGeomField: libc::c_int,
        psExtent: *mut OGREnvelope,
        bForce: libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_TestCapability(arg1: OGRLayerH, arg2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn OGR_L_CreateField(
        arg1: OGRLayerH,
        arg2: OGRFieldDefnH,
        arg3: libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_CreateGeomField(
        hLayer: OGRLayerH,
        hFieldDefn: OGRGeomFieldDefnH,
        bForce: libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_DeleteField(arg1: OGRLayerH, iField: libc::c_int) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_ReorderFields(arg1: OGRLayerH, panMap: *mut libc::c_int) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_ReorderField(
        arg1: OGRLayerH,
        iOldFieldPos: libc::c_int,
        iNewFieldPos: libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_AlterFieldDefn(
        arg1: OGRLayerH,
        iField: libc::c_int,
        hNewFieldDefn: OGRFieldDefnH,
        nFlags: libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_StartTransaction(arg1: OGRLayerH) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_CommitTransaction(arg1: OGRLayerH) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_RollbackTransaction(arg1: OGRLayerH) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_Reference(arg1: OGRLayerH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_L_Dereference(arg1: OGRLayerH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_L_GetRefCount(arg1: OGRLayerH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_L_SyncToDisk(arg1: OGRLayerH) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_GetFeaturesRead(arg1: OGRLayerH) -> GIntBig;
}
extern "C" {
    pub fn OGR_L_GetFIDColumn(arg1: OGRLayerH) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_L_GetGeometryColumn(arg1: OGRLayerH) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_L_GetStyleTable(arg1: OGRLayerH) -> OGRStyleTableH;
}
extern "C" {
    pub fn OGR_L_SetStyleTableDirectly(arg1: OGRLayerH, arg2: OGRStyleTableH);
}
extern "C" {
    pub fn OGR_L_SetStyleTable(arg1: OGRLayerH, arg2: OGRStyleTableH);
}
extern "C" {
    pub fn OGR_L_SetIgnoredFields(arg1: OGRLayerH, arg2: *mut *const libc::c_char) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_Intersection(
        arg1: OGRLayerH,
        arg2: OGRLayerH,
        arg3: OGRLayerH,
        arg4: *mut *mut libc::c_char,
        arg5: GDALProgressFunc,
        arg6: *mut libc::c_void,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_Union(
        arg1: OGRLayerH,
        arg2: OGRLayerH,
        arg3: OGRLayerH,
        arg4: *mut *mut libc::c_char,
        arg5: GDALProgressFunc,
        arg6: *mut libc::c_void,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_SymDifference(
        arg1: OGRLayerH,
        arg2: OGRLayerH,
        arg3: OGRLayerH,
        arg4: *mut *mut libc::c_char,
        arg5: GDALProgressFunc,
        arg6: *mut libc::c_void,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_Identity(
        arg1: OGRLayerH,
        arg2: OGRLayerH,
        arg3: OGRLayerH,
        arg4: *mut *mut libc::c_char,
        arg5: GDALProgressFunc,
        arg6: *mut libc::c_void,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_Update(
        arg1: OGRLayerH,
        arg2: OGRLayerH,
        arg3: OGRLayerH,
        arg4: *mut *mut libc::c_char,
        arg5: GDALProgressFunc,
        arg6: *mut libc::c_void,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_Clip(
        arg1: OGRLayerH,
        arg2: OGRLayerH,
        arg3: OGRLayerH,
        arg4: *mut *mut libc::c_char,
        arg5: GDALProgressFunc,
        arg6: *mut libc::c_void,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_Erase(
        arg1: OGRLayerH,
        arg2: OGRLayerH,
        arg3: OGRLayerH,
        arg4: *mut *mut libc::c_char,
        arg5: GDALProgressFunc,
        arg6: *mut libc::c_void,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_DS_Destroy(arg1: OGRDataSourceH);
}
extern "C" {
    pub fn OGR_DS_GetName(arg1: OGRDataSourceH) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_DS_GetLayerCount(arg1: OGRDataSourceH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_DS_GetLayer(arg1: OGRDataSourceH, arg2: libc::c_int) -> OGRLayerH;
}
extern "C" {
    pub fn OGR_DS_GetLayerByName(arg1: OGRDataSourceH, arg2: *const libc::c_char) -> OGRLayerH;
}
extern "C" {
    pub fn OGR_DS_DeleteLayer(arg1: OGRDataSourceH, arg2: libc::c_int) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_DS_GetDriver(arg1: OGRDataSourceH) -> OGRSFDriverH;
}
extern "C" {
    pub fn OGR_DS_CreateLayer(
        arg1: OGRDataSourceH,
        arg2: *const libc::c_char,
        arg3: OGRSpatialReferenceH,
        arg4: OGRwkbGeometryType::Type,
        arg5: *mut *mut libc::c_char,
    ) -> OGRLayerH;
}
extern "C" {
    pub fn OGR_DS_CopyLayer(
        arg1: OGRDataSourceH,
        arg2: OGRLayerH,
        arg3: *const libc::c_char,
        arg4: *mut *mut libc::c_char,
    ) -> OGRLayerH;
}
extern "C" {
    pub fn OGR_DS_TestCapability(arg1: OGRDataSourceH, arg2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn OGR_DS_ExecuteSQL(
        arg1: OGRDataSourceH,
        arg2: *const libc::c_char,
        arg3: OGRGeometryH,
        arg4: *const libc::c_char,
    ) -> OGRLayerH;
}
extern "C" {
    pub fn OGR_DS_ReleaseResultSet(arg1: OGRDataSourceH, arg2: OGRLayerH);
}
extern "C" {
    pub fn OGR_DS_Reference(arg1: OGRDataSourceH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_DS_Dereference(arg1: OGRDataSourceH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_DS_GetRefCount(arg1: OGRDataSourceH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_DS_GetSummaryRefCount(arg1: OGRDataSourceH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_DS_SyncToDisk(arg1: OGRDataSourceH) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_DS_GetStyleTable(arg1: OGRDataSourceH) -> OGRStyleTableH;
}
extern "C" {
    pub fn OGR_DS_SetStyleTableDirectly(arg1: OGRDataSourceH, arg2: OGRStyleTableH);
}
extern "C" {
    pub fn OGR_DS_SetStyleTable(arg1: OGRDataSourceH, arg2: OGRStyleTableH);
}
extern "C" {
    pub fn OGR_Dr_GetName(arg1: OGRSFDriverH) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_Dr_Open(
        arg1: OGRSFDriverH,
        arg2: *const libc::c_char,
        arg3: libc::c_int,
    ) -> OGRDataSourceH;
}
extern "C" {
    pub fn OGR_Dr_TestCapability(arg1: OGRSFDriverH, arg2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn OGR_Dr_CreateDataSource(
        arg1: OGRSFDriverH,
        arg2: *const libc::c_char,
        arg3: *mut *mut libc::c_char,
    ) -> OGRDataSourceH;
}
extern "C" {
    pub fn OGR_Dr_CopyDataSource(
        arg1: OGRSFDriverH,
        arg2: OGRDataSourceH,
        arg3: *const libc::c_char,
        arg4: *mut *mut libc::c_char,
    ) -> OGRDataSourceH;
}
extern "C" {
    pub fn OGR_Dr_DeleteDataSource(arg1: OGRSFDriverH, arg2: *const libc::c_char) -> OGRErr::Type;
}
extern "C" {
    pub fn OGROpen(
        arg1: *const libc::c_char,
        arg2: libc::c_int,
        arg3: *mut OGRSFDriverH,
    ) -> OGRDataSourceH;
}
extern "C" {
    pub fn OGROpenShared(
        arg1: *const libc::c_char,
        arg2: libc::c_int,
        arg3: *mut OGRSFDriverH,
    ) -> OGRDataSourceH;
}
extern "C" {
    pub fn OGRReleaseDataSource(arg1: OGRDataSourceH) -> OGRErr::Type;
}
extern "C" {
    pub fn OGRRegisterDriver(arg1: OGRSFDriverH);
}
extern "C" {
    pub fn OGRDeregisterDriver(arg1: OGRSFDriverH);
}
extern "C" {
    pub fn OGRGetDriverCount() -> libc::c_int;
}
extern "C" {
    pub fn OGRGetDriver(arg1: libc::c_int) -> OGRSFDriverH;
}
extern "C" {
    pub fn OGRGetDriverByName(arg1: *const libc::c_char) -> OGRSFDriverH;
}
extern "C" {
    pub fn OGRGetOpenDSCount() -> libc::c_int;
}
extern "C" {
    pub fn OGRGetOpenDS(iDS: libc::c_int) -> OGRDataSourceH;
}
extern "C" {
    pub fn OGRRegisterAll();
}
extern "C" {
    pub fn OGRCleanupAll();
}
pub type OGRStyleMgrH = *mut libc::c_void;
pub type OGRStyleToolH = *mut libc::c_void;
extern "C" {
    pub fn OGR_SM_Create(hStyleTable: OGRStyleTableH) -> OGRStyleMgrH;
}
extern "C" {
    pub fn OGR_SM_Destroy(hSM: OGRStyleMgrH);
}
extern "C" {
    pub fn OGR_SM_InitFromFeature(hSM: OGRStyleMgrH, hFeat: OGRFeatureH) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_SM_InitStyleString(
        hSM: OGRStyleMgrH,
        pszStyleString: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OGR_SM_GetPartCount(
        hSM: OGRStyleMgrH,
        pszStyleString: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OGR_SM_GetPart(
        hSM: OGRStyleMgrH,
        nPartId: libc::c_int,
        pszStyleString: *const libc::c_char,
    ) -> OGRStyleToolH;
}
extern "C" {
    pub fn OGR_SM_AddPart(hSM: OGRStyleMgrH, hST: OGRStyleToolH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_SM_AddStyle(
        hSM: OGRStyleMgrH,
        pszStyleName: *const libc::c_char,
        pszStyleString: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OGR_ST_Create(eClassId: OGRSTClassId) -> OGRStyleToolH;
}
extern "C" {
    pub fn OGR_ST_Destroy(hST: OGRStyleToolH);
}
extern "C" {
    pub fn OGR_ST_GetType(hST: OGRStyleToolH) -> OGRSTClassId;
}
extern "C" {
    pub fn OGR_ST_GetUnit(hST: OGRStyleToolH) -> OGRSTUnitId;
}
extern "C" {
    pub fn OGR_ST_SetUnit(hST: OGRStyleToolH, eUnit: OGRSTUnitId, dfGroundPaperScale: f64);
}
extern "C" {
    pub fn OGR_ST_GetParamStr(
        hST: OGRStyleToolH,
        eParam: libc::c_int,
        bValueIsNull: *mut libc::c_int,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_ST_GetParamNum(
        hST: OGRStyleToolH,
        eParam: libc::c_int,
        bValueIsNull: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OGR_ST_GetParamDbl(
        hST: OGRStyleToolH,
        eParam: libc::c_int,
        bValueIsNull: *mut libc::c_int,
    ) -> f64;
}
extern "C" {
    pub fn OGR_ST_SetParamStr(
        hST: OGRStyleToolH,
        eParam: libc::c_int,
        pszValue: *const libc::c_char,
    );
}
extern "C" {
    pub fn OGR_ST_SetParamNum(hST: OGRStyleToolH, eParam: libc::c_int, nValue: libc::c_int);
}
extern "C" {
    pub fn OGR_ST_SetParamDbl(hST: OGRStyleToolH, eParam: libc::c_int, dfValue: f64);
}
extern "C" {
    pub fn OGR_ST_GetStyleString(hST: OGRStyleToolH) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_ST_GetRGBFromString(
        hST: OGRStyleToolH,
        pszColor: *const libc::c_char,
        pnRed: *mut libc::c_int,
        pnGreen: *mut libc::c_int,
        pnBlue: *mut libc::c_int,
        pnAlpha: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OGR_STBL_Create() -> OGRStyleTableH;
}
extern "C" {
    pub fn OGR_STBL_Destroy(hSTBL: OGRStyleTableH);
}
extern "C" {
    pub fn OGR_STBL_AddStyle(
        hStyleTable: OGRStyleTableH,
        pszName: *const libc::c_char,
        pszStyleString: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OGR_STBL_SaveStyleTable(
        hStyleTable: OGRStyleTableH,
        pszFilename: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OGR_STBL_LoadStyleTable(
        hStyleTable: OGRStyleTableH,
        pszFilename: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OGR_STBL_Find(
        hStyleTable: OGRStyleTableH,
        pszName: *const libc::c_char,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_STBL_ResetStyleStringReading(hStyleTable: OGRStyleTableH);
}
extern "C" {
    pub fn OGR_STBL_GetNextStyle(hStyleTable: OGRStyleTableH) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_STBL_GetLastStyleName(hStyleTable: OGRStyleTableH) -> *const libc::c_char;
}
pub mod GDALDataType {
    pub type Type = libc::c_uint;
    pub const GDT_Unknown: Type = 0;
    pub const GDT_Byte: Type = 1;
    pub const GDT_UInt16: Type = 2;
    pub const GDT_Int16: Type = 3;
    pub const GDT_UInt32: Type = 4;
    pub const GDT_Int32: Type = 5;
    pub const GDT_Float32: Type = 6;
    pub const GDT_Float64: Type = 7;
    pub const GDT_CInt16: Type = 8;
    pub const GDT_CInt32: Type = 9;
    pub const GDT_CFloat32: Type = 10;
    pub const GDT_CFloat64: Type = 11;
    pub const GDT_TypeCount: Type = 12;
}
extern "C" {
    pub fn GDALGetDataTypeSize(arg1: GDALDataType::Type) -> libc::c_int;
}
extern "C" {
    pub fn GDALGetDataTypeSizeBits(eDataType: GDALDataType::Type) -> libc::c_int;
}
extern "C" {
    pub fn GDALGetDataTypeSizeBytes(arg1: GDALDataType::Type) -> libc::c_int;
}
extern "C" {
    pub fn GDALDataTypeIsComplex(arg1: GDALDataType::Type) -> libc::c_int;
}
extern "C" {
    pub fn GDALDataTypeIsInteger(arg1: GDALDataType::Type) -> libc::c_int;
}
extern "C" {
    pub fn GDALDataTypeIsFloating(arg1: GDALDataType::Type) -> libc::c_int;
}
extern "C" {
    pub fn GDALDataTypeIsSigned(arg1: GDALDataType::Type) -> libc::c_int;
}
extern "C" {
    pub fn GDALGetDataTypeName(arg1: GDALDataType::Type) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALGetDataTypeByName(arg1: *const libc::c_char) -> GDALDataType::Type;
}
extern "C" {
    pub fn GDALDataTypeUnion(
        arg1: GDALDataType::Type,
        arg2: GDALDataType::Type,
    ) -> GDALDataType::Type;
}
extern "C" {
    pub fn GDALDataTypeUnionWithValue(
        eDT: GDALDataType::Type,
        dValue: f64,
        bComplex: libc::c_int,
    ) -> GDALDataType::Type;
}
extern "C" {
    pub fn GDALFindDataType(
        nBits: libc::c_int,
        bSigned: libc::c_int,
        bFloating: libc::c_int,
        bComplex: libc::c_int,
    ) -> GDALDataType::Type;
}
extern "C" {
    pub fn GDALFindDataTypeForValue(dValue: f64, bComplex: libc::c_int) -> GDALDataType::Type;
}
extern "C" {
    pub fn GDALAdjustValueToDataType(
        eDT: GDALDataType::Type,
        dfValue: f64,
        pbClamped: *mut libc::c_int,
        pbRounded: *mut libc::c_int,
    ) -> f64;
}
extern "C" {
    pub fn GDALGetNonComplexDataType(arg1: GDALDataType::Type) -> GDALDataType::Type;
}
extern "C" {
    pub fn GDALDataTypeIsConversionLossy(
        eTypeFrom: GDALDataType::Type,
        eTypeTo: GDALDataType::Type,
    ) -> libc::c_int;
}
pub mod GDALAsyncStatusType {
    pub type Type = libc::c_uint;
    pub const GARIO_PENDING: Type = 0;
    pub const GARIO_UPDATE: Type = 1;
    pub const GARIO_ERROR: Type = 2;
    pub const GARIO_COMPLETE: Type = 3;
    pub const GARIO_TypeCount: Type = 4;
}
extern "C" {
    pub fn GDALGetAsyncStatusTypeName(arg1: GDALAsyncStatusType::Type) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALGetAsyncStatusTypeByName(arg1: *const libc::c_char) -> GDALAsyncStatusType::Type;
}
pub mod GDALAccess {
    pub type Type = libc::c_uint;
    pub const GA_ReadOnly: Type = 0;
    pub const GA_Update: Type = 1;
}
pub mod GDALRWFlag {
    pub type Type = libc::c_uint;
    pub const GF_Read: Type = 0;
    pub const GF_Write: Type = 1;
}
pub mod GDALRIOResampleAlg {
    pub type Type = libc::c_uint;
    pub const GRIORA_NearestNeighbour: Type = 0;
    pub const GRIORA_Bilinear: Type = 1;
    pub const GRIORA_Cubic: Type = 2;
    pub const GRIORA_CubicSpline: Type = 3;
    pub const GRIORA_Lanczos: Type = 4;
    pub const GRIORA_Average: Type = 5;
    pub const GRIORA_Mode: Type = 6;
    pub const GRIORA_Gauss: Type = 7;
    pub const GRIORA_LAST: Type = 7;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALRasterIOExtraArg {
    pub nVersion: libc::c_int,
    pub eResampleAlg: GDALRIOResampleAlg::Type,
    pub pfnProgress: GDALProgressFunc,
    pub pProgressData: *mut libc::c_void,
    pub bFloatingPointWindowValidity: libc::c_int,
    pub dfXOff: f64,
    pub dfYOff: f64,
    pub dfXSize: f64,
    pub dfYSize: f64,
}
#[test]
fn bindgen_test_layout_GDALRasterIOExtraArg() {
    assert_eq!(
        ::std::mem::size_of::<GDALRasterIOExtraArg>(),
        64usize,
        concat!("Size of: ", stringify!(GDALRasterIOExtraArg))
    );
    assert_eq!(
        ::std::mem::align_of::<GDALRasterIOExtraArg>(),
        8usize,
        concat!("Alignment of ", stringify!(GDALRasterIOExtraArg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALRasterIOExtraArg>())).nVersion as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRasterIOExtraArg),
            "::",
            stringify!(nVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALRasterIOExtraArg>())).eResampleAlg as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRasterIOExtraArg),
            "::",
            stringify!(eResampleAlg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALRasterIOExtraArg>())).pfnProgress as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRasterIOExtraArg),
            "::",
            stringify!(pfnProgress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALRasterIOExtraArg>())).pProgressData as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRasterIOExtraArg),
            "::",
            stringify!(pProgressData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALRasterIOExtraArg>())).bFloatingPointWindowValidity
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRasterIOExtraArg),
            "::",
            stringify!(bFloatingPointWindowValidity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALRasterIOExtraArg>())).dfXOff as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRasterIOExtraArg),
            "::",
            stringify!(dfXOff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALRasterIOExtraArg>())).dfYOff as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRasterIOExtraArg),
            "::",
            stringify!(dfYOff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALRasterIOExtraArg>())).dfXSize as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRasterIOExtraArg),
            "::",
            stringify!(dfXSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALRasterIOExtraArg>())).dfYSize as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRasterIOExtraArg),
            "::",
            stringify!(dfYSize)
        )
    );
}
pub mod GDALColorInterp {
    pub type Type = libc::c_uint;
    pub const GCI_Undefined: Type = 0;
    pub const GCI_GrayIndex: Type = 1;
    pub const GCI_PaletteIndex: Type = 2;
    pub const GCI_RedBand: Type = 3;
    pub const GCI_GreenBand: Type = 4;
    pub const GCI_BlueBand: Type = 5;
    pub const GCI_AlphaBand: Type = 6;
    pub const GCI_HueBand: Type = 7;
    pub const GCI_SaturationBand: Type = 8;
    pub const GCI_LightnessBand: Type = 9;
    pub const GCI_CyanBand: Type = 10;
    pub const GCI_MagentaBand: Type = 11;
    pub const GCI_YellowBand: Type = 12;
    pub const GCI_BlackBand: Type = 13;
    pub const GCI_YCbCr_YBand: Type = 14;
    pub const GCI_YCbCr_CbBand: Type = 15;
    pub const GCI_YCbCr_CrBand: Type = 16;
    pub const GCI_Max: Type = 16;
}
extern "C" {
    pub fn GDALGetColorInterpretationName(arg1: GDALColorInterp::Type) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALGetColorInterpretationByName(pszName: *const libc::c_char) -> GDALColorInterp::Type;
}
pub mod GDALPaletteInterp {
    pub type Type = libc::c_uint;
    pub const GPI_Gray: Type = 0;
    pub const GPI_RGB: Type = 1;
    pub const GPI_CMYK: Type = 2;
    pub const GPI_HLS: Type = 3;
}
extern "C" {
    pub fn GDALGetPaletteInterpretationName(arg1: GDALPaletteInterp::Type) -> *const libc::c_char;
}
pub type GDALMajorObjectH = *mut libc::c_void;
pub type GDALDatasetH = *mut libc::c_void;
pub type GDALRasterBandH = *mut libc::c_void;
pub type GDALDriverH = *mut libc::c_void;
pub type GDALColorTableH = *mut libc::c_void;
pub type GDALRasterAttributeTableH = *mut libc::c_void;
pub type GDALAsyncReaderH = *mut libc::c_void;
pub type GSpacing = GIntBig;
pub mod GDALExtendedDataTypeClass {
    pub type Type = libc::c_uint;
    pub const GEDTC_NUMERIC: Type = 0;
    pub const GEDTC_STRING: Type = 1;
    pub const GEDTC_COMPOUND: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALExtendedDataTypeHS {
    _unused: [u8; 0],
}
pub type GDALExtendedDataTypeH = *mut GDALExtendedDataTypeHS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALEDTComponentHS {
    _unused: [u8; 0],
}
pub type GDALEDTComponentH = *mut GDALEDTComponentHS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALGroupHS {
    _unused: [u8; 0],
}
pub type GDALGroupH = *mut GDALGroupHS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALMDArrayHS {
    _unused: [u8; 0],
}
pub type GDALMDArrayH = *mut GDALMDArrayHS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALAttributeHS {
    _unused: [u8; 0],
}
pub type GDALAttributeH = *mut GDALAttributeHS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALDimensionHS {
    _unused: [u8; 0],
}
pub type GDALDimensionH = *mut GDALDimensionHS;
extern "C" {
    pub fn GDALAllRegister();
}
extern "C" {
    pub fn GDALCreate(
        hDriver: GDALDriverH,
        arg1: *const libc::c_char,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: libc::c_int,
        arg5: GDALDataType::Type,
        arg6: CSLConstList,
    ) -> GDALDatasetH;
}
extern "C" {
    pub fn GDALCreateCopy(
        arg1: GDALDriverH,
        arg2: *const libc::c_char,
        arg3: GDALDatasetH,
        arg4: libc::c_int,
        arg5: CSLConstList,
        arg6: GDALProgressFunc,
        arg7: *mut libc::c_void,
    ) -> GDALDatasetH;
}
extern "C" {
    pub fn GDALIdentifyDriver(
        pszFilename: *const libc::c_char,
        papszFileList: CSLConstList,
    ) -> GDALDriverH;
}
extern "C" {
    pub fn GDALIdentifyDriverEx(
        pszFilename: *const libc::c_char,
        nIdentifyFlags: libc::c_uint,
        papszAllowedDrivers: *const *const libc::c_char,
        papszFileList: *const *const libc::c_char,
    ) -> GDALDriverH;
}
extern "C" {
    pub fn GDALOpen(pszFilename: *const libc::c_char, eAccess: GDALAccess::Type) -> GDALDatasetH;
}
extern "C" {
    pub fn GDALOpenShared(arg1: *const libc::c_char, arg2: GDALAccess::Type) -> GDALDatasetH;
}
extern "C" {
    pub fn GDALOpenEx(
        pszFilename: *const libc::c_char,
        nOpenFlags: libc::c_uint,
        papszAllowedDrivers: *const *const libc::c_char,
        papszOpenOptions: *const *const libc::c_char,
        papszSiblingFiles: *const *const libc::c_char,
    ) -> GDALDatasetH;
}
extern "C" {
    pub fn GDALDumpOpenDatasets(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn GDALGetDriverByName(arg1: *const libc::c_char) -> GDALDriverH;
}
extern "C" {
    pub fn GDALGetDriverCount() -> libc::c_int;
}
extern "C" {
    pub fn GDALGetDriver(arg1: libc::c_int) -> GDALDriverH;
}
extern "C" {
    pub fn GDALCreateDriver() -> GDALDriverH;
}
extern "C" {
    pub fn GDALDestroyDriver(arg1: GDALDriverH);
}
extern "C" {
    pub fn GDALRegisterDriver(arg1: GDALDriverH) -> libc::c_int;
}
extern "C" {
    pub fn GDALDeregisterDriver(arg1: GDALDriverH);
}
extern "C" {
    pub fn GDALDestroyDriverManager();
}
extern "C" {
    pub fn GDALDestroy();
}
extern "C" {
    pub fn GDALDeleteDataset(arg1: GDALDriverH, arg2: *const libc::c_char) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRenameDataset(
        arg1: GDALDriverH,
        pszNewName: *const libc::c_char,
        pszOldName: *const libc::c_char,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALCopyDatasetFiles(
        arg1: GDALDriverH,
        pszNewName: *const libc::c_char,
        pszOldName: *const libc::c_char,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALValidateCreationOptions(
        arg1: GDALDriverH,
        papszCreationOptions: CSLConstList,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALGetDriverShortName(arg1: GDALDriverH) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALGetDriverLongName(arg1: GDALDriverH) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALGetDriverHelpTopic(arg1: GDALDriverH) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALGetDriverCreationOptionList(arg1: GDALDriverH) -> *const libc::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDAL_GCP {
    pub pszId: *mut libc::c_char,
    pub pszInfo: *mut libc::c_char,
    pub dfGCPPixel: f64,
    pub dfGCPLine: f64,
    pub dfGCPX: f64,
    pub dfGCPY: f64,
    pub dfGCPZ: f64,
}
#[test]
fn bindgen_test_layout_GDAL_GCP() {
    assert_eq!(
        ::std::mem::size_of::<GDAL_GCP>(),
        56usize,
        concat!("Size of: ", stringify!(GDAL_GCP))
    );
    assert_eq!(
        ::std::mem::align_of::<GDAL_GCP>(),
        8usize,
        concat!("Alignment of ", stringify!(GDAL_GCP))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDAL_GCP>())).pszId as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GDAL_GCP),
            "::",
            stringify!(pszId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDAL_GCP>())).pszInfo as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GDAL_GCP),
            "::",
            stringify!(pszInfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDAL_GCP>())).dfGCPPixel as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GDAL_GCP),
            "::",
            stringify!(dfGCPPixel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDAL_GCP>())).dfGCPLine as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GDAL_GCP),
            "::",
            stringify!(dfGCPLine)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDAL_GCP>())).dfGCPX as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GDAL_GCP),
            "::",
            stringify!(dfGCPX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDAL_GCP>())).dfGCPY as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(GDAL_GCP),
            "::",
            stringify!(dfGCPY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDAL_GCP>())).dfGCPZ as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(GDAL_GCP),
            "::",
            stringify!(dfGCPZ)
        )
    );
}
extern "C" {
    pub fn GDALInitGCPs(arg1: libc::c_int, arg2: *mut GDAL_GCP);
}
extern "C" {
    pub fn GDALDeinitGCPs(arg1: libc::c_int, arg2: *mut GDAL_GCP);
}
extern "C" {
    pub fn GDALDuplicateGCPs(arg1: libc::c_int, arg2: *const GDAL_GCP) -> *mut GDAL_GCP;
}
extern "C" {
    pub fn GDALGCPsToGeoTransform(
        nGCPCount: libc::c_int,
        pasGCPs: *const GDAL_GCP,
        padfGeoTransform: *mut f64,
        bApproxOK: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALInvGeoTransform(
        padfGeoTransformIn: *mut f64,
        padfInvGeoTransformOut: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALApplyGeoTransform(
        arg1: *mut f64,
        arg2: f64,
        arg3: f64,
        arg4: *mut f64,
        arg5: *mut f64,
    );
}
extern "C" {
    pub fn GDALComposeGeoTransforms(
        padfGeoTransform1: *const f64,
        padfGeoTransform2: *const f64,
        padfGeoTransformOut: *mut f64,
    );
}
extern "C" {
    pub fn GDALGetMetadataDomainList(hObject: GDALMajorObjectH) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn GDALGetMetadata(
        arg1: GDALMajorObjectH,
        arg2: *const libc::c_char,
    ) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn GDALSetMetadata(
        arg1: GDALMajorObjectH,
        arg2: CSLConstList,
        arg3: *const libc::c_char,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetMetadataItem(
        arg1: GDALMajorObjectH,
        arg2: *const libc::c_char,
        arg3: *const libc::c_char,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALSetMetadataItem(
        arg1: GDALMajorObjectH,
        arg2: *const libc::c_char,
        arg3: *const libc::c_char,
        arg4: *const libc::c_char,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetDescription(arg1: GDALMajorObjectH) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALSetDescription(arg1: GDALMajorObjectH, arg2: *const libc::c_char);
}
extern "C" {
    pub fn GDALGetDatasetDriver(arg1: GDALDatasetH) -> GDALDriverH;
}
extern "C" {
    pub fn GDALGetFileList(arg1: GDALDatasetH) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn GDALClose(arg1: GDALDatasetH);
}
extern "C" {
    pub fn GDALGetRasterXSize(arg1: GDALDatasetH) -> libc::c_int;
}
extern "C" {
    pub fn GDALGetRasterYSize(arg1: GDALDatasetH) -> libc::c_int;
}
extern "C" {
    pub fn GDALGetRasterCount(arg1: GDALDatasetH) -> libc::c_int;
}
extern "C" {
    pub fn GDALGetRasterBand(arg1: GDALDatasetH, arg2: libc::c_int) -> GDALRasterBandH;
}
extern "C" {
    pub fn GDALAddBand(
        hDS: GDALDatasetH,
        eType: GDALDataType::Type,
        papszOptions: CSLConstList,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALBeginAsyncReader(
        hDS: GDALDatasetH,
        nXOff: libc::c_int,
        nYOff: libc::c_int,
        nXSize: libc::c_int,
        nYSize: libc::c_int,
        pBuf: *mut libc::c_void,
        nBufXSize: libc::c_int,
        nBufYSize: libc::c_int,
        eBufType: GDALDataType::Type,
        nBandCount: libc::c_int,
        panBandMap: *mut libc::c_int,
        nPixelSpace: libc::c_int,
        nLineSpace: libc::c_int,
        nBandSpace: libc::c_int,
        papszOptions: CSLConstList,
    ) -> GDALAsyncReaderH;
}
extern "C" {
    pub fn GDALEndAsyncReader(hDS: GDALDatasetH, hAsynchReaderH: GDALAsyncReaderH);
}
extern "C" {
    pub fn GDALDatasetRasterIO(
        hDS: GDALDatasetH,
        eRWFlag: GDALRWFlag::Type,
        nDSXOff: libc::c_int,
        nDSYOff: libc::c_int,
        nDSXSize: libc::c_int,
        nDSYSize: libc::c_int,
        pBuffer: *mut libc::c_void,
        nBXSize: libc::c_int,
        nBYSize: libc::c_int,
        eBDataType: GDALDataType::Type,
        nBandCount: libc::c_int,
        panBandCount: *mut libc::c_int,
        nPixelSpace: libc::c_int,
        nLineSpace: libc::c_int,
        nBandSpace: libc::c_int,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALDatasetRasterIOEx(
        hDS: GDALDatasetH,
        eRWFlag: GDALRWFlag::Type,
        nDSXOff: libc::c_int,
        nDSYOff: libc::c_int,
        nDSXSize: libc::c_int,
        nDSYSize: libc::c_int,
        pBuffer: *mut libc::c_void,
        nBXSize: libc::c_int,
        nBYSize: libc::c_int,
        eBDataType: GDALDataType::Type,
        nBandCount: libc::c_int,
        panBandCount: *mut libc::c_int,
        nPixelSpace: GSpacing,
        nLineSpace: GSpacing,
        nBandSpace: GSpacing,
        psExtraArg: *mut GDALRasterIOExtraArg,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALDatasetAdviseRead(
        hDS: GDALDatasetH,
        nDSXOff: libc::c_int,
        nDSYOff: libc::c_int,
        nDSXSize: libc::c_int,
        nDSYSize: libc::c_int,
        nBXSize: libc::c_int,
        nBYSize: libc::c_int,
        eBDataType: GDALDataType::Type,
        nBandCount: libc::c_int,
        panBandCount: *mut libc::c_int,
        papszOptions: CSLConstList,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetProjectionRef(arg1: GDALDatasetH) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALGetSpatialRef(arg1: GDALDatasetH) -> OGRSpatialReferenceH;
}
extern "C" {
    pub fn GDALSetProjection(arg1: GDALDatasetH, arg2: *const libc::c_char) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALSetSpatialRef(arg1: GDALDatasetH, arg2: OGRSpatialReferenceH) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetGeoTransform(arg1: GDALDatasetH, arg2: *mut f64) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALSetGeoTransform(arg1: GDALDatasetH, arg2: *mut f64) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetGCPCount(arg1: GDALDatasetH) -> libc::c_int;
}
extern "C" {
    pub fn GDALGetGCPProjection(arg1: GDALDatasetH) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALGetGCPSpatialRef(arg1: GDALDatasetH) -> OGRSpatialReferenceH;
}
extern "C" {
    pub fn GDALGetGCPs(arg1: GDALDatasetH) -> *const GDAL_GCP;
}
extern "C" {
    pub fn GDALSetGCPs(
        arg1: GDALDatasetH,
        arg2: libc::c_int,
        arg3: *const GDAL_GCP,
        arg4: *const libc::c_char,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALSetGCPs2(
        arg1: GDALDatasetH,
        arg2: libc::c_int,
        arg3: *const GDAL_GCP,
        arg4: OGRSpatialReferenceH,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetInternalHandle(
        arg1: GDALDatasetH,
        arg2: *const libc::c_char,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn GDALReferenceDataset(arg1: GDALDatasetH) -> libc::c_int;
}
extern "C" {
    pub fn GDALDereferenceDataset(arg1: GDALDatasetH) -> libc::c_int;
}
extern "C" {
    pub fn GDALReleaseDataset(arg1: GDALDatasetH) -> libc::c_int;
}
extern "C" {
    pub fn GDALBuildOverviews(
        arg1: GDALDatasetH,
        arg2: *const libc::c_char,
        arg3: libc::c_int,
        arg4: *mut libc::c_int,
        arg5: libc::c_int,
        arg6: *mut libc::c_int,
        arg7: GDALProgressFunc,
        arg8: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetOpenDatasets(hDS: *mut *mut GDALDatasetH, pnCount: *mut libc::c_int);
}
extern "C" {
    pub fn GDALGetAccess(hDS: GDALDatasetH) -> libc::c_int;
}
extern "C" {
    pub fn GDALFlushCache(hDS: GDALDatasetH);
}
extern "C" {
    pub fn GDALCreateDatasetMaskBand(hDS: GDALDatasetH, nFlags: libc::c_int) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALDatasetCopyWholeRaster(
        hSrcDS: GDALDatasetH,
        hDstDS: GDALDatasetH,
        papszOptions: CSLConstList,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRasterBandCopyWholeRaster(
        hSrcBand: GDALRasterBandH,
        hDstBand: GDALRasterBandH,
        constpapszOptions: *const *const libc::c_char,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRegenerateOverviews(
        hSrcBand: GDALRasterBandH,
        nOverviewCount: libc::c_int,
        pahOverviewBands: *mut GDALRasterBandH,
        pszResampling: *const libc::c_char,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALDatasetGetLayerCount(arg1: GDALDatasetH) -> libc::c_int;
}
extern "C" {
    pub fn GDALDatasetGetLayer(arg1: GDALDatasetH, arg2: libc::c_int) -> OGRLayerH;
}
extern "C" {
    pub fn GDALDatasetGetLayerByName(arg1: GDALDatasetH, arg2: *const libc::c_char) -> OGRLayerH;
}
extern "C" {
    pub fn GDALDatasetDeleteLayer(arg1: GDALDatasetH, arg2: libc::c_int) -> OGRErr::Type;
}
extern "C" {
    pub fn GDALDatasetCreateLayer(
        arg1: GDALDatasetH,
        arg2: *const libc::c_char,
        arg3: OGRSpatialReferenceH,
        arg4: OGRwkbGeometryType::Type,
        arg5: CSLConstList,
    ) -> OGRLayerH;
}
extern "C" {
    pub fn GDALDatasetCopyLayer(
        arg1: GDALDatasetH,
        arg2: OGRLayerH,
        arg3: *const libc::c_char,
        arg4: CSLConstList,
    ) -> OGRLayerH;
}
extern "C" {
    pub fn GDALDatasetResetReading(arg1: GDALDatasetH);
}
extern "C" {
    pub fn GDALDatasetGetNextFeature(
        hDS: GDALDatasetH,
        phBelongingLayer: *mut OGRLayerH,
        pdfProgressPct: *mut f64,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
    ) -> OGRFeatureH;
}
extern "C" {
    pub fn GDALDatasetTestCapability(arg1: GDALDatasetH, arg2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn GDALDatasetExecuteSQL(
        arg1: GDALDatasetH,
        arg2: *const libc::c_char,
        arg3: OGRGeometryH,
        arg4: *const libc::c_char,
    ) -> OGRLayerH;
}
extern "C" {
    pub fn GDALDatasetAbortSQL(arg1: GDALDatasetH) -> OGRErr::Type;
}
extern "C" {
    pub fn GDALDatasetReleaseResultSet(arg1: GDALDatasetH, arg2: OGRLayerH);
}
extern "C" {
    pub fn GDALDatasetGetStyleTable(arg1: GDALDatasetH) -> OGRStyleTableH;
}
extern "C" {
    pub fn GDALDatasetSetStyleTableDirectly(arg1: GDALDatasetH, arg2: OGRStyleTableH);
}
extern "C" {
    pub fn GDALDatasetSetStyleTable(arg1: GDALDatasetH, arg2: OGRStyleTableH);
}
extern "C" {
    pub fn GDALDatasetStartTransaction(hDS: GDALDatasetH, bForce: libc::c_int) -> OGRErr::Type;
}
extern "C" {
    pub fn GDALDatasetCommitTransaction(hDS: GDALDatasetH) -> OGRErr::Type;
}
extern "C" {
    pub fn GDALDatasetRollbackTransaction(hDS: GDALDatasetH) -> OGRErr::Type;
}
extern "C" {
    pub fn GDALDatasetClearStatistics(hDS: GDALDatasetH);
}
pub type GDALDerivedPixelFunc = ::std::option::Option<
    unsafe extern "C" fn(
        papoSources: *mut *mut libc::c_void,
        nSources: libc::c_int,
        pData: *mut libc::c_void,
        nBufXSize: libc::c_int,
        nBufYSize: libc::c_int,
        eSrcType: GDALDataType::Type,
        eBufType: GDALDataType::Type,
        nPixelSpace: libc::c_int,
        nLineSpace: libc::c_int,
    ) -> CPLErr::Type,
>;
extern "C" {
    pub fn GDALGetRasterDataType(arg1: GDALRasterBandH) -> GDALDataType::Type;
}
extern "C" {
    pub fn GDALGetBlockSize(
        arg1: GDALRasterBandH,
        pnXSize: *mut libc::c_int,
        pnYSize: *mut libc::c_int,
    );
}
extern "C" {
    pub fn GDALGetActualBlockSize(
        arg1: GDALRasterBandH,
        nXBlockOff: libc::c_int,
        nYBlockOff: libc::c_int,
        pnXValid: *mut libc::c_int,
        pnYValid: *mut libc::c_int,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRasterAdviseRead(
        hRB: GDALRasterBandH,
        nDSXOff: libc::c_int,
        nDSYOff: libc::c_int,
        nDSXSize: libc::c_int,
        nDSYSize: libc::c_int,
        nBXSize: libc::c_int,
        nBYSize: libc::c_int,
        eBDataType: GDALDataType::Type,
        papszOptions: CSLConstList,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRasterIO(
        hRBand: GDALRasterBandH,
        eRWFlag: GDALRWFlag::Type,
        nDSXOff: libc::c_int,
        nDSYOff: libc::c_int,
        nDSXSize: libc::c_int,
        nDSYSize: libc::c_int,
        pBuffer: *mut libc::c_void,
        nBXSize: libc::c_int,
        nBYSize: libc::c_int,
        eBDataType: GDALDataType::Type,
        nPixelSpace: libc::c_int,
        nLineSpace: libc::c_int,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRasterIOEx(
        hRBand: GDALRasterBandH,
        eRWFlag: GDALRWFlag::Type,
        nDSXOff: libc::c_int,
        nDSYOff: libc::c_int,
        nDSXSize: libc::c_int,
        nDSYSize: libc::c_int,
        pBuffer: *mut libc::c_void,
        nBXSize: libc::c_int,
        nBYSize: libc::c_int,
        eBDataType: GDALDataType::Type,
        nPixelSpace: GSpacing,
        nLineSpace: GSpacing,
        psExtraArg: *mut GDALRasterIOExtraArg,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALReadBlock(
        arg1: GDALRasterBandH,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALWriteBlock(
        arg1: GDALRasterBandH,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetRasterBandXSize(arg1: GDALRasterBandH) -> libc::c_int;
}
extern "C" {
    pub fn GDALGetRasterBandYSize(arg1: GDALRasterBandH) -> libc::c_int;
}
extern "C" {
    pub fn GDALGetRasterAccess(arg1: GDALRasterBandH) -> GDALAccess::Type;
}
extern "C" {
    pub fn GDALGetBandNumber(arg1: GDALRasterBandH) -> libc::c_int;
}
extern "C" {
    pub fn GDALGetBandDataset(arg1: GDALRasterBandH) -> GDALDatasetH;
}
extern "C" {
    pub fn GDALGetRasterColorInterpretation(arg1: GDALRasterBandH) -> GDALColorInterp::Type;
}
extern "C" {
    pub fn GDALSetRasterColorInterpretation(
        arg1: GDALRasterBandH,
        arg2: GDALColorInterp::Type,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetRasterColorTable(arg1: GDALRasterBandH) -> GDALColorTableH;
}
extern "C" {
    pub fn GDALSetRasterColorTable(arg1: GDALRasterBandH, arg2: GDALColorTableH) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALHasArbitraryOverviews(arg1: GDALRasterBandH) -> libc::c_int;
}
extern "C" {
    pub fn GDALGetOverviewCount(arg1: GDALRasterBandH) -> libc::c_int;
}
extern "C" {
    pub fn GDALGetOverview(arg1: GDALRasterBandH, arg2: libc::c_int) -> GDALRasterBandH;
}
extern "C" {
    pub fn GDALGetRasterNoDataValue(arg1: GDALRasterBandH, arg2: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn GDALSetRasterNoDataValue(arg1: GDALRasterBandH, arg2: f64) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALDeleteRasterNoDataValue(arg1: GDALRasterBandH) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetRasterCategoryNames(arg1: GDALRasterBandH) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn GDALSetRasterCategoryNames(arg1: GDALRasterBandH, arg2: CSLConstList) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetRasterMinimum(arg1: GDALRasterBandH, pbSuccess: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn GDALGetRasterMaximum(arg1: GDALRasterBandH, pbSuccess: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn GDALGetRasterStatistics(
        arg1: GDALRasterBandH,
        bApproxOK: libc::c_int,
        bForce: libc::c_int,
        pdfMin: *mut f64,
        pdfMax: *mut f64,
        pdfMean: *mut f64,
        pdfStdDev: *mut f64,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALComputeRasterStatistics(
        arg1: GDALRasterBandH,
        bApproxOK: libc::c_int,
        pdfMin: *mut f64,
        pdfMax: *mut f64,
        pdfMean: *mut f64,
        pdfStdDev: *mut f64,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALSetRasterStatistics(
        hBand: GDALRasterBandH,
        dfMin: f64,
        dfMax: f64,
        dfMean: f64,
        dfStdDev: f64,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRasterBandAsMDArray(arg1: GDALRasterBandH) -> GDALMDArrayH;
}
extern "C" {
    pub fn GDALGetRasterUnitType(arg1: GDALRasterBandH) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALSetRasterUnitType(
        hBand: GDALRasterBandH,
        pszNewValue: *const libc::c_char,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetRasterOffset(arg1: GDALRasterBandH, pbSuccess: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn GDALSetRasterOffset(hBand: GDALRasterBandH, dfNewOffset: f64) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetRasterScale(arg1: GDALRasterBandH, pbSuccess: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn GDALSetRasterScale(hBand: GDALRasterBandH, dfNewOffset: f64) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALComputeRasterMinMax(
        hBand: GDALRasterBandH,
        bApproxOK: libc::c_int,
        adfMinMax: *mut f64,
    );
}
extern "C" {
    pub fn GDALFlushRasterCache(hBand: GDALRasterBandH) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetRasterHistogram(
        hBand: GDALRasterBandH,
        dfMin: f64,
        dfMax: f64,
        nBuckets: libc::c_int,
        panHistogram: *mut libc::c_int,
        bIncludeOutOfRange: libc::c_int,
        bApproxOK: libc::c_int,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetRasterHistogramEx(
        hBand: GDALRasterBandH,
        dfMin: f64,
        dfMax: f64,
        nBuckets: libc::c_int,
        panHistogram: *mut GUIntBig,
        bIncludeOutOfRange: libc::c_int,
        bApproxOK: libc::c_int,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetDefaultHistogram(
        hBand: GDALRasterBandH,
        pdfMin: *mut f64,
        pdfMax: *mut f64,
        pnBuckets: *mut libc::c_int,
        ppanHistogram: *mut *mut libc::c_int,
        bForce: libc::c_int,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetDefaultHistogramEx(
        hBand: GDALRasterBandH,
        pdfMin: *mut f64,
        pdfMax: *mut f64,
        pnBuckets: *mut libc::c_int,
        ppanHistogram: *mut *mut GUIntBig,
        bForce: libc::c_int,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALSetDefaultHistogram(
        hBand: GDALRasterBandH,
        dfMin: f64,
        dfMax: f64,
        nBuckets: libc::c_int,
        panHistogram: *mut libc::c_int,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALSetDefaultHistogramEx(
        hBand: GDALRasterBandH,
        dfMin: f64,
        dfMax: f64,
        nBuckets: libc::c_int,
        panHistogram: *mut GUIntBig,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetRandomRasterSample(
        arg1: GDALRasterBandH,
        arg2: libc::c_int,
        arg3: *mut f32,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALGetRasterSampleOverview(arg1: GDALRasterBandH, arg2: libc::c_int)
        -> GDALRasterBandH;
}
extern "C" {
    pub fn GDALGetRasterSampleOverviewEx(arg1: GDALRasterBandH, arg2: GUIntBig) -> GDALRasterBandH;
}
extern "C" {
    pub fn GDALFillRaster(
        hBand: GDALRasterBandH,
        dfRealValue: f64,
        dfImaginaryValue: f64,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALComputeBandStats(
        hBand: GDALRasterBandH,
        nSampleStep: libc::c_int,
        pdfMean: *mut f64,
        pdfStdDev: *mut f64,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALOverviewMagnitudeCorrection(
        hBaseBand: GDALRasterBandH,
        nOverviewCount: libc::c_int,
        pahOverviews: *mut GDALRasterBandH,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetDefaultRAT(hBand: GDALRasterBandH) -> GDALRasterAttributeTableH;
}
extern "C" {
    pub fn GDALSetDefaultRAT(
        arg1: GDALRasterBandH,
        arg2: GDALRasterAttributeTableH,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALAddDerivedBandPixelFunc(
        pszName: *const libc::c_char,
        pfnPixelFunc: GDALDerivedPixelFunc,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetMaskBand(hBand: GDALRasterBandH) -> GDALRasterBandH;
}
extern "C" {
    pub fn GDALGetMaskFlags(hBand: GDALRasterBandH) -> libc::c_int;
}
extern "C" {
    pub fn GDALCreateMaskBand(hBand: GDALRasterBandH, nFlags: libc::c_int) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetDataCoverageStatus(
        hBand: GDALRasterBandH,
        nXOff: libc::c_int,
        nYOff: libc::c_int,
        nXSize: libc::c_int,
        nYSize: libc::c_int,
        nMaskFlagStop: libc::c_int,
        pdfDataPct: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALARGetNextUpdatedRegion(
        hARIO: GDALAsyncReaderH,
        dfTimeout: f64,
        pnXBufOff: *mut libc::c_int,
        pnYBufOff: *mut libc::c_int,
        pnXBufSize: *mut libc::c_int,
        pnYBufSize: *mut libc::c_int,
    ) -> GDALAsyncStatusType::Type;
}
extern "C" {
    pub fn GDALARLockBuffer(hARIO: GDALAsyncReaderH, dfTimeout: f64) -> libc::c_int;
}
extern "C" {
    pub fn GDALARUnlockBuffer(hARIO: GDALAsyncReaderH);
}
extern "C" {
    pub fn GDALGeneralCmdLineProcessor(
        nArgc: libc::c_int,
        ppapszArgv: *mut *mut *mut libc::c_char,
        nOptions: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALSwapWords(
        pData: *mut libc::c_void,
        nWordSize: libc::c_int,
        nWordCount: libc::c_int,
        nWordSkip: libc::c_int,
    );
}
extern "C" {
    pub fn GDALSwapWordsEx(
        pData: *mut libc::c_void,
        nWordSize: libc::c_int,
        nWordCount: usize,
        nWordSkip: libc::c_int,
    );
}
extern "C" {
    pub fn GDALCopyWords(
        pSrcData: *const libc::c_void,
        eSrcType: GDALDataType::Type,
        nSrcPixelOffset: libc::c_int,
        pDstData: *mut libc::c_void,
        eDstType: GDALDataType::Type,
        nDstPixelOffset: libc::c_int,
        nWordCount: libc::c_int,
    );
}
extern "C" {
    pub fn GDALCopyWords64(
        pSrcData: *const libc::c_void,
        eSrcType: GDALDataType::Type,
        nSrcPixelOffset: libc::c_int,
        pDstData: *mut libc::c_void,
        eDstType: GDALDataType::Type,
        nDstPixelOffset: libc::c_int,
        nWordCount: GPtrDiff_t,
    );
}
extern "C" {
    pub fn GDALCopyBits(
        pabySrcData: *const GByte,
        nSrcOffset: libc::c_int,
        nSrcStep: libc::c_int,
        pabyDstData: *mut GByte,
        nDstOffset: libc::c_int,
        nDstStep: libc::c_int,
        nBitCount: libc::c_int,
        nStepCount: libc::c_int,
    );
}
extern "C" {
    pub fn GDALLoadWorldFile(arg1: *const libc::c_char, arg2: *mut f64) -> libc::c_int;
}
extern "C" {
    pub fn GDALReadWorldFile(
        arg1: *const libc::c_char,
        arg2: *const libc::c_char,
        arg3: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALWriteWorldFile(
        arg1: *const libc::c_char,
        arg2: *const libc::c_char,
        arg3: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALLoadTabFile(
        arg1: *const libc::c_char,
        arg2: *mut f64,
        arg3: *mut *mut libc::c_char,
        arg4: *mut libc::c_int,
        arg5: *mut *mut GDAL_GCP,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALReadTabFile(
        arg1: *const libc::c_char,
        arg2: *mut f64,
        arg3: *mut *mut libc::c_char,
        arg4: *mut libc::c_int,
        arg5: *mut *mut GDAL_GCP,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALLoadOziMapFile(
        arg1: *const libc::c_char,
        arg2: *mut f64,
        arg3: *mut *mut libc::c_char,
        arg4: *mut libc::c_int,
        arg5: *mut *mut GDAL_GCP,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALReadOziMapFile(
        arg1: *const libc::c_char,
        arg2: *mut f64,
        arg3: *mut *mut libc::c_char,
        arg4: *mut libc::c_int,
        arg5: *mut *mut GDAL_GCP,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALDecToDMS(
        arg1: f64,
        arg2: *const libc::c_char,
        arg3: libc::c_int,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALPackedDMSToDec(arg1: f64) -> f64;
}
extern "C" {
    pub fn GDALDecToPackedDMS(arg1: f64) -> f64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALRPCInfo {
    pub dfLINE_OFF: f64,
    pub dfSAMP_OFF: f64,
    pub dfLAT_OFF: f64,
    pub dfLONG_OFF: f64,
    pub dfHEIGHT_OFF: f64,
    pub dfLINE_SCALE: f64,
    pub dfSAMP_SCALE: f64,
    pub dfLAT_SCALE: f64,
    pub dfLONG_SCALE: f64,
    pub dfHEIGHT_SCALE: f64,
    pub adfLINE_NUM_COEFF: [f64; 20usize],
    pub adfLINE_DEN_COEFF: [f64; 20usize],
    pub adfSAMP_NUM_COEFF: [f64; 20usize],
    pub adfSAMP_DEN_COEFF: [f64; 20usize],
    pub dfMIN_LONG: f64,
    pub dfMIN_LAT: f64,
    pub dfMAX_LONG: f64,
    pub dfMAX_LAT: f64,
}
#[test]
fn bindgen_test_layout_GDALRPCInfo() {
    assert_eq!(
        ::std::mem::size_of::<GDALRPCInfo>(),
        752usize,
        concat!("Size of: ", stringify!(GDALRPCInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<GDALRPCInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(GDALRPCInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALRPCInfo>())).dfLINE_OFF as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfo),
            "::",
            stringify!(dfLINE_OFF)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALRPCInfo>())).dfSAMP_OFF as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfo),
            "::",
            stringify!(dfSAMP_OFF)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALRPCInfo>())).dfLAT_OFF as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfo),
            "::",
            stringify!(dfLAT_OFF)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALRPCInfo>())).dfLONG_OFF as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfo),
            "::",
            stringify!(dfLONG_OFF)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALRPCInfo>())).dfHEIGHT_OFF as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfo),
            "::",
            stringify!(dfHEIGHT_OFF)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALRPCInfo>())).dfLINE_SCALE as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfo),
            "::",
            stringify!(dfLINE_SCALE)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALRPCInfo>())).dfSAMP_SCALE as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfo),
            "::",
            stringify!(dfSAMP_SCALE)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALRPCInfo>())).dfLAT_SCALE as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfo),
            "::",
            stringify!(dfLAT_SCALE)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALRPCInfo>())).dfLONG_SCALE as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfo),
            "::",
            stringify!(dfLONG_SCALE)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALRPCInfo>())).dfHEIGHT_SCALE as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfo),
            "::",
            stringify!(dfHEIGHT_SCALE)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALRPCInfo>())).adfLINE_NUM_COEFF as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfo),
            "::",
            stringify!(adfLINE_NUM_COEFF)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALRPCInfo>())).adfLINE_DEN_COEFF as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfo),
            "::",
            stringify!(adfLINE_DEN_COEFF)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALRPCInfo>())).adfSAMP_NUM_COEFF as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfo),
            "::",
            stringify!(adfSAMP_NUM_COEFF)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALRPCInfo>())).adfSAMP_DEN_COEFF as *const _ as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfo),
            "::",
            stringify!(adfSAMP_DEN_COEFF)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALRPCInfo>())).dfMIN_LONG as *const _ as usize },
        720usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfo),
            "::",
            stringify!(dfMIN_LONG)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALRPCInfo>())).dfMIN_LAT as *const _ as usize },
        728usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfo),
            "::",
            stringify!(dfMIN_LAT)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALRPCInfo>())).dfMAX_LONG as *const _ as usize },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfo),
            "::",
            stringify!(dfMAX_LONG)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALRPCInfo>())).dfMAX_LAT as *const _ as usize },
        744usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfo),
            "::",
            stringify!(dfMAX_LAT)
        )
    );
}
extern "C" {
    pub fn GDALExtractRPCInfo(arg1: CSLConstList, arg2: *mut GDALRPCInfo) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALColorEntry {
    pub c1: libc::c_short,
    pub c2: libc::c_short,
    pub c3: libc::c_short,
    pub c4: libc::c_short,
}
#[test]
fn bindgen_test_layout_GDALColorEntry() {
    assert_eq!(
        ::std::mem::size_of::<GDALColorEntry>(),
        8usize,
        concat!("Size of: ", stringify!(GDALColorEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<GDALColorEntry>(),
        2usize,
        concat!("Alignment of ", stringify!(GDALColorEntry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALColorEntry>())).c1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALColorEntry),
            "::",
            stringify!(c1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALColorEntry>())).c2 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALColorEntry),
            "::",
            stringify!(c2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALColorEntry>())).c3 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALColorEntry),
            "::",
            stringify!(c3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALColorEntry>())).c4 as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALColorEntry),
            "::",
            stringify!(c4)
        )
    );
}
extern "C" {
    pub fn GDALCreateColorTable(arg1: GDALPaletteInterp::Type) -> GDALColorTableH;
}
extern "C" {
    pub fn GDALDestroyColorTable(arg1: GDALColorTableH);
}
extern "C" {
    pub fn GDALCloneColorTable(arg1: GDALColorTableH) -> GDALColorTableH;
}
extern "C" {
    pub fn GDALGetPaletteInterpretation(arg1: GDALColorTableH) -> GDALPaletteInterp::Type;
}
extern "C" {
    pub fn GDALGetColorEntryCount(arg1: GDALColorTableH) -> libc::c_int;
}
extern "C" {
    pub fn GDALGetColorEntry(arg1: GDALColorTableH, arg2: libc::c_int) -> *const GDALColorEntry;
}
extern "C" {
    pub fn GDALGetColorEntryAsRGB(
        arg1: GDALColorTableH,
        arg2: libc::c_int,
        arg3: *mut GDALColorEntry,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALSetColorEntry(arg1: GDALColorTableH, arg2: libc::c_int, arg3: *const GDALColorEntry);
}
extern "C" {
    pub fn GDALCreateColorRamp(
        hTable: GDALColorTableH,
        nStartIndex: libc::c_int,
        psStartColor: *const GDALColorEntry,
        nEndIndex: libc::c_int,
        psEndColor: *const GDALColorEntry,
    );
}
pub mod GDALRATFieldType {
    pub type Type = libc::c_uint;
    pub const GFT_Integer: Type = 0;
    pub const GFT_Real: Type = 1;
    pub const GFT_String: Type = 2;
}
pub mod GDALRATFieldUsage {
    pub type Type = libc::c_uint;
    pub const GFU_Generic: Type = 0;
    pub const GFU_PixelCount: Type = 1;
    pub const GFU_Name: Type = 2;
    pub const GFU_Min: Type = 3;
    pub const GFU_Max: Type = 4;
    pub const GFU_MinMax: Type = 5;
    pub const GFU_Red: Type = 6;
    pub const GFU_Green: Type = 7;
    pub const GFU_Blue: Type = 8;
    pub const GFU_Alpha: Type = 9;
    pub const GFU_RedMin: Type = 10;
    pub const GFU_GreenMin: Type = 11;
    pub const GFU_BlueMin: Type = 12;
    pub const GFU_AlphaMin: Type = 13;
    pub const GFU_RedMax: Type = 14;
    pub const GFU_GreenMax: Type = 15;
    pub const GFU_BlueMax: Type = 16;
    pub const GFU_AlphaMax: Type = 17;
    pub const GFU_MaxCount: Type = 18;
}
pub mod GDALRATTableType {
    pub type Type = libc::c_uint;
    pub const GRTT_THEMATIC: Type = 0;
    pub const GRTT_ATHEMATIC: Type = 1;
}
extern "C" {
    pub fn GDALCreateRasterAttributeTable() -> GDALRasterAttributeTableH;
}
extern "C" {
    pub fn GDALDestroyRasterAttributeTable(arg1: GDALRasterAttributeTableH);
}
extern "C" {
    pub fn GDALRATGetColumnCount(arg1: GDALRasterAttributeTableH) -> libc::c_int;
}
extern "C" {
    pub fn GDALRATGetNameOfCol(
        arg1: GDALRasterAttributeTableH,
        arg2: libc::c_int,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALRATGetUsageOfCol(
        arg1: GDALRasterAttributeTableH,
        arg2: libc::c_int,
    ) -> GDALRATFieldUsage::Type;
}
extern "C" {
    pub fn GDALRATGetTypeOfCol(
        arg1: GDALRasterAttributeTableH,
        arg2: libc::c_int,
    ) -> GDALRATFieldType::Type;
}
extern "C" {
    pub fn GDALRATGetColOfUsage(
        arg1: GDALRasterAttributeTableH,
        arg2: GDALRATFieldUsage::Type,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALRATGetRowCount(arg1: GDALRasterAttributeTableH) -> libc::c_int;
}
extern "C" {
    pub fn GDALRATGetValueAsString(
        arg1: GDALRasterAttributeTableH,
        arg2: libc::c_int,
        arg3: libc::c_int,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALRATGetValueAsInt(
        arg1: GDALRasterAttributeTableH,
        arg2: libc::c_int,
        arg3: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALRATGetValueAsDouble(
        arg1: GDALRasterAttributeTableH,
        arg2: libc::c_int,
        arg3: libc::c_int,
    ) -> f64;
}
extern "C" {
    pub fn GDALRATSetValueAsString(
        arg1: GDALRasterAttributeTableH,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: *const libc::c_char,
    );
}
extern "C" {
    pub fn GDALRATSetValueAsInt(
        arg1: GDALRasterAttributeTableH,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: libc::c_int,
    );
}
extern "C" {
    pub fn GDALRATSetValueAsDouble(
        arg1: GDALRasterAttributeTableH,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: f64,
    );
}
extern "C" {
    pub fn GDALRATChangesAreWrittenToFile(hRAT: GDALRasterAttributeTableH) -> libc::c_int;
}
extern "C" {
    pub fn GDALRATValuesIOAsDouble(
        hRAT: GDALRasterAttributeTableH,
        eRWFlag: GDALRWFlag::Type,
        iField: libc::c_int,
        iStartRow: libc::c_int,
        iLength: libc::c_int,
        pdfData: *mut f64,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRATValuesIOAsInteger(
        hRAT: GDALRasterAttributeTableH,
        eRWFlag: GDALRWFlag::Type,
        iField: libc::c_int,
        iStartRow: libc::c_int,
        iLength: libc::c_int,
        pnData: *mut libc::c_int,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRATValuesIOAsString(
        hRAT: GDALRasterAttributeTableH,
        eRWFlag: GDALRWFlag::Type,
        iField: libc::c_int,
        iStartRow: libc::c_int,
        iLength: libc::c_int,
        papszStrList: CSLConstList,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRATSetRowCount(arg1: GDALRasterAttributeTableH, arg2: libc::c_int);
}
extern "C" {
    pub fn GDALRATCreateColumn(
        arg1: GDALRasterAttributeTableH,
        arg2: *const libc::c_char,
        arg3: GDALRATFieldType::Type,
        arg4: GDALRATFieldUsage::Type,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRATSetLinearBinning(
        arg1: GDALRasterAttributeTableH,
        arg2: f64,
        arg3: f64,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRATGetLinearBinning(
        arg1: GDALRasterAttributeTableH,
        arg2: *mut f64,
        arg3: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALRATSetTableType(
        hRAT: GDALRasterAttributeTableH,
        eInTableType: GDALRATTableType::Type,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRATGetTableType(hRAT: GDALRasterAttributeTableH) -> GDALRATTableType::Type;
}
extern "C" {
    pub fn GDALRATInitializeFromColorTable(
        arg1: GDALRasterAttributeTableH,
        arg2: GDALColorTableH,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRATTranslateToColorTable(
        arg1: GDALRasterAttributeTableH,
        nEntryCount: libc::c_int,
    ) -> GDALColorTableH;
}
extern "C" {
    pub fn GDALRATDumpReadable(arg1: GDALRasterAttributeTableH, arg2: *mut FILE);
}
extern "C" {
    pub fn GDALRATClone(arg1: GDALRasterAttributeTableH) -> GDALRasterAttributeTableH;
}
extern "C" {
    pub fn GDALRATSerializeJSON(arg1: GDALRasterAttributeTableH) -> *mut libc::c_void;
}
extern "C" {
    pub fn GDALRATGetRowOfValue(arg1: GDALRasterAttributeTableH, arg2: f64) -> libc::c_int;
}
extern "C" {
    pub fn GDALRATRemoveStatistics(arg1: GDALRasterAttributeTableH);
}
extern "C" {
    pub fn GDALSetCacheMax(nBytes: libc::c_int);
}
extern "C" {
    pub fn GDALGetCacheMax() -> libc::c_int;
}
extern "C" {
    pub fn GDALGetCacheUsed() -> libc::c_int;
}
extern "C" {
    pub fn GDALSetCacheMax64(nBytes: GIntBig);
}
extern "C" {
    pub fn GDALGetCacheMax64() -> GIntBig;
}
extern "C" {
    pub fn GDALGetCacheUsed64() -> GIntBig;
}
extern "C" {
    pub fn GDALFlushCacheBlock() -> libc::c_int;
}
extern "C" {
    pub fn GDALDatasetGetVirtualMem(
        hDS: GDALDatasetH,
        eRWFlag: GDALRWFlag::Type,
        nXOff: libc::c_int,
        nYOff: libc::c_int,
        nXSize: libc::c_int,
        nYSize: libc::c_int,
        nBufXSize: libc::c_int,
        nBufYSize: libc::c_int,
        eBufType: GDALDataType::Type,
        nBandCount: libc::c_int,
        panBandMap: *mut libc::c_int,
        nPixelSpace: libc::c_int,
        nLineSpace: GIntBig,
        nBandSpace: GIntBig,
        nCacheSize: usize,
        nPageSizeHint: usize,
        bSingleThreadUsage: libc::c_int,
        papszOptions: CSLConstList,
    ) -> *mut CPLVirtualMem;
}
extern "C" {
    pub fn GDALRasterBandGetVirtualMem(
        hBand: GDALRasterBandH,
        eRWFlag: GDALRWFlag::Type,
        nXOff: libc::c_int,
        nYOff: libc::c_int,
        nXSize: libc::c_int,
        nYSize: libc::c_int,
        nBufXSize: libc::c_int,
        nBufYSize: libc::c_int,
        eBufType: GDALDataType::Type,
        nPixelSpace: libc::c_int,
        nLineSpace: GIntBig,
        nCacheSize: usize,
        nPageSizeHint: usize,
        bSingleThreadUsage: libc::c_int,
        papszOptions: CSLConstList,
    ) -> *mut CPLVirtualMem;
}
extern "C" {
    pub fn GDALGetVirtualMemAuto(
        hBand: GDALRasterBandH,
        eRWFlag: GDALRWFlag::Type,
        pnPixelSpace: *mut libc::c_int,
        pnLineSpace: *mut GIntBig,
        papszOptions: CSLConstList,
    ) -> *mut CPLVirtualMem;
}
pub mod GDALTileOrganization {
    pub type Type = libc::c_uint;
    pub const GTO_TIP: Type = 0;
    pub const GTO_BIT: Type = 1;
    pub const GTO_BSQ: Type = 2;
}
extern "C" {
    pub fn GDALDatasetGetTiledVirtualMem(
        hDS: GDALDatasetH,
        eRWFlag: GDALRWFlag::Type,
        nXOff: libc::c_int,
        nYOff: libc::c_int,
        nXSize: libc::c_int,
        nYSize: libc::c_int,
        nTileXSize: libc::c_int,
        nTileYSize: libc::c_int,
        eBufType: GDALDataType::Type,
        nBandCount: libc::c_int,
        panBandMap: *mut libc::c_int,
        eTileOrganization: GDALTileOrganization::Type,
        nCacheSize: usize,
        bSingleThreadUsage: libc::c_int,
        papszOptions: CSLConstList,
    ) -> *mut CPLVirtualMem;
}
extern "C" {
    pub fn GDALRasterBandGetTiledVirtualMem(
        hBand: GDALRasterBandH,
        eRWFlag: GDALRWFlag::Type,
        nXOff: libc::c_int,
        nYOff: libc::c_int,
        nXSize: libc::c_int,
        nYSize: libc::c_int,
        nTileXSize: libc::c_int,
        nTileYSize: libc::c_int,
        eBufType: GDALDataType::Type,
        nCacheSize: usize,
        bSingleThreadUsage: libc::c_int,
        papszOptions: CSLConstList,
    ) -> *mut CPLVirtualMem;
}
extern "C" {
    pub fn GDALCreatePansharpenedVRT(
        pszXML: *const libc::c_char,
        hPanchroBand: GDALRasterBandH,
        nInputSpectralBands: libc::c_int,
        pahInputSpectralBands: *mut GDALRasterBandH,
    ) -> GDALDatasetH;
}
extern "C" {
    pub fn GDALGetJPEG2000Structure(
        pszFilename: *const libc::c_char,
        papszOptions: CSLConstList,
    ) -> *mut CPLXMLNode;
}
extern "C" {
    pub fn GDALCreateMultiDimensional(
        hDriver: GDALDriverH,
        pszName: *const libc::c_char,
        papszRootGroupOptions: CSLConstList,
        papszOptions: CSLConstList,
    ) -> GDALDatasetH;
}
extern "C" {
    pub fn GDALExtendedDataTypeCreate(eType: GDALDataType::Type) -> GDALExtendedDataTypeH;
}
extern "C" {
    pub fn GDALExtendedDataTypeCreateString(nMaxStringLength: usize) -> GDALExtendedDataTypeH;
}
extern "C" {
    pub fn GDALExtendedDataTypeCreateCompound(
        pszName: *const libc::c_char,
        nTotalSize: usize,
        nComponents: usize,
        comps: *const GDALEDTComponentH,
    ) -> GDALExtendedDataTypeH;
}
extern "C" {
    pub fn GDALExtendedDataTypeRelease(hEDT: GDALExtendedDataTypeH);
}
extern "C" {
    pub fn GDALExtendedDataTypeGetName(hEDT: GDALExtendedDataTypeH) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALExtendedDataTypeGetClass(
        hEDT: GDALExtendedDataTypeH,
    ) -> GDALExtendedDataTypeClass::Type;
}
extern "C" {
    pub fn GDALExtendedDataTypeGetNumericDataType(
        hEDT: GDALExtendedDataTypeH,
    ) -> GDALDataType::Type;
}
extern "C" {
    pub fn GDALExtendedDataTypeGetSize(hEDT: GDALExtendedDataTypeH) -> usize;
}
extern "C" {
    pub fn GDALExtendedDataTypeGetMaxStringLength(hEDT: GDALExtendedDataTypeH) -> usize;
}
extern "C" {
    pub fn GDALExtendedDataTypeGetComponents(
        hEDT: GDALExtendedDataTypeH,
        pnCount: *mut usize,
    ) -> *mut GDALEDTComponentH;
}
extern "C" {
    pub fn GDALExtendedDataTypeFreeComponents(components: *mut GDALEDTComponentH, nCount: usize);
}
extern "C" {
    pub fn GDALExtendedDataTypeCanConvertTo(
        hSourceEDT: GDALExtendedDataTypeH,
        hTargetEDT: GDALExtendedDataTypeH,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALExtendedDataTypeEquals(
        hFirstEDT: GDALExtendedDataTypeH,
        hSecondEDT: GDALExtendedDataTypeH,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALEDTComponentCreate(
        pszName: *const libc::c_char,
        nOffset: usize,
        hType: GDALExtendedDataTypeH,
    ) -> GDALEDTComponentH;
}
extern "C" {
    pub fn GDALEDTComponentRelease(hComp: GDALEDTComponentH);
}
extern "C" {
    pub fn GDALEDTComponentGetName(hComp: GDALEDTComponentH) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALEDTComponentGetOffset(hComp: GDALEDTComponentH) -> usize;
}
extern "C" {
    pub fn GDALEDTComponentGetType(hComp: GDALEDTComponentH) -> GDALExtendedDataTypeH;
}
extern "C" {
    pub fn GDALDatasetGetRootGroup(hDS: GDALDatasetH) -> GDALGroupH;
}
extern "C" {
    pub fn GDALGroupRelease(hGroup: GDALGroupH);
}
extern "C" {
    pub fn GDALGroupGetName(hGroup: GDALGroupH) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALGroupGetFullName(hGroup: GDALGroupH) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALGroupGetMDArrayNames(
        hGroup: GDALGroupH,
        papszOptions: CSLConstList,
    ) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn GDALGroupOpenMDArray(
        hGroup: GDALGroupH,
        pszMDArrayName: *const libc::c_char,
        papszOptions: CSLConstList,
    ) -> GDALMDArrayH;
}
extern "C" {
    pub fn GDALGroupOpenMDArrayFromFullname(
        hGroup: GDALGroupH,
        pszMDArrayName: *const libc::c_char,
        papszOptions: CSLConstList,
    ) -> GDALMDArrayH;
}
extern "C" {
    pub fn GDALGroupResolveMDArray(
        hGroup: GDALGroupH,
        pszName: *const libc::c_char,
        pszStartingPoint: *const libc::c_char,
        papszOptions: CSLConstList,
    ) -> GDALMDArrayH;
}
extern "C" {
    pub fn GDALGroupGetGroupNames(
        hGroup: GDALGroupH,
        papszOptions: CSLConstList,
    ) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn GDALGroupOpenGroup(
        hGroup: GDALGroupH,
        pszSubGroupName: *const libc::c_char,
        papszOptions: CSLConstList,
    ) -> GDALGroupH;
}
extern "C" {
    pub fn GDALGroupOpenGroupFromFullname(
        hGroup: GDALGroupH,
        pszMDArrayName: *const libc::c_char,
        papszOptions: CSLConstList,
    ) -> GDALGroupH;
}
extern "C" {
    pub fn GDALGroupGetDimensions(
        hGroup: GDALGroupH,
        pnCount: *mut usize,
        papszOptions: CSLConstList,
    ) -> *mut GDALDimensionH;
}
extern "C" {
    pub fn GDALGroupGetAttribute(
        hGroup: GDALGroupH,
        pszName: *const libc::c_char,
    ) -> GDALAttributeH;
}
extern "C" {
    pub fn GDALGroupGetAttributes(
        hGroup: GDALGroupH,
        pnCount: *mut usize,
        papszOptions: CSLConstList,
    ) -> *mut GDALAttributeH;
}
extern "C" {
    pub fn GDALGroupGetStructuralInfo(hGroup: GDALGroupH) -> CSLConstList;
}
extern "C" {
    pub fn GDALGroupCreateGroup(
        hGroup: GDALGroupH,
        pszSubGroupName: *const libc::c_char,
        papszOptions: CSLConstList,
    ) -> GDALGroupH;
}
extern "C" {
    pub fn GDALGroupCreateDimension(
        hGroup: GDALGroupH,
        pszName: *const libc::c_char,
        pszType: *const libc::c_char,
        pszDirection: *const libc::c_char,
        nSize: GUInt64,
        papszOptions: CSLConstList,
    ) -> GDALDimensionH;
}
extern "C" {
    pub fn GDALGroupCreateMDArray(
        hGroup: GDALGroupH,
        pszName: *const libc::c_char,
        nDimensions: usize,
        pahDimensions: *mut GDALDimensionH,
        hEDT: GDALExtendedDataTypeH,
        papszOptions: CSLConstList,
    ) -> GDALMDArrayH;
}
extern "C" {
    pub fn GDALGroupCreateAttribute(
        hGroup: GDALGroupH,
        pszName: *const libc::c_char,
        nDimensions: usize,
        panDimensions: *const GUInt64,
        hEDT: GDALExtendedDataTypeH,
        papszOptions: CSLConstList,
    ) -> GDALAttributeH;
}
extern "C" {
    pub fn GDALMDArrayRelease(hMDArray: GDALMDArrayH);
}
extern "C" {
    pub fn GDALMDArrayGetName(hArray: GDALMDArrayH) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALMDArrayGetFullName(hArray: GDALMDArrayH) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALMDArrayGetTotalElementsCount(hArray: GDALMDArrayH) -> GUInt64;
}
extern "C" {
    pub fn GDALMDArrayGetDimensionCount(hArray: GDALMDArrayH) -> usize;
}
extern "C" {
    pub fn GDALMDArrayGetDimensions(
        hArray: GDALMDArrayH,
        pnCount: *mut usize,
    ) -> *mut GDALDimensionH;
}
extern "C" {
    pub fn GDALMDArrayGetDataType(hArray: GDALMDArrayH) -> GDALExtendedDataTypeH;
}
extern "C" {
    pub fn GDALMDArrayRead(
        hArray: GDALMDArrayH,
        arrayStartIdx: *const GUInt64,
        count: *const usize,
        arrayStep: *const GInt64,
        bufferStride: *const GPtrDiff_t,
        bufferDatatype: GDALExtendedDataTypeH,
        pDstBuffer: *mut libc::c_void,
        pDstBufferAllocStart: *const libc::c_void,
        nDstBufferllocSize: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALMDArrayWrite(
        hArray: GDALMDArrayH,
        arrayStartIdx: *const GUInt64,
        count: *const usize,
        arrayStep: *const GInt64,
        bufferStride: *const GPtrDiff_t,
        bufferDatatype: GDALExtendedDataTypeH,
        pSrcBuffer: *const libc::c_void,
        psrcBufferAllocStart: *const libc::c_void,
        nSrcBufferllocSize: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALMDArrayAdviseRead(
        hArray: GDALMDArrayH,
        arrayStartIdx: *const GUInt64,
        count: *const usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALMDArrayGetAttribute(
        hArray: GDALMDArrayH,
        pszName: *const libc::c_char,
    ) -> GDALAttributeH;
}
extern "C" {
    pub fn GDALMDArrayGetAttributes(
        hArray: GDALMDArrayH,
        pnCount: *mut usize,
        papszOptions: CSLConstList,
    ) -> *mut GDALAttributeH;
}
extern "C" {
    pub fn GDALMDArrayCreateAttribute(
        hArray: GDALMDArrayH,
        pszName: *const libc::c_char,
        nDimensions: usize,
        panDimensions: *const GUInt64,
        hEDT: GDALExtendedDataTypeH,
        papszOptions: CSLConstList,
    ) -> GDALAttributeH;
}
extern "C" {
    pub fn GDALMDArrayGetRawNoDataValue(hArray: GDALMDArrayH) -> *const libc::c_void;
}
extern "C" {
    pub fn GDALMDArrayGetNoDataValueAsDouble(
        hArray: GDALMDArrayH,
        pbHasNoDataValue: *mut libc::c_int,
    ) -> f64;
}
extern "C" {
    pub fn GDALMDArraySetRawNoDataValue(
        hArray: GDALMDArrayH,
        arg1: *const libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALMDArraySetNoDataValueAsDouble(
        hArray: GDALMDArrayH,
        dfNoDataValue: f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALMDArraySetScale(hArray: GDALMDArrayH, dfScale: f64) -> libc::c_int;
}
extern "C" {
    pub fn GDALMDArrayGetScale(hArray: GDALMDArrayH, pbHasValue: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn GDALMDArraySetOffset(hArray: GDALMDArrayH, dfOffset: f64) -> libc::c_int;
}
extern "C" {
    pub fn GDALMDArrayGetOffset(hArray: GDALMDArrayH, pbHasValue: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn GDALMDArrayGetBlockSize(hArray: GDALMDArrayH, pnCount: *mut usize) -> *mut GUInt64;
}
extern "C" {
    pub fn GDALMDArraySetUnit(hArray: GDALMDArrayH, arg1: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn GDALMDArrayGetUnit(hArray: GDALMDArrayH) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALMDArraySetSpatialRef(arg1: GDALMDArrayH, arg2: OGRSpatialReferenceH) -> libc::c_int;
}
extern "C" {
    pub fn GDALMDArrayGetSpatialRef(hArray: GDALMDArrayH) -> OGRSpatialReferenceH;
}
extern "C" {
    pub fn GDALMDArrayGetProcessingChunkSize(
        hArray: GDALMDArrayH,
        pnCount: *mut usize,
        nMaxChunkMemory: usize,
    ) -> *mut usize;
}
extern "C" {
    pub fn GDALMDArrayGetStructuralInfo(hArray: GDALMDArrayH) -> CSLConstList;
}
extern "C" {
    pub fn GDALMDArrayGetView(
        hArray: GDALMDArrayH,
        pszViewExpr: *const libc::c_char,
    ) -> GDALMDArrayH;
}
extern "C" {
    pub fn GDALMDArrayTranspose(
        hArray: GDALMDArrayH,
        nNewAxisCount: usize,
        panMapNewAxisToOldAxis: *const libc::c_int,
    ) -> GDALMDArrayH;
}
extern "C" {
    pub fn GDALMDArrayGetUnscaled(hArray: GDALMDArrayH) -> GDALMDArrayH;
}
extern "C" {
    pub fn GDALMDArrayGetMask(hArray: GDALMDArrayH, papszOptions: CSLConstList) -> GDALMDArrayH;
}
extern "C" {
    pub fn GDALMDArrayAsClassicDataset(
        hArray: GDALMDArrayH,
        iXDim: usize,
        iYDim: usize,
    ) -> GDALDatasetH;
}
extern "C" {
    pub fn GDALMDArrayGetStatistics(
        hArray: GDALMDArrayH,
        arg1: GDALDatasetH,
        bApproxOK: libc::c_int,
        bForce: libc::c_int,
        pdfMin: *mut f64,
        pdfMax: *mut f64,
        pdfMean: *mut f64,
        pdfStdDev: *mut f64,
        pnValidCount: *mut GUInt64,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALMDArrayComputeStatistics(
        hArray: GDALMDArrayH,
        arg1: GDALDatasetH,
        bApproxOK: libc::c_int,
        pdfMin: *mut f64,
        pdfMax: *mut f64,
        pdfMean: *mut f64,
        pdfStdDev: *mut f64,
        pnValidCount: *mut GUInt64,
        arg2: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALAttributeRelease(hAttr: GDALAttributeH);
}
extern "C" {
    pub fn GDALReleaseAttributes(attributes: *mut GDALAttributeH, nCount: usize);
}
extern "C" {
    pub fn GDALAttributeGetName(hAttr: GDALAttributeH) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALAttributeGetFullName(hAttr: GDALAttributeH) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALAttributeGetTotalElementsCount(hAttr: GDALAttributeH) -> GUInt64;
}
extern "C" {
    pub fn GDALAttributeGetDimensionCount(hAttr: GDALAttributeH) -> usize;
}
extern "C" {
    pub fn GDALAttributeGetDimensionsSize(
        hAttr: GDALAttributeH,
        pnCount: *mut usize,
    ) -> *mut GUInt64;
}
extern "C" {
    pub fn GDALAttributeGetDataType(hAttr: GDALAttributeH) -> GDALExtendedDataTypeH;
}
extern "C" {
    pub fn GDALAttributeReadAsRaw(hAttr: GDALAttributeH, pnSize: *mut usize) -> *mut GByte;
}
extern "C" {
    pub fn GDALAttributeFreeRawResult(hAttr: GDALAttributeH, raw: *mut GByte, nSize: usize);
}
extern "C" {
    pub fn GDALAttributeReadAsString(hAttr: GDALAttributeH) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALAttributeReadAsInt(hAttr: GDALAttributeH) -> libc::c_int;
}
extern "C" {
    pub fn GDALAttributeReadAsDouble(hAttr: GDALAttributeH) -> f64;
}
extern "C" {
    pub fn GDALAttributeReadAsStringArray(hAttr: GDALAttributeH) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn GDALAttributeReadAsIntArray(
        hAttr: GDALAttributeH,
        pnCount: *mut usize,
    ) -> *mut libc::c_int;
}
extern "C" {
    pub fn GDALAttributeReadAsDoubleArray(hAttr: GDALAttributeH, pnCount: *mut usize) -> *mut f64;
}
extern "C" {
    pub fn GDALAttributeWriteRaw(
        hAttr: GDALAttributeH,
        arg1: *const libc::c_void,
        arg2: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALAttributeWriteString(
        hAttr: GDALAttributeH,
        arg1: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALAttributeWriteStringArray(hAttr: GDALAttributeH, arg1: CSLConstList) -> libc::c_int;
}
extern "C" {
    pub fn GDALAttributeWriteInt(hAttr: GDALAttributeH, arg1: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn GDALAttributeWriteDouble(hAttr: GDALAttributeH, arg1: f64) -> libc::c_int;
}
extern "C" {
    pub fn GDALAttributeWriteDoubleArray(
        hAttr: GDALAttributeH,
        arg1: *const f64,
        arg2: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALDimensionRelease(hDim: GDALDimensionH);
}
extern "C" {
    pub fn GDALReleaseDimensions(dims: *mut GDALDimensionH, nCount: usize);
}
extern "C" {
    pub fn GDALDimensionGetName(hDim: GDALDimensionH) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALDimensionGetFullName(hDim: GDALDimensionH) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALDimensionGetType(hDim: GDALDimensionH) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALDimensionGetDirection(hDim: GDALDimensionH) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALDimensionGetSize(hDim: GDALDimensionH) -> GUInt64;
}
extern "C" {
    pub fn GDALDimensionGetIndexingVariable(hDim: GDALDimensionH) -> GDALMDArrayH;
}
extern "C" {
    pub fn GDALDimensionSetIndexingVariable(
        hDim: GDALDimensionH,
        hArray: GDALMDArrayH,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALComputeMedianCutPCT(
        hRed: GDALRasterBandH,
        hGreen: GDALRasterBandH,
        hBlue: GDALRasterBandH,
        pfnIncludePixel: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: libc::c_int,
                arg2: libc::c_int,
                arg3: *mut libc::c_void,
            ) -> libc::c_int,
        >,
        nColors: libc::c_int,
        hColorTable: GDALColorTableH,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALDitherRGB2PCT(
        hRed: GDALRasterBandH,
        hGreen: GDALRasterBandH,
        hBlue: GDALRasterBandH,
        hTarget: GDALRasterBandH,
        hColorTable: GDALColorTableH,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALChecksumImage(
        hBand: GDALRasterBandH,
        nXOff: libc::c_int,
        nYOff: libc::c_int,
        nXSize: libc::c_int,
        nYSize: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALComputeProximity(
        hSrcBand: GDALRasterBandH,
        hProximityBand: GDALRasterBandH,
        papszOptions: *mut *mut libc::c_char,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALFillNodata(
        hTargetBand: GDALRasterBandH,
        hMaskBand: GDALRasterBandH,
        dfMaxSearchDist: f64,
        bDeprecatedOption: libc::c_int,
        nSmoothingIterations: libc::c_int,
        papszOptions: *mut *mut libc::c_char,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALPolygonize(
        hSrcBand: GDALRasterBandH,
        hMaskBand: GDALRasterBandH,
        hOutLayer: OGRLayerH,
        iPixValField: libc::c_int,
        papszOptions: *mut *mut libc::c_char,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALFPolygonize(
        hSrcBand: GDALRasterBandH,
        hMaskBand: GDALRasterBandH,
        hOutLayer: OGRLayerH,
        iPixValField: libc::c_int,
        papszOptions: *mut *mut libc::c_char,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALSieveFilter(
        hSrcBand: GDALRasterBandH,
        hMaskBand: GDALRasterBandH,
        hDstBand: GDALRasterBandH,
        nSizeThreshold: libc::c_int,
        nConnectedness: libc::c_int,
        papszOptions: *mut *mut libc::c_char,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut libc::c_void,
    ) -> CPLErr::Type;
}
pub type GDALTransformerFunc = ::std::option::Option<
    unsafe extern "C" fn(
        pTransformerArg: *mut libc::c_void,
        bDstToSrc: libc::c_int,
        nPointCount: libc::c_int,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
        panSuccess: *mut libc::c_int,
    ) -> libc::c_int,
>;
extern "C" {
    pub fn GDALDestroyTransformer(pTransformerArg: *mut libc::c_void);
}
extern "C" {
    pub fn GDALUseTransformer(
        pTransformerArg: *mut libc::c_void,
        bDstToSrc: libc::c_int,
        nPointCount: libc::c_int,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
        panSuccess: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALCreateSimilarTransformer(
        psTransformerArg: *mut libc::c_void,
        dfSrcRatioX: f64,
        dfSrcRatioY: f64,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn GDALCreateGenImgProjTransformer(
        hSrcDS: GDALDatasetH,
        pszSrcWKT: *const libc::c_char,
        hDstDS: GDALDatasetH,
        pszDstWKT: *const libc::c_char,
        bGCPUseOK: libc::c_int,
        dfGCPErrorThreshold: f64,
        nOrder: libc::c_int,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn GDALCreateGenImgProjTransformer2(
        hSrcDS: GDALDatasetH,
        hDstDS: GDALDatasetH,
        papszOptions: *mut *mut libc::c_char,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn GDALCreateGenImgProjTransformer3(
        pszSrcWKT: *const libc::c_char,
        padfSrcGeoTransform: *const f64,
        pszDstWKT: *const libc::c_char,
        padfDstGeoTransform: *const f64,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn GDALCreateGenImgProjTransformer4(
        hSrcSRS: OGRSpatialReferenceH,
        padfSrcGeoTransform: *const f64,
        hDstSRS: OGRSpatialReferenceH,
        padfDstGeoTransform: *const f64,
        papszOptions: *const *const libc::c_char,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn GDALSetGenImgProjTransformerDstGeoTransform(arg1: *mut libc::c_void, arg2: *const f64);
}
extern "C" {
    pub fn GDALDestroyGenImgProjTransformer(arg1: *mut libc::c_void);
}
extern "C" {
    pub fn GDALGenImgProjTransform(
        pTransformArg: *mut libc::c_void,
        bDstToSrc: libc::c_int,
        nPointCount: libc::c_int,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
        panSuccess: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALSetTransformerDstGeoTransform(arg1: *mut libc::c_void, arg2: *const f64);
}
extern "C" {
    pub fn GDALGetTransformerDstGeoTransform(arg1: *mut libc::c_void, arg2: *mut f64);
}
extern "C" {
    pub fn GDALCreateReprojectionTransformer(
        pszSrcWKT: *const libc::c_char,
        pszDstWKT: *const libc::c_char,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn GDALCreateReprojectionTransformerEx(
        hSrcSRS: OGRSpatialReferenceH,
        hDstSRS: OGRSpatialReferenceH,
        papszOptions: *const *const libc::c_char,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn GDALDestroyReprojectionTransformer(arg1: *mut libc::c_void);
}
extern "C" {
    pub fn GDALReprojectionTransform(
        pTransformArg: *mut libc::c_void,
        bDstToSrc: libc::c_int,
        nPointCount: libc::c_int,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
        panSuccess: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALCreateGCPTransformer(
        nGCPCount: libc::c_int,
        pasGCPList: *const GDAL_GCP,
        nReqOrder: libc::c_int,
        bReversed: libc::c_int,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn GDALCreateGCPRefineTransformer(
        nGCPCount: libc::c_int,
        pasGCPList: *const GDAL_GCP,
        nReqOrder: libc::c_int,
        bReversed: libc::c_int,
        tolerance: f64,
        minimumGcps: libc::c_int,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn GDALDestroyGCPTransformer(pTransformArg: *mut libc::c_void);
}
extern "C" {
    pub fn GDALGCPTransform(
        pTransformArg: *mut libc::c_void,
        bDstToSrc: libc::c_int,
        nPointCount: libc::c_int,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
        panSuccess: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALCreateTPSTransformer(
        nGCPCount: libc::c_int,
        pasGCPList: *const GDAL_GCP,
        bReversed: libc::c_int,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn GDALDestroyTPSTransformer(pTransformArg: *mut libc::c_void);
}
extern "C" {
    pub fn GDALTPSTransform(
        pTransformArg: *mut libc::c_void,
        bDstToSrc: libc::c_int,
        nPointCount: libc::c_int,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
        panSuccess: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALCreateRPCTransformer(
        psRPC: *mut GDALRPCInfo,
        bReversed: libc::c_int,
        dfPixErrThreshold: f64,
        papszOptions: *mut *mut libc::c_char,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn GDALDestroyRPCTransformer(pTransformArg: *mut libc::c_void);
}
extern "C" {
    pub fn GDALRPCTransform(
        pTransformArg: *mut libc::c_void,
        bDstToSrc: libc::c_int,
        nPointCount: libc::c_int,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
        panSuccess: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALCreateGeoLocTransformer(
        hBaseDS: GDALDatasetH,
        papszGeolocationInfo: *mut *mut libc::c_char,
        bReversed: libc::c_int,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn GDALDestroyGeoLocTransformer(pTransformArg: *mut libc::c_void);
}
extern "C" {
    pub fn GDALGeoLocTransform(
        pTransformArg: *mut libc::c_void,
        bDstToSrc: libc::c_int,
        nPointCount: libc::c_int,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
        panSuccess: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALCreateApproxTransformer(
        pfnRawTransformer: GDALTransformerFunc,
        pRawTransformerArg: *mut libc::c_void,
        dfMaxError: f64,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn GDALApproxTransformerOwnsSubtransformer(
        pCBData: *mut libc::c_void,
        bOwnFlag: libc::c_int,
    );
}
extern "C" {
    pub fn GDALDestroyApproxTransformer(pApproxArg: *mut libc::c_void);
}
extern "C" {
    pub fn GDALApproxTransform(
        pTransformArg: *mut libc::c_void,
        bDstToSrc: libc::c_int,
        nPointCount: libc::c_int,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
        panSuccess: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALSimpleImageWarp(
        hSrcDS: GDALDatasetH,
        hDstDS: GDALDatasetH,
        nBandCount: libc::c_int,
        panBandList: *mut libc::c_int,
        pfnTransform: GDALTransformerFunc,
        pTransformArg: *mut libc::c_void,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut libc::c_void,
        papszWarpOptions: *mut *mut libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALSuggestedWarpOutput(
        hSrcDS: GDALDatasetH,
        pfnTransformer: GDALTransformerFunc,
        pTransformArg: *mut libc::c_void,
        padfGeoTransformOut: *mut f64,
        pnPixels: *mut libc::c_int,
        pnLines: *mut libc::c_int,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALSuggestedWarpOutput2(
        hSrcDS: GDALDatasetH,
        pfnTransformer: GDALTransformerFunc,
        pTransformArg: *mut libc::c_void,
        padfGeoTransformOut: *mut f64,
        pnPixels: *mut libc::c_int,
        pnLines: *mut libc::c_int,
        padfExtents: *mut f64,
        nOptions: libc::c_int,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALSerializeTransformer(
        pfnFunc: GDALTransformerFunc,
        pTransformArg: *mut libc::c_void,
    ) -> *mut CPLXMLNode;
}
extern "C" {
    pub fn GDALDeserializeTransformer(
        psTree: *mut CPLXMLNode,
        ppfnFunc: *mut GDALTransformerFunc,
        ppTransformArg: *mut *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALTransformGeolocations(
        hXBand: GDALRasterBandH,
        hYBand: GDALRasterBandH,
        hZBand: GDALRasterBandH,
        pfnTransformer: GDALTransformerFunc,
        pTransformArg: *mut libc::c_void,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut libc::c_void,
        papszOptions: *mut *mut libc::c_char,
    ) -> CPLErr::Type;
}
pub type GDALContourWriter = ::std::option::Option<
    unsafe extern "C" fn(
        dfLevel: f64,
        nPoints: libc::c_int,
        padfX: *mut f64,
        padfY: *mut f64,
        arg1: *mut libc::c_void,
    ) -> CPLErr::Type,
>;
pub type GDALContourGeneratorH = *mut libc::c_void;
extern "C" {
    pub fn GDAL_CG_Create(
        nWidth: libc::c_int,
        nHeight: libc::c_int,
        bNoDataSet: libc::c_int,
        dfNoDataValue: f64,
        dfContourInterval: f64,
        dfContourBase: f64,
        pfnWriter: GDALContourWriter,
        pCBData: *mut libc::c_void,
    ) -> GDALContourGeneratorH;
}
extern "C" {
    pub fn GDAL_CG_FeedLine(hCG: GDALContourGeneratorH, padfScanline: *mut f64) -> CPLErr::Type;
}
extern "C" {
    pub fn GDAL_CG_Destroy(hCG: GDALContourGeneratorH);
}
extern "C" {
    pub fn OGRContourWriter(
        arg1: f64,
        arg2: libc::c_int,
        arg3: *mut f64,
        arg4: *mut f64,
        pInfo: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALContourGenerate(
        hBand: GDALRasterBandH,
        dfContourInterval: f64,
        dfContourBase: f64,
        nFixedLevelCount: libc::c_int,
        padfFixedLevels: *mut f64,
        bUseNoData: libc::c_int,
        dfNoDataValue: f64,
        hLayer: *mut libc::c_void,
        iIDField: libc::c_int,
        iElevField: libc::c_int,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALContourGenerateEx(
        hBand: GDALRasterBandH,
        hLayer: *mut libc::c_void,
        options: CSLConstList,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut libc::c_void,
    ) -> CPLErr::Type;
}
pub mod GDALViewshedMode {
    pub type Type = libc::c_uint;
    pub const GVM_Diagonal: Type = 1;
    pub const GVM_Edge: Type = 2;
    pub const GVM_Max: Type = 3;
    pub const GVM_Min: Type = 4;
}
pub mod GDALViewshedOutputType {
    pub type Type = libc::c_uint;
    pub const GVOT_NORMAL: Type = 1;
    pub const GVOT_MIN_TARGET_HEIGHT_FROM_DEM: Type = 2;
    pub const GVOT_MIN_TARGET_HEIGHT_FROM_GROUND: Type = 3;
}
extern "C" {
    pub fn GDALViewshedGenerate(
        hBand: GDALRasterBandH,
        pszDriverName: *const libc::c_char,
        pszTargetRasterName: *const libc::c_char,
        papszCreationOptions: CSLConstList,
        dfObserverX: f64,
        dfObserverY: f64,
        dfObserverHeight: f64,
        dfTargetHeight: f64,
        dfVisibleVal: f64,
        dfInvisibleVal: f64,
        dfOutOfRangeVal: f64,
        dfNoDataVal: f64,
        dfCurvCoeff: f64,
        eMode: GDALViewshedMode::Type,
        dfMaxDistance: f64,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut libc::c_void,
        heightMode: GDALViewshedOutputType::Type,
        papszExtraOptions: CSLConstList,
    ) -> GDALDatasetH;
}
extern "C" {
    pub fn GDALRasterizeGeometries(
        hDS: GDALDatasetH,
        nBandCount: libc::c_int,
        panBandList: *mut libc::c_int,
        nGeomCount: libc::c_int,
        pahGeometries: *mut OGRGeometryH,
        pfnTransformer: GDALTransformerFunc,
        pTransformArg: *mut libc::c_void,
        padfGeomBurnValue: *mut f64,
        papszOptions: *mut *mut libc::c_char,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRasterizeLayers(
        hDS: GDALDatasetH,
        nBandCount: libc::c_int,
        panBandList: *mut libc::c_int,
        nLayerCount: libc::c_int,
        pahLayers: *mut OGRLayerH,
        pfnTransformer: GDALTransformerFunc,
        pTransformArg: *mut libc::c_void,
        padfLayerBurnValues: *mut f64,
        papszOptions: *mut *mut libc::c_char,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRasterizeLayersBuf(
        pData: *mut libc::c_void,
        nBufXSize: libc::c_int,
        nBufYSize: libc::c_int,
        eBufType: GDALDataType::Type,
        nPixelSpace: libc::c_int,
        nLineSpace: libc::c_int,
        nLayerCount: libc::c_int,
        pahLayers: *mut OGRLayerH,
        pszDstProjection: *const libc::c_char,
        padfDstGeoTransform: *mut f64,
        pfnTransformer: GDALTransformerFunc,
        pTransformArg: *mut libc::c_void,
        dfBurnValue: f64,
        papszOptions: *mut *mut libc::c_char,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut libc::c_void,
    ) -> CPLErr::Type;
}
pub mod GDALGridAlgorithm {
    pub type Type = libc::c_uint;
    pub const GGA_InverseDistanceToAPower: Type = 1;
    pub const GGA_MovingAverage: Type = 2;
    pub const GGA_NearestNeighbor: Type = 3;
    pub const GGA_MetricMinimum: Type = 4;
    pub const GGA_MetricMaximum: Type = 5;
    pub const GGA_MetricRange: Type = 6;
    pub const GGA_MetricCount: Type = 7;
    pub const GGA_MetricAverageDistance: Type = 8;
    pub const GGA_MetricAverageDistancePts: Type = 9;
    pub const GGA_Linear: Type = 10;
    pub const GGA_InverseDistanceToAPowerNearestNeighbor: Type = 11;
}
extern "C" {
    pub fn GDALGridCreate(
        arg1: GDALGridAlgorithm::Type,
        arg2: *const libc::c_void,
        arg3: GUInt32,
        arg4: *const f64,
        arg5: *const f64,
        arg6: *const f64,
        arg7: f64,
        arg8: f64,
        arg9: f64,
        arg10: f64,
        arg11: GUInt32,
        arg12: GUInt32,
        arg13: GDALDataType::Type,
        arg14: *mut libc::c_void,
        arg15: GDALProgressFunc,
        arg16: *mut libc::c_void,
    ) -> CPLErr::Type;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALGridContext {
    _unused: [u8; 0],
}
extern "C" {
    pub fn GDALGridContextCreate(
        eAlgorithm: GDALGridAlgorithm::Type,
        poOptions: *const libc::c_void,
        nPoints: GUInt32,
        padfX: *const f64,
        padfY: *const f64,
        padfZ: *const f64,
        bCallerWillKeepPointArraysAlive: libc::c_int,
    ) -> *mut GDALGridContext;
}
extern "C" {
    pub fn GDALGridContextFree(psContext: *mut GDALGridContext);
}
extern "C" {
    pub fn GDALGridContextProcess(
        psContext: *mut GDALGridContext,
        dfXMin: f64,
        dfXMax: f64,
        dfYMin: f64,
        dfYMax: f64,
        nXSize: GUInt32,
        nYSize: GUInt32,
        eType: GDALDataType::Type,
        pData: *mut libc::c_void,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALComputeMatchingPoints(
        hFirstImage: GDALDatasetH,
        hSecondImage: GDALDatasetH,
        papszOptions: *mut *mut libc::c_char,
        pnGCPCount: *mut libc::c_int,
    ) -> *mut GDAL_GCP;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALTriFacet {
    pub anVertexIdx: [libc::c_int; 3usize],
    pub anNeighborIdx: [libc::c_int; 3usize],
}
#[test]
fn bindgen_test_layout_GDALTriFacet() {
    assert_eq!(
        ::std::mem::size_of::<GDALTriFacet>(),
        24usize,
        concat!("Size of: ", stringify!(GDALTriFacet))
    );
    assert_eq!(
        ::std::mem::align_of::<GDALTriFacet>(),
        4usize,
        concat!("Alignment of ", stringify!(GDALTriFacet))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALTriFacet>())).anVertexIdx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALTriFacet),
            "::",
            stringify!(anVertexIdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALTriFacet>())).anNeighborIdx as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALTriFacet),
            "::",
            stringify!(anNeighborIdx)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALTriBarycentricCoefficients {
    pub dfMul1X: f64,
    pub dfMul1Y: f64,
    pub dfMul2X: f64,
    pub dfMul2Y: f64,
    pub dfCstX: f64,
    pub dfCstY: f64,
}
#[test]
fn bindgen_test_layout_GDALTriBarycentricCoefficients() {
    assert_eq!(
        ::std::mem::size_of::<GDALTriBarycentricCoefficients>(),
        48usize,
        concat!("Size of: ", stringify!(GDALTriBarycentricCoefficients))
    );
    assert_eq!(
        ::std::mem::align_of::<GDALTriBarycentricCoefficients>(),
        8usize,
        concat!("Alignment of ", stringify!(GDALTriBarycentricCoefficients))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALTriBarycentricCoefficients>())).dfMul1X as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALTriBarycentricCoefficients),
            "::",
            stringify!(dfMul1X)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALTriBarycentricCoefficients>())).dfMul1Y as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALTriBarycentricCoefficients),
            "::",
            stringify!(dfMul1Y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALTriBarycentricCoefficients>())).dfMul2X as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALTriBarycentricCoefficients),
            "::",
            stringify!(dfMul2X)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALTriBarycentricCoefficients>())).dfMul2Y as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALTriBarycentricCoefficients),
            "::",
            stringify!(dfMul2Y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALTriBarycentricCoefficients>())).dfCstX as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALTriBarycentricCoefficients),
            "::",
            stringify!(dfCstX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALTriBarycentricCoefficients>())).dfCstY as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALTriBarycentricCoefficients),
            "::",
            stringify!(dfCstY)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALTriangulation {
    pub nFacets: libc::c_int,
    pub pasFacets: *mut GDALTriFacet,
    pub pasFacetCoefficients: *mut GDALTriBarycentricCoefficients,
}
#[test]
fn bindgen_test_layout_GDALTriangulation() {
    assert_eq!(
        ::std::mem::size_of::<GDALTriangulation>(),
        24usize,
        concat!("Size of: ", stringify!(GDALTriangulation))
    );
    assert_eq!(
        ::std::mem::align_of::<GDALTriangulation>(),
        8usize,
        concat!("Alignment of ", stringify!(GDALTriangulation))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALTriangulation>())).nFacets as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALTriangulation),
            "::",
            stringify!(nFacets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALTriangulation>())).pasFacets as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALTriangulation),
            "::",
            stringify!(pasFacets)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALTriangulation>())).pasFacetCoefficients as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALTriangulation),
            "::",
            stringify!(pasFacetCoefficients)
        )
    );
}
extern "C" {
    pub fn GDALHasTriangulation() -> libc::c_int;
}
extern "C" {
    pub fn GDALTriangulationCreateDelaunay(
        nPoints: libc::c_int,
        padfX: *const f64,
        padfY: *const f64,
    ) -> *mut GDALTriangulation;
}
extern "C" {
    pub fn GDALTriangulationComputeBarycentricCoefficients(
        psDT: *mut GDALTriangulation,
        padfX: *const f64,
        padfY: *const f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALTriangulationComputeBarycentricCoordinates(
        psDT: *const GDALTriangulation,
        nFacetIdx: libc::c_int,
        dfX: f64,
        dfY: f64,
        pdfL1: *mut f64,
        pdfL2: *mut f64,
        pdfL3: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALTriangulationFindFacetBruteForce(
        psDT: *const GDALTriangulation,
        dfX: f64,
        dfY: f64,
        panOutputFacetIdx: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALTriangulationFindFacetDirected(
        psDT: *const GDALTriangulation,
        nFacetIdx: libc::c_int,
        dfX: f64,
        dfY: f64,
        panOutputFacetIdx: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALTriangulationFree(psDT: *mut GDALTriangulation);
}
extern "C" {
    pub fn GDALTriangulationTerminate();
}
extern "C" {
    pub fn GDALOpenVerticalShiftGrid(
        pszProj4Geoidgrids: *const libc::c_char,
        pbError: *mut libc::c_int,
    ) -> GDALDatasetH;
}
extern "C" {
    pub fn GDALApplyVerticalShiftGrid(
        hSrcDataset: GDALDatasetH,
        hGridDataset: GDALDatasetH,
        bInverse: libc::c_int,
        dfSrcUnitToMeter: f64,
        dfDstUnitToMeter: f64,
        papszOptions: *const *const libc::c_char,
    ) -> GDALDatasetH;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALInfoOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALInfoOptionsForBinary {
    _unused: [u8; 0],
}
extern "C" {
    pub fn GDALInfoOptionsNew(
        papszArgv: *mut *mut libc::c_char,
        psOptionsForBinary: *mut GDALInfoOptionsForBinary,
    ) -> *mut GDALInfoOptions;
}
extern "C" {
    pub fn GDALInfoOptionsFree(psOptions: *mut GDALInfoOptions);
}
extern "C" {
    pub fn GDALInfo(hDataset: GDALDatasetH, psOptions: *const GDALInfoOptions)
        -> *mut libc::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALTranslateOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALTranslateOptionsForBinary {
    _unused: [u8; 0],
}
extern "C" {
    pub fn GDALTranslateOptionsNew(
        papszArgv: *mut *mut libc::c_char,
        psOptionsForBinary: *mut GDALTranslateOptionsForBinary,
    ) -> *mut GDALTranslateOptions;
}
extern "C" {
    pub fn GDALTranslateOptionsFree(psOptions: *mut GDALTranslateOptions);
}
extern "C" {
    pub fn GDALTranslateOptionsSetProgress(
        psOptions: *mut GDALTranslateOptions,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
    );
}
extern "C" {
    pub fn GDALTranslate(
        pszDestFilename: *const libc::c_char,
        hSrcDataset: GDALDatasetH,
        psOptions: *const GDALTranslateOptions,
        pbUsageError: *mut libc::c_int,
    ) -> GDALDatasetH;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALWarpAppOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALWarpAppOptionsForBinary {
    _unused: [u8; 0],
}
extern "C" {
    pub fn GDALWarpAppOptionsNew(
        papszArgv: *mut *mut libc::c_char,
        psOptionsForBinary: *mut GDALWarpAppOptionsForBinary,
    ) -> *mut GDALWarpAppOptions;
}
extern "C" {
    pub fn GDALWarpAppOptionsFree(psOptions: *mut GDALWarpAppOptions);
}
extern "C" {
    pub fn GDALWarpAppOptionsSetProgress(
        psOptions: *mut GDALWarpAppOptions,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
    );
}
extern "C" {
    pub fn GDALWarpAppOptionsSetQuiet(psOptions: *mut GDALWarpAppOptions, bQuiet: libc::c_int);
}
extern "C" {
    pub fn GDALWarpAppOptionsSetWarpOption(
        psOptions: *mut GDALWarpAppOptions,
        pszKey: *const libc::c_char,
        pszValue: *const libc::c_char,
    );
}
extern "C" {
    pub fn GDALWarp(
        pszDest: *const libc::c_char,
        hDstDS: GDALDatasetH,
        nSrcCount: libc::c_int,
        pahSrcDS: *mut GDALDatasetH,
        psOptions: *const GDALWarpAppOptions,
        pbUsageError: *mut libc::c_int,
    ) -> GDALDatasetH;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALVectorTranslateOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALVectorTranslateOptionsForBinary {
    _unused: [u8; 0],
}
extern "C" {
    pub fn GDALVectorTranslateOptionsNew(
        papszArgv: *mut *mut libc::c_char,
        psOptionsForBinary: *mut GDALVectorTranslateOptionsForBinary,
    ) -> *mut GDALVectorTranslateOptions;
}
extern "C" {
    pub fn GDALVectorTranslateOptionsFree(psOptions: *mut GDALVectorTranslateOptions);
}
extern "C" {
    pub fn GDALVectorTranslateOptionsSetProgress(
        psOptions: *mut GDALVectorTranslateOptions,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
    );
}
extern "C" {
    pub fn GDALVectorTranslate(
        pszDest: *const libc::c_char,
        hDstDS: GDALDatasetH,
        nSrcCount: libc::c_int,
        pahSrcDS: *mut GDALDatasetH,
        psOptions: *const GDALVectorTranslateOptions,
        pbUsageError: *mut libc::c_int,
    ) -> GDALDatasetH;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALDEMProcessingOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALDEMProcessingOptionsForBinary {
    _unused: [u8; 0],
}
extern "C" {
    pub fn GDALDEMProcessingOptionsNew(
        papszArgv: *mut *mut libc::c_char,
        psOptionsForBinary: *mut GDALDEMProcessingOptionsForBinary,
    ) -> *mut GDALDEMProcessingOptions;
}
extern "C" {
    pub fn GDALDEMProcessingOptionsFree(psOptions: *mut GDALDEMProcessingOptions);
}
extern "C" {
    pub fn GDALDEMProcessingOptionsSetProgress(
        psOptions: *mut GDALDEMProcessingOptions,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
    );
}
extern "C" {
    pub fn GDALDEMProcessing(
        pszDestFilename: *const libc::c_char,
        hSrcDataset: GDALDatasetH,
        pszProcessing: *const libc::c_char,
        pszColorFilename: *const libc::c_char,
        psOptions: *const GDALDEMProcessingOptions,
        pbUsageError: *mut libc::c_int,
    ) -> GDALDatasetH;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALNearblackOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALNearblackOptionsForBinary {
    _unused: [u8; 0],
}
extern "C" {
    pub fn GDALNearblackOptionsNew(
        papszArgv: *mut *mut libc::c_char,
        psOptionsForBinary: *mut GDALNearblackOptionsForBinary,
    ) -> *mut GDALNearblackOptions;
}
extern "C" {
    pub fn GDALNearblackOptionsFree(psOptions: *mut GDALNearblackOptions);
}
extern "C" {
    pub fn GDALNearblackOptionsSetProgress(
        psOptions: *mut GDALNearblackOptions,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
    );
}
extern "C" {
    pub fn GDALNearblack(
        pszDest: *const libc::c_char,
        hDstDS: GDALDatasetH,
        hSrcDS: GDALDatasetH,
        psOptions: *const GDALNearblackOptions,
        pbUsageError: *mut libc::c_int,
    ) -> GDALDatasetH;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALGridOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALGridOptionsForBinary {
    _unused: [u8; 0],
}
extern "C" {
    pub fn GDALGridOptionsNew(
        papszArgv: *mut *mut libc::c_char,
        psOptionsForBinary: *mut GDALGridOptionsForBinary,
    ) -> *mut GDALGridOptions;
}
extern "C" {
    pub fn GDALGridOptionsFree(psOptions: *mut GDALGridOptions);
}
extern "C" {
    pub fn GDALGridOptionsSetProgress(
        psOptions: *mut GDALGridOptions,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
    );
}
extern "C" {
    pub fn GDALGrid(
        pszDest: *const libc::c_char,
        hSrcDS: GDALDatasetH,
        psOptions: *const GDALGridOptions,
        pbUsageError: *mut libc::c_int,
    ) -> GDALDatasetH;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALRasterizeOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALRasterizeOptionsForBinary {
    _unused: [u8; 0],
}
extern "C" {
    pub fn GDALRasterizeOptionsNew(
        papszArgv: *mut *mut libc::c_char,
        psOptionsForBinary: *mut GDALRasterizeOptionsForBinary,
    ) -> *mut GDALRasterizeOptions;
}
extern "C" {
    pub fn GDALRasterizeOptionsFree(psOptions: *mut GDALRasterizeOptions);
}
extern "C" {
    pub fn GDALRasterizeOptionsSetProgress(
        psOptions: *mut GDALRasterizeOptions,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
    );
}
extern "C" {
    pub fn GDALRasterize(
        pszDest: *const libc::c_char,
        hDstDS: GDALDatasetH,
        hSrcDS: GDALDatasetH,
        psOptions: *const GDALRasterizeOptions,
        pbUsageError: *mut libc::c_int,
    ) -> GDALDatasetH;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALBuildVRTOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALBuildVRTOptionsForBinary {
    _unused: [u8; 0],
}
extern "C" {
    pub fn GDALBuildVRTOptionsNew(
        papszArgv: *mut *mut libc::c_char,
        psOptionsForBinary: *mut GDALBuildVRTOptionsForBinary,
    ) -> *mut GDALBuildVRTOptions;
}
extern "C" {
    pub fn GDALBuildVRTOptionsFree(psOptions: *mut GDALBuildVRTOptions);
}
extern "C" {
    pub fn GDALBuildVRTOptionsSetProgress(
        psOptions: *mut GDALBuildVRTOptions,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
    );
}
extern "C" {
    pub fn GDALBuildVRT(
        pszDest: *const libc::c_char,
        nSrcCount: libc::c_int,
        pahSrcDS: *mut GDALDatasetH,
        papszSrcDSNames: *const *const libc::c_char,
        psOptions: *const GDALBuildVRTOptions,
        pbUsageError: *mut libc::c_int,
    ) -> GDALDatasetH;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALMultiDimInfoOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALMultiDimInfoOptionsForBinary {
    _unused: [u8; 0],
}
extern "C" {
    pub fn GDALMultiDimInfoOptionsNew(
        papszArgv: *mut *mut libc::c_char,
        psOptionsForBinary: *mut GDALMultiDimInfoOptionsForBinary,
    ) -> *mut GDALMultiDimInfoOptions;
}
extern "C" {
    pub fn GDALMultiDimInfoOptionsFree(psOptions: *mut GDALMultiDimInfoOptions);
}
extern "C" {
    pub fn GDALMultiDimInfo(
        hDataset: GDALDatasetH,
        psOptions: *const GDALMultiDimInfoOptions,
    ) -> *mut libc::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALMultiDimTranslateOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALMultiDimTranslateOptionsForBinary {
    _unused: [u8; 0],
}
extern "C" {
    pub fn GDALMultiDimTranslateOptionsNew(
        papszArgv: *mut *mut libc::c_char,
        psOptionsForBinary: *mut GDALMultiDimTranslateOptionsForBinary,
    ) -> *mut GDALMultiDimTranslateOptions;
}
extern "C" {
    pub fn GDALMultiDimTranslateOptionsFree(psOptions: *mut GDALMultiDimTranslateOptions);
}
extern "C" {
    pub fn GDALMultiDimTranslateOptionsSetProgress(
        psOptions: *mut GDALMultiDimTranslateOptions,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
    );
}
extern "C" {
    pub fn GDALMultiDimTranslate(
        pszDest: *const libc::c_char,
        hDstDataset: GDALDatasetH,
        nSrcCount: libc::c_int,
        pahSrcDS: *mut GDALDatasetH,
        psOptions: *const GDALMultiDimTranslateOptions,
        pbUsageError: *mut libc::c_int,
    ) -> GDALDatasetH;
}
pub mod OGRAxisOrientation {
    pub type Type = libc::c_uint;
    pub const OAO_Other: Type = 0;
    pub const OAO_North: Type = 1;
    pub const OAO_South: Type = 2;
    pub const OAO_East: Type = 3;
    pub const OAO_West: Type = 4;
    pub const OAO_Up: Type = 5;
    pub const OAO_Down: Type = 6;
}
extern "C" {
    pub fn OSRAxisEnumToName(eOrientation: OGRAxisOrientation::Type) -> *const libc::c_char;
}
extern "C" {
    pub fn OSRSetPROJSearchPaths(papszPaths: *const *const libc::c_char);
}
extern "C" {
    pub fn OSRGetPROJSearchPaths() -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn OSRGetPROJVersion(
        pnMajor: *mut libc::c_int,
        pnMinor: *mut libc::c_int,
        pnPatch: *mut libc::c_int,
    );
}
extern "C" {
    pub fn OSRNewSpatialReference(arg1: *const libc::c_char) -> OGRSpatialReferenceH;
}
extern "C" {
    pub fn OSRCloneGeogCS(arg1: OGRSpatialReferenceH) -> OGRSpatialReferenceH;
}
extern "C" {
    pub fn OSRClone(arg1: OGRSpatialReferenceH) -> OGRSpatialReferenceH;
}
extern "C" {
    pub fn OSRDestroySpatialReference(arg1: OGRSpatialReferenceH);
}
extern "C" {
    pub fn OSRReference(arg1: OGRSpatialReferenceH) -> libc::c_int;
}
extern "C" {
    pub fn OSRDereference(arg1: OGRSpatialReferenceH) -> libc::c_int;
}
extern "C" {
    pub fn OSRRelease(arg1: OGRSpatialReferenceH);
}
extern "C" {
    pub fn OSRValidate(arg1: OGRSpatialReferenceH) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRImportFromEPSG(arg1: OGRSpatialReferenceH, arg2: libc::c_int) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRImportFromEPSGA(arg1: OGRSpatialReferenceH, arg2: libc::c_int) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRImportFromWkt(
        arg1: OGRSpatialReferenceH,
        arg2: *mut *mut libc::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRImportFromProj4(
        arg1: OGRSpatialReferenceH,
        arg2: *const libc::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRImportFromESRI(
        arg1: OGRSpatialReferenceH,
        arg2: *mut *mut libc::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRImportFromPCI(
        hSRS: OGRSpatialReferenceH,
        arg1: *const libc::c_char,
        arg2: *const libc::c_char,
        arg3: *mut f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRImportFromUSGS(
        arg1: OGRSpatialReferenceH,
        arg2: libc::c_long,
        arg3: libc::c_long,
        arg4: *mut f64,
        arg5: libc::c_long,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRImportFromXML(arg1: OGRSpatialReferenceH, arg2: *const libc::c_char) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRImportFromDict(
        arg1: OGRSpatialReferenceH,
        arg2: *const libc::c_char,
        arg3: *const libc::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRImportFromPanorama(
        arg1: OGRSpatialReferenceH,
        arg2: libc::c_long,
        arg3: libc::c_long,
        arg4: libc::c_long,
        arg5: *mut f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRImportFromOzi(
        arg1: OGRSpatialReferenceH,
        arg2: *const *const libc::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRImportFromMICoordSys(
        arg1: OGRSpatialReferenceH,
        arg2: *const libc::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRImportFromERM(
        arg1: OGRSpatialReferenceH,
        arg2: *const libc::c_char,
        arg3: *const libc::c_char,
        arg4: *const libc::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRImportFromUrl(arg1: OGRSpatialReferenceH, arg2: *const libc::c_char) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRExportToWkt(arg1: OGRSpatialReferenceH, arg2: *mut *mut libc::c_char)
        -> OGRErr::Type;
}
extern "C" {
    pub fn OSRExportToWktEx(
        arg1: OGRSpatialReferenceH,
        ppszResult: *mut *mut libc::c_char,
        papszOptions: *const *const libc::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRExportToPrettyWkt(
        arg1: OGRSpatialReferenceH,
        arg2: *mut *mut libc::c_char,
        arg3: libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRExportToPROJJSON(
        hSRS: OGRSpatialReferenceH,
        ppszReturn: *mut *mut libc::c_char,
        papszOptions: *const *const libc::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRExportToProj4(
        arg1: OGRSpatialReferenceH,
        arg2: *mut *mut libc::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRExportToPCI(
        arg1: OGRSpatialReferenceH,
        arg2: *mut *mut libc::c_char,
        arg3: *mut *mut libc::c_char,
        arg4: *mut *mut f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRExportToUSGS(
        arg1: OGRSpatialReferenceH,
        arg2: *mut libc::c_long,
        arg3: *mut libc::c_long,
        arg4: *mut *mut f64,
        arg5: *mut libc::c_long,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRExportToXML(
        arg1: OGRSpatialReferenceH,
        arg2: *mut *mut libc::c_char,
        arg3: *const libc::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRExportToPanorama(
        arg1: OGRSpatialReferenceH,
        arg2: *mut libc::c_long,
        arg3: *mut libc::c_long,
        arg4: *mut libc::c_long,
        arg5: *mut libc::c_long,
        arg6: *mut f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRExportToMICoordSys(
        arg1: OGRSpatialReferenceH,
        arg2: *mut *mut libc::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRExportToERM(
        arg1: OGRSpatialReferenceH,
        arg2: *mut libc::c_char,
        arg3: *mut libc::c_char,
        arg4: *mut libc::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRMorphToESRI(arg1: OGRSpatialReferenceH) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRMorphFromESRI(arg1: OGRSpatialReferenceH) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRConvertToOtherProjection(
        hSRS: OGRSpatialReferenceH,
        pszTargetProjection: *const libc::c_char,
        papszOptions: *const *const libc::c_char,
    ) -> OGRSpatialReferenceH;
}
extern "C" {
    pub fn OSRGetName(hSRS: OGRSpatialReferenceH) -> *const libc::c_char;
}
extern "C" {
    pub fn OSRSetAttrValue(
        hSRS: OGRSpatialReferenceH,
        pszNodePath: *const libc::c_char,
        pszNewNodeValue: *const libc::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRGetAttrValue(
        hSRS: OGRSpatialReferenceH,
        pszName: *const libc::c_char,
        iChild: libc::c_int,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn OSRSetAngularUnits(
        arg1: OGRSpatialReferenceH,
        arg2: *const libc::c_char,
        arg3: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRGetAngularUnits(arg1: OGRSpatialReferenceH, arg2: *mut *mut libc::c_char) -> f64;
}
extern "C" {
    pub fn OSRSetLinearUnits(
        arg1: OGRSpatialReferenceH,
        arg2: *const libc::c_char,
        arg3: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetTargetLinearUnits(
        arg1: OGRSpatialReferenceH,
        arg2: *const libc::c_char,
        arg3: *const libc::c_char,
        arg4: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetLinearUnitsAndUpdateParameters(
        arg1: OGRSpatialReferenceH,
        arg2: *const libc::c_char,
        arg3: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRGetLinearUnits(arg1: OGRSpatialReferenceH, arg2: *mut *mut libc::c_char) -> f64;
}
extern "C" {
    pub fn OSRGetTargetLinearUnits(
        arg1: OGRSpatialReferenceH,
        arg2: *const libc::c_char,
        arg3: *mut *mut libc::c_char,
    ) -> f64;
}
extern "C" {
    pub fn OSRGetPrimeMeridian(arg1: OGRSpatialReferenceH, arg2: *mut *mut libc::c_char) -> f64;
}
extern "C" {
    pub fn OSRIsGeographic(arg1: OGRSpatialReferenceH) -> libc::c_int;
}
extern "C" {
    pub fn OSRIsDerivedGeographic(arg1: OGRSpatialReferenceH) -> libc::c_int;
}
extern "C" {
    pub fn OSRIsLocal(arg1: OGRSpatialReferenceH) -> libc::c_int;
}
extern "C" {
    pub fn OSRIsProjected(arg1: OGRSpatialReferenceH) -> libc::c_int;
}
extern "C" {
    pub fn OSRIsCompound(arg1: OGRSpatialReferenceH) -> libc::c_int;
}
extern "C" {
    pub fn OSRIsGeocentric(arg1: OGRSpatialReferenceH) -> libc::c_int;
}
extern "C" {
    pub fn OSRIsVertical(arg1: OGRSpatialReferenceH) -> libc::c_int;
}
extern "C" {
    pub fn OSRIsSameGeogCS(arg1: OGRSpatialReferenceH, arg2: OGRSpatialReferenceH) -> libc::c_int;
}
extern "C" {
    pub fn OSRIsSameVertCS(arg1: OGRSpatialReferenceH, arg2: OGRSpatialReferenceH) -> libc::c_int;
}
extern "C" {
    pub fn OSRIsSame(arg1: OGRSpatialReferenceH, arg2: OGRSpatialReferenceH) -> libc::c_int;
}
extern "C" {
    pub fn OSRIsSameEx(
        arg1: OGRSpatialReferenceH,
        arg2: OGRSpatialReferenceH,
        papszOptions: *const *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OSRSetLocalCS(hSRS: OGRSpatialReferenceH, pszName: *const libc::c_char) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetProjCS(hSRS: OGRSpatialReferenceH, pszName: *const libc::c_char) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetGeocCS(hSRS: OGRSpatialReferenceH, pszName: *const libc::c_char) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetWellKnownGeogCS(
        hSRS: OGRSpatialReferenceH,
        pszName: *const libc::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetFromUserInput(
        hSRS: OGRSpatialReferenceH,
        arg1: *const libc::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRCopyGeogCSFrom(
        hSRS: OGRSpatialReferenceH,
        hSrcSRS: OGRSpatialReferenceH,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetTOWGS84(
        hSRS: OGRSpatialReferenceH,
        arg1: f64,
        arg2: f64,
        arg3: f64,
        arg4: f64,
        arg5: f64,
        arg6: f64,
        arg7: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRGetTOWGS84(
        hSRS: OGRSpatialReferenceH,
        arg1: *mut f64,
        arg2: libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRAddGuessedTOWGS84(hSRS: OGRSpatialReferenceH) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetCompoundCS(
        hSRS: OGRSpatialReferenceH,
        pszName: *const libc::c_char,
        hHorizSRS: OGRSpatialReferenceH,
        hVertSRS: OGRSpatialReferenceH,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRPromoteTo3D(hSRS: OGRSpatialReferenceH, pszName: *const libc::c_char)
        -> OGRErr::Type;
}
extern "C" {
    pub fn OSRDemoteTo2D(hSRS: OGRSpatialReferenceH, pszName: *const libc::c_char) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetGeogCS(
        hSRS: OGRSpatialReferenceH,
        pszGeogName: *const libc::c_char,
        pszDatumName: *const libc::c_char,
        pszEllipsoidName: *const libc::c_char,
        dfSemiMajor: f64,
        dfInvFlattening: f64,
        pszPMName: *const libc::c_char,
        dfPMOffset: f64,
        pszUnits: *const libc::c_char,
        dfConvertToRadians: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetVertCS(
        hSRS: OGRSpatialReferenceH,
        pszVertCSName: *const libc::c_char,
        pszVertDatumName: *const libc::c_char,
        nVertDatumType: libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRGetSemiMajor(arg1: OGRSpatialReferenceH, arg2: *mut OGRErr::Type) -> f64;
}
extern "C" {
    pub fn OSRGetSemiMinor(arg1: OGRSpatialReferenceH, arg2: *mut OGRErr::Type) -> f64;
}
extern "C" {
    pub fn OSRGetInvFlattening(arg1: OGRSpatialReferenceH, arg2: *mut OGRErr::Type) -> f64;
}
extern "C" {
    pub fn OSRSetAuthority(
        hSRS: OGRSpatialReferenceH,
        pszTargetKey: *const libc::c_char,
        pszAuthority: *const libc::c_char,
        nCode: libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRGetAuthorityCode(
        hSRS: OGRSpatialReferenceH,
        pszTargetKey: *const libc::c_char,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn OSRGetAuthorityName(
        hSRS: OGRSpatialReferenceH,
        pszTargetKey: *const libc::c_char,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn OSRGetAreaOfUse(
        hSRS: OGRSpatialReferenceH,
        pdfWestLongitudeDeg: *mut f64,
        pdfSouthLatitudeDeg: *mut f64,
        pdfEastLongitudeDeg: *mut f64,
        pdfNorthLatitudeDeg: *mut f64,
        ppszAreaName: *mut *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OSRSetProjection(arg1: OGRSpatialReferenceH, arg2: *const libc::c_char) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetProjParm(
        arg1: OGRSpatialReferenceH,
        arg2: *const libc::c_char,
        arg3: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRGetProjParm(
        hSRS: OGRSpatialReferenceH,
        pszParmName: *const libc::c_char,
        dfDefault: f64,
        arg1: *mut OGRErr::Type,
    ) -> f64;
}
extern "C" {
    pub fn OSRSetNormProjParm(
        arg1: OGRSpatialReferenceH,
        arg2: *const libc::c_char,
        arg3: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRGetNormProjParm(
        hSRS: OGRSpatialReferenceH,
        pszParmName: *const libc::c_char,
        dfDefault: f64,
        arg1: *mut OGRErr::Type,
    ) -> f64;
}
extern "C" {
    pub fn OSRSetUTM(
        hSRS: OGRSpatialReferenceH,
        nZone: libc::c_int,
        bNorth: libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRGetUTMZone(hSRS: OGRSpatialReferenceH, pbNorth: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn OSRSetStatePlane(
        hSRS: OGRSpatialReferenceH,
        nZone: libc::c_int,
        bNAD83: libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetStatePlaneWithUnits(
        hSRS: OGRSpatialReferenceH,
        nZone: libc::c_int,
        bNAD83: libc::c_int,
        pszOverrideUnitName: *const libc::c_char,
        dfOverrideUnit: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRAutoIdentifyEPSG(hSRS: OGRSpatialReferenceH) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRFindMatches(
        hSRS: OGRSpatialReferenceH,
        papszOptions: *mut *mut libc::c_char,
        pnEntries: *mut libc::c_int,
        ppanMatchConfidence: *mut *mut libc::c_int,
    ) -> *mut OGRSpatialReferenceH;
}
extern "C" {
    pub fn OSRFreeSRSArray(pahSRS: *mut OGRSpatialReferenceH);
}
extern "C" {
    pub fn OSREPSGTreatsAsLatLong(hSRS: OGRSpatialReferenceH) -> libc::c_int;
}
extern "C" {
    pub fn OSREPSGTreatsAsNorthingEasting(hSRS: OGRSpatialReferenceH) -> libc::c_int;
}
extern "C" {
    pub fn OSRGetAxis(
        hSRS: OGRSpatialReferenceH,
        pszTargetKey: *const libc::c_char,
        iAxis: libc::c_int,
        peOrientation: *mut OGRAxisOrientation::Type,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn OSRGetAxesCount(hSRS: OGRSpatialReferenceH) -> libc::c_int;
}
extern "C" {
    pub fn OSRSetAxes(
        hSRS: OGRSpatialReferenceH,
        pszTargetKey: *const libc::c_char,
        pszXAxisName: *const libc::c_char,
        eXAxisOrientation: OGRAxisOrientation::Type,
        pszYAxisName: *const libc::c_char,
        eYAxisOrientation: OGRAxisOrientation::Type,
    ) -> OGRErr::Type;
}
pub mod OSRAxisMappingStrategy {
    pub type Type = libc::c_uint;
    pub const OAMS_TRADITIONAL_GIS_ORDER: Type = 0;
    pub const OAMS_AUTHORITY_COMPLIANT: Type = 1;
    pub const OAMS_CUSTOM: Type = 2;
}
extern "C" {
    pub fn OSRGetAxisMappingStrategy(hSRS: OGRSpatialReferenceH) -> OSRAxisMappingStrategy::Type;
}
extern "C" {
    pub fn OSRSetAxisMappingStrategy(
        hSRS: OGRSpatialReferenceH,
        strategy: OSRAxisMappingStrategy::Type,
    );
}
extern "C" {
    pub fn OSRGetDataAxisToSRSAxisMapping(
        hSRS: OGRSpatialReferenceH,
        pnCount: *mut libc::c_int,
    ) -> *const libc::c_int;
}
extern "C" {
    pub fn OSRSetDataAxisToSRSAxisMapping(
        hSRS: OGRSpatialReferenceH,
        nMappingSize: libc::c_int,
        panMapping: *const libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetACEA(
        hSRS: OGRSpatialReferenceH,
        dfStdP1: f64,
        dfStdP2: f64,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetAE(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetBonne(
        hSRS: OGRSpatialReferenceH,
        dfStandardParallel: f64,
        dfCentralMeridian: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetCEA(
        hSRS: OGRSpatialReferenceH,
        dfStdP1: f64,
        dfCentralMeridian: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetCS(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetEC(
        hSRS: OGRSpatialReferenceH,
        dfStdP1: f64,
        dfStdP2: f64,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetEckert(
        hSRS: OGRSpatialReferenceH,
        nVariation: libc::c_int,
        dfCentralMeridian: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetEckertIV(
        hSRS: OGRSpatialReferenceH,
        dfCentralMeridian: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetEckertVI(
        hSRS: OGRSpatialReferenceH,
        dfCentralMeridian: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetEquirectangular(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetEquirectangular2(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfPseudoStdParallel1: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetGS(
        hSRS: OGRSpatialReferenceH,
        dfCentralMeridian: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetGH(
        hSRS: OGRSpatialReferenceH,
        dfCentralMeridian: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetIGH(hSRS: OGRSpatialReferenceH) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetGEOS(
        hSRS: OGRSpatialReferenceH,
        dfCentralMeridian: f64,
        dfSatelliteHeight: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetGaussSchreiberTMercator(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfScale: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetGnomonic(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetHOM(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfAzimuth: f64,
        dfRectToSkew: f64,
        dfScale: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetHOMAC(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfAzimuth: f64,
        dfRectToSkew: f64,
        dfScale: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetHOM2PNO(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfLat1: f64,
        dfLong1: f64,
        dfLat2: f64,
        dfLong2: f64,
        dfScale: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetIWMPolyconic(
        hSRS: OGRSpatialReferenceH,
        dfLat1: f64,
        dfLat2: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetKrovak(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfAzimuth: f64,
        dfPseudoStdParallelLat: f64,
        dfScale: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetLAEA(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetLCC(
        hSRS: OGRSpatialReferenceH,
        dfStdP1: f64,
        dfStdP2: f64,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetLCC1SP(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfScale: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetLCCB(
        hSRS: OGRSpatialReferenceH,
        dfStdP1: f64,
        dfStdP2: f64,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetMC(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetMercator(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfScale: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetMercator2SP(
        hSRS: OGRSpatialReferenceH,
        dfStdP1: f64,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetMollweide(
        hSRS: OGRSpatialReferenceH,
        dfCentralMeridian: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetNZMG(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetOS(
        hSRS: OGRSpatialReferenceH,
        dfOriginLat: f64,
        dfCMeridian: f64,
        dfScale: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetOrthographic(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetPolyconic(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetPS(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfScale: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetRobinson(
        hSRS: OGRSpatialReferenceH,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetSinusoidal(
        hSRS: OGRSpatialReferenceH,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetStereographic(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfScale: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetSOC(
        hSRS: OGRSpatialReferenceH,
        dfLatitudeOfOrigin: f64,
        dfCentralMeridian: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetTM(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfScale: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetTMVariant(
        hSRS: OGRSpatialReferenceH,
        pszVariantName: *const libc::c_char,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfScale: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetTMG(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetTMSO(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfScale: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetTPED(
        hSRS: OGRSpatialReferenceH,
        dfLat1: f64,
        dfLong1: f64,
        dfLat2: f64,
        dfLong2: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetVDG(
        hSRS: OGRSpatialReferenceH,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetWagner(
        hSRS: OGRSpatialReferenceH,
        nVariation: libc::c_int,
        dfCenterLat: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetQSC(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetSCH(
        hSRS: OGRSpatialReferenceH,
        dfPegLat: f64,
        dfPegLong: f64,
        dfPegHeading: f64,
        dfPegHgt: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetVerticalPerspective(
        hSRS: OGRSpatialReferenceH,
        dfTopoOriginLat: f64,
        dfTopoOriginLon: f64,
        dfTopoOriginHeight: f64,
        dfViewPointHeight: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRCalcInvFlattening(dfSemiMajor: f64, dfSemiMinor: f64) -> f64;
}
extern "C" {
    pub fn OSRCalcSemiMinorFromInvFlattening(dfSemiMajor: f64, dfInvFlattening: f64) -> f64;
}
extern "C" {
    pub fn OSRCleanup();
}
pub mod OSRCRSType {
    pub type Type = libc::c_uint;
    pub const OSR_CRS_TYPE_GEOGRAPHIC_2D: Type = 0;
    pub const OSR_CRS_TYPE_GEOGRAPHIC_3D: Type = 1;
    pub const OSR_CRS_TYPE_GEOCENTRIC: Type = 2;
    pub const OSR_CRS_TYPE_PROJECTED: Type = 3;
    pub const OSR_CRS_TYPE_VERTICAL: Type = 4;
    pub const OSR_CRS_TYPE_COMPOUND: Type = 5;
    pub const OSR_CRS_TYPE_OTHER: Type = 6;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSRCRSInfo {
    pub pszAuthName: *mut libc::c_char,
    pub pszCode: *mut libc::c_char,
    pub pszName: *mut libc::c_char,
    pub eType: OSRCRSType::Type,
    pub bDeprecated: libc::c_int,
    pub bBboxValid: libc::c_int,
    pub dfWestLongitudeDeg: f64,
    pub dfSouthLatitudeDeg: f64,
    pub dfEastLongitudeDeg: f64,
    pub dfNorthLatitudeDeg: f64,
    pub pszAreaName: *mut libc::c_char,
    pub pszProjectionMethod: *mut libc::c_char,
}
#[test]
fn bindgen_test_layout_OSRCRSInfo() {
    assert_eq!(
        ::std::mem::size_of::<OSRCRSInfo>(),
        88usize,
        concat!("Size of: ", stringify!(OSRCRSInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<OSRCRSInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(OSRCRSInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OSRCRSInfo>())).pszAuthName as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSRCRSInfo),
            "::",
            stringify!(pszAuthName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OSRCRSInfo>())).pszCode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OSRCRSInfo),
            "::",
            stringify!(pszCode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OSRCRSInfo>())).pszName as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OSRCRSInfo),
            "::",
            stringify!(pszName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OSRCRSInfo>())).eType as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(OSRCRSInfo),
            "::",
            stringify!(eType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OSRCRSInfo>())).bDeprecated as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(OSRCRSInfo),
            "::",
            stringify!(bDeprecated)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OSRCRSInfo>())).bBboxValid as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(OSRCRSInfo),
            "::",
            stringify!(bBboxValid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OSRCRSInfo>())).dfWestLongitudeDeg as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(OSRCRSInfo),
            "::",
            stringify!(dfWestLongitudeDeg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OSRCRSInfo>())).dfSouthLatitudeDeg as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(OSRCRSInfo),
            "::",
            stringify!(dfSouthLatitudeDeg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OSRCRSInfo>())).dfEastLongitudeDeg as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(OSRCRSInfo),
            "::",
            stringify!(dfEastLongitudeDeg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OSRCRSInfo>())).dfNorthLatitudeDeg as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(OSRCRSInfo),
            "::",
            stringify!(dfNorthLatitudeDeg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OSRCRSInfo>())).pszAreaName as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(OSRCRSInfo),
            "::",
            stringify!(pszAreaName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OSRCRSInfo>())).pszProjectionMethod as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(OSRCRSInfo),
            "::",
            stringify!(pszProjectionMethod)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSRCRSListParameters {
    _unused: [u8; 0],
}
extern "C" {
    pub fn OSRGetCRSInfoListFromDatabase(
        pszAuthName: *const libc::c_char,
        params: *const OSRCRSListParameters,
        pnOutResultCount: *mut libc::c_int,
    ) -> *mut *mut OSRCRSInfo;
}
extern "C" {
    pub fn OSRDestroyCRSInfoList(list: *mut *mut OSRCRSInfo);
}
extern "C" {
    pub fn OCTNewCoordinateTransformation(
        hSourceSRS: OGRSpatialReferenceH,
        hTargetSRS: OGRSpatialReferenceH,
    ) -> OGRCoordinateTransformationH;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OGRCoordinateTransformationOptions {
    _unused: [u8; 0],
}
pub type OGRCoordinateTransformationOptionsH = *mut OGRCoordinateTransformationOptions;
extern "C" {
    pub fn OCTNewCoordinateTransformationOptions() -> OGRCoordinateTransformationOptionsH;
}
extern "C" {
    pub fn OCTCoordinateTransformationOptionsSetOperation(
        hOptions: OGRCoordinateTransformationOptionsH,
        pszCO: *const libc::c_char,
        bReverseCO: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OCTCoordinateTransformationOptionsSetAreaOfInterest(
        hOptions: OGRCoordinateTransformationOptionsH,
        dfWestLongitudeDeg: f64,
        dfSouthLatitudeDeg: f64,
        dfEastLongitudeDeg: f64,
        dfNorthLatitudeDeg: f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OCTDestroyCoordinateTransformationOptions(arg1: OGRCoordinateTransformationOptionsH);
}
extern "C" {
    pub fn OCTNewCoordinateTransformationEx(
        hSourceSRS: OGRSpatialReferenceH,
        hTargetSRS: OGRSpatialReferenceH,
        hOptions: OGRCoordinateTransformationOptionsH,
    ) -> OGRCoordinateTransformationH;
}
extern "C" {
    pub fn OCTDestroyCoordinateTransformation(arg1: OGRCoordinateTransformationH);
}
extern "C" {
    pub fn OCTTransform(
        hCT: OGRCoordinateTransformationH,
        nCount: libc::c_int,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OCTTransformEx(
        hCT: OGRCoordinateTransformationH,
        nCount: libc::c_int,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
        pabSuccess: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OCTTransform4D(
        hCT: OGRCoordinateTransformationH,
        nCount: libc::c_int,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
        t: *mut f64,
        pabSuccess: *mut libc::c_int,
    ) -> libc::c_int;
}
pub type CPLThreadFunc = ::std::option::Option<unsafe extern "C" fn(arg1: *mut libc::c_void)>;
extern "C" {
    pub fn CPLLockFile(pszPath: *const libc::c_char, dfWaitInSeconds: f64) -> *mut libc::c_void;
}
extern "C" {
    pub fn CPLUnlockFile(hLock: *mut libc::c_void);
}
extern "C" {
    pub fn CPLCreateMutex() -> *mut libc::c_void;
}
extern "C" {
    pub fn CPLCreateMutexEx(nOptions: libc::c_int) -> *mut libc::c_void;
}
extern "C" {
    pub fn CPLCreateOrAcquireMutex(
        arg1: *mut *mut libc::c_void,
        dfWaitInSeconds: f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CPLCreateOrAcquireMutexEx(
        arg1: *mut *mut libc::c_void,
        dfWaitInSeconds: f64,
        nOptions: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CPLAcquireMutex(hMutex: *mut libc::c_void, dfWaitInSeconds: f64) -> libc::c_int;
}
extern "C" {
    pub fn CPLReleaseMutex(hMutex: *mut libc::c_void);
}
extern "C" {
    pub fn CPLDestroyMutex(hMutex: *mut libc::c_void);
}
extern "C" {
    pub fn CPLCleanupMasterMutex();
}
extern "C" {
    pub fn CPLCreateCond() -> *mut libc::c_void;
}
extern "C" {
    pub fn CPLCondWait(hCond: *mut libc::c_void, hMutex: *mut libc::c_void);
}
pub mod CPLCondTimedWaitReason {
    pub type Type = libc::c_uint;
    pub const COND_TIMED_WAIT_COND: Type = 0;
    pub const COND_TIMED_WAIT_TIME_OUT: Type = 1;
    pub const COND_TIMED_WAIT_OTHER: Type = 2;
}
extern "C" {
    pub fn CPLCondTimedWait(
        hCond: *mut libc::c_void,
        hMutex: *mut libc::c_void,
        dfWaitInSeconds: f64,
    ) -> CPLCondTimedWaitReason::Type;
}
extern "C" {
    pub fn CPLCondSignal(hCond: *mut libc::c_void);
}
extern "C" {
    pub fn CPLCondBroadcast(hCond: *mut libc::c_void);
}
extern "C" {
    pub fn CPLDestroyCond(hCond: *mut libc::c_void);
}
extern "C" {
    pub fn CPLGetPID() -> GIntBig;
}
extern "C" {
    pub fn CPLGetCurrentProcessID() -> libc::c_int;
}
extern "C" {
    pub fn CPLCreateThread(pfnMain: CPLThreadFunc, pArg: *mut libc::c_void) -> libc::c_int;
}
extern "C" {
    pub fn CPLCreateJoinableThread(
        pfnMain: CPLThreadFunc,
        pArg: *mut libc::c_void,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn CPLJoinThread(hJoinableThread: *mut libc::c_void);
}
extern "C" {
    pub fn CPLSleep(dfWaitInSeconds: f64);
}
extern "C" {
    pub fn CPLGetThreadingModel() -> *const libc::c_char;
}
extern "C" {
    pub fn CPLGetNumCPUs() -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CPLLock {
    _unused: [u8; 0],
}
pub type CPLLock = _CPLLock;
pub mod CPLLockType {
    pub type Type = libc::c_uint;
    pub const LOCK_RECURSIVE_MUTEX: Type = 0;
    pub const LOCK_ADAPTIVE_MUTEX: Type = 1;
    pub const LOCK_SPIN: Type = 2;
}
extern "C" {
    pub fn CPLCreateLock(eType: CPLLockType::Type) -> *mut CPLLock;
}
extern "C" {
    pub fn CPLCreateOrAcquireLock(arg1: *mut *mut CPLLock, eType: CPLLockType::Type)
        -> libc::c_int;
}
extern "C" {
    pub fn CPLAcquireLock(arg1: *mut CPLLock) -> libc::c_int;
}
extern "C" {
    pub fn CPLReleaseLock(arg1: *mut CPLLock);
}
extern "C" {
    pub fn CPLDestroyLock(arg1: *mut CPLLock);
}
extern "C" {
    pub fn CPLLockSetDebugPerf(arg1: *mut CPLLock, bEnableIn: libc::c_int);
}
extern "C" {
    pub fn CPLGetTLS(nIndex: libc::c_int) -> *mut libc::c_void;
}
extern "C" {
    pub fn CPLGetTLSEx(
        nIndex: libc::c_int,
        pbMemoryErrorOccurred: *mut libc::c_int,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn CPLSetTLS(nIndex: libc::c_int, pData: *mut libc::c_void, bFreeOnExit: libc::c_int);
}
pub type CPLTLSFreeFunc = ::std::option::Option<unsafe extern "C" fn(pData: *mut libc::c_void)>;
extern "C" {
    pub fn CPLSetTLSWithFreeFunc(
        nIndex: libc::c_int,
        pData: *mut libc::c_void,
        pfnFree: CPLTLSFreeFunc,
    );
}
extern "C" {
    pub fn CPLSetTLSWithFreeFuncEx(
        nIndex: libc::c_int,
        pData: *mut libc::c_void,
        pfnFree: CPLTLSFreeFunc,
        pbMemoryErrorOccurred: *mut libc::c_int,
    );
}
extern "C" {
    pub fn CPLCleanupTLS();
}
pub mod GDALResampleAlg {
    pub type Type = libc::c_uint;
    pub const GRA_NearestNeighbour: Type = 0;
    pub const GRA_Bilinear: Type = 1;
    pub const GRA_Cubic: Type = 2;
    pub const GRA_CubicSpline: Type = 3;
    pub const GRA_Lanczos: Type = 4;
    pub const GRA_Average: Type = 5;
    pub const GRA_Mode: Type = 6;
    pub const GRA_Max: Type = 8;
    pub const GRA_Min: Type = 9;
    pub const GRA_Med: Type = 10;
    pub const GRA_Q1: Type = 11;
    pub const GRA_Q3: Type = 12;
    pub const GRA_Sum: Type = 13;
}
pub type GDALMaskFunc = ::std::option::Option<
    unsafe extern "C" fn(
        pMaskFuncArg: *mut libc::c_void,
        nBandCount: libc::c_int,
        eType: GDALDataType::Type,
        nXOff: libc::c_int,
        nYOff: libc::c_int,
        nXSize: libc::c_int,
        nYSize: libc::c_int,
        papabyImageData: *mut *mut GByte,
        bMaskIsFloat: libc::c_int,
        pMask: *mut libc::c_void,
    ) -> libc::c_int,
>;
extern "C" {
    pub fn GDALWarpNoDataMasker(
        pMaskFuncArg: *mut libc::c_void,
        nBandCount: libc::c_int,
        eType: GDALDataType::Type,
        nXOff: libc::c_int,
        nYOff: libc::c_int,
        nXSize: libc::c_int,
        nYSize: libc::c_int,
        papabyImageData: *mut *mut GByte,
        bMaskIsFloat: libc::c_int,
        pValidityMask: *mut libc::c_void,
        pbOutAllValid: *mut libc::c_int,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALWarpDstAlphaMasker(
        pMaskFuncArg: *mut libc::c_void,
        nBandCount: libc::c_int,
        eType: GDALDataType::Type,
        nXOff: libc::c_int,
        nYOff: libc::c_int,
        nXSize: libc::c_int,
        nYSize: libc::c_int,
        arg1: *mut *mut GByte,
        bMaskIsFloat: libc::c_int,
        pValidityMask: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALWarpSrcAlphaMasker(
        pMaskFuncArg: *mut libc::c_void,
        nBandCount: libc::c_int,
        eType: GDALDataType::Type,
        nXOff: libc::c_int,
        nYOff: libc::c_int,
        nXSize: libc::c_int,
        nYSize: libc::c_int,
        arg1: *mut *mut GByte,
        bMaskIsFloat: libc::c_int,
        pValidityMask: *mut libc::c_void,
        pbOutAllOpaque: *mut libc::c_int,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALWarpSrcMaskMasker(
        pMaskFuncArg: *mut libc::c_void,
        nBandCount: libc::c_int,
        eType: GDALDataType::Type,
        nXOff: libc::c_int,
        nYOff: libc::c_int,
        nXSize: libc::c_int,
        nYSize: libc::c_int,
        arg1: *mut *mut GByte,
        bMaskIsFloat: libc::c_int,
        pValidityMask: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALWarpCutlineMasker(
        pMaskFuncArg: *mut libc::c_void,
        nBandCount: libc::c_int,
        eType: GDALDataType::Type,
        nXOff: libc::c_int,
        nYOff: libc::c_int,
        nXSize: libc::c_int,
        nYSize: libc::c_int,
        arg1: *mut *mut GByte,
        bMaskIsFloat: libc::c_int,
        pValidityMask: *mut libc::c_void,
    ) -> CPLErr::Type;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALWarpOptions {
    pub papszWarpOptions: *mut *mut libc::c_char,
    pub dfWarpMemoryLimit: f64,
    pub eResampleAlg: GDALResampleAlg::Type,
    pub eWorkingDataType: GDALDataType::Type,
    pub hSrcDS: GDALDatasetH,
    pub hDstDS: GDALDatasetH,
    pub nBandCount: libc::c_int,
    pub panSrcBands: *mut libc::c_int,
    pub panDstBands: *mut libc::c_int,
    pub nSrcAlphaBand: libc::c_int,
    pub nDstAlphaBand: libc::c_int,
    pub padfSrcNoDataReal: *mut f64,
    pub padfSrcNoDataImag: *mut f64,
    pub padfDstNoDataReal: *mut f64,
    pub padfDstNoDataImag: *mut f64,
    pub pfnProgress: GDALProgressFunc,
    pub pProgressArg: *mut libc::c_void,
    pub pfnTransformer: GDALTransformerFunc,
    pub pTransformerArg: *mut libc::c_void,
    pub papfnSrcPerBandValidityMaskFunc: *mut GDALMaskFunc,
    pub papSrcPerBandValidityMaskFuncArg: *mut *mut libc::c_void,
    pub pfnSrcValidityMaskFunc: GDALMaskFunc,
    pub pSrcValidityMaskFuncArg: *mut libc::c_void,
    pub pfnSrcDensityMaskFunc: GDALMaskFunc,
    pub pSrcDensityMaskFuncArg: *mut libc::c_void,
    pub pfnDstDensityMaskFunc: GDALMaskFunc,
    pub pDstDensityMaskFuncArg: *mut libc::c_void,
    pub pfnDstValidityMaskFunc: GDALMaskFunc,
    pub pDstValidityMaskFuncArg: *mut libc::c_void,
    pub pfnPreWarpChunkProcessor: ::std::option::Option<
        unsafe extern "C" fn(pKern: *mut libc::c_void, pArg: *mut libc::c_void) -> CPLErr::Type,
    >,
    pub pPreWarpProcessorArg: *mut libc::c_void,
    pub pfnPostWarpChunkProcessor: ::std::option::Option<
        unsafe extern "C" fn(pKern: *mut libc::c_void, pArg: *mut libc::c_void) -> CPLErr::Type,
    >,
    pub pPostWarpProcessorArg: *mut libc::c_void,
    pub hCutline: *mut libc::c_void,
    pub dfCutlineBlendDist: f64,
}
#[test]
fn bindgen_test_layout_GDALWarpOptions() {
    assert_eq!(
        ::std::mem::size_of::<GDALWarpOptions>(),
        264usize,
        concat!("Size of: ", stringify!(GDALWarpOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<GDALWarpOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(GDALWarpOptions))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALWarpOptions>())).papszWarpOptions as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(papszWarpOptions)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALWarpOptions>())).dfWarpMemoryLimit as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(dfWarpMemoryLimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALWarpOptions>())).eResampleAlg as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(eResampleAlg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALWarpOptions>())).eWorkingDataType as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(eWorkingDataType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALWarpOptions>())).hSrcDS as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(hSrcDS)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALWarpOptions>())).hDstDS as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(hDstDS)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALWarpOptions>())).nBandCount as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(nBandCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALWarpOptions>())).panSrcBands as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(panSrcBands)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALWarpOptions>())).panDstBands as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(panDstBands)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALWarpOptions>())).nSrcAlphaBand as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(nSrcAlphaBand)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALWarpOptions>())).nDstAlphaBand as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(nDstAlphaBand)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALWarpOptions>())).padfSrcNoDataReal as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(padfSrcNoDataReal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALWarpOptions>())).padfSrcNoDataImag as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(padfSrcNoDataImag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALWarpOptions>())).padfDstNoDataReal as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(padfDstNoDataReal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALWarpOptions>())).padfDstNoDataImag as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(padfDstNoDataImag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALWarpOptions>())).pfnProgress as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(pfnProgress)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALWarpOptions>())).pProgressArg as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(pProgressArg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALWarpOptions>())).pfnTransformer as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(pfnTransformer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALWarpOptions>())).pTransformerArg as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(pTransformerArg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALWarpOptions>())).papfnSrcPerBandValidityMaskFunc as *const _
                as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(papfnSrcPerBandValidityMaskFunc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALWarpOptions>())).papSrcPerBandValidityMaskFuncArg as *const _
                as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(papSrcPerBandValidityMaskFuncArg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALWarpOptions>())).pfnSrcValidityMaskFunc as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(pfnSrcValidityMaskFunc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALWarpOptions>())).pSrcValidityMaskFuncArg as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(pSrcValidityMaskFuncArg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALWarpOptions>())).pfnSrcDensityMaskFunc as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(pfnSrcDensityMaskFunc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALWarpOptions>())).pSrcDensityMaskFuncArg as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(pSrcDensityMaskFuncArg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALWarpOptions>())).pfnDstDensityMaskFunc as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(pfnDstDensityMaskFunc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALWarpOptions>())).pDstDensityMaskFuncArg as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(pDstDensityMaskFuncArg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALWarpOptions>())).pfnDstValidityMaskFunc as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(pfnDstValidityMaskFunc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALWarpOptions>())).pDstValidityMaskFuncArg as *const _ as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(pDstValidityMaskFuncArg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALWarpOptions>())).pfnPreWarpChunkProcessor as *const _
                as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(pfnPreWarpChunkProcessor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALWarpOptions>())).pPreWarpProcessorArg as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(pPreWarpProcessorArg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALWarpOptions>())).pfnPostWarpChunkProcessor as *const _
                as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(pfnPostWarpChunkProcessor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALWarpOptions>())).pPostWarpProcessorArg as *const _ as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(pPostWarpProcessorArg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALWarpOptions>())).hCutline as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(hCutline)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALWarpOptions>())).dfCutlineBlendDist as *const _ as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(dfCutlineBlendDist)
        )
    );
}
extern "C" {
    pub fn GDALCreateWarpOptions() -> *mut GDALWarpOptions;
}
extern "C" {
    pub fn GDALDestroyWarpOptions(arg1: *mut GDALWarpOptions);
}
extern "C" {
    pub fn GDALCloneWarpOptions(arg1: *const GDALWarpOptions) -> *mut GDALWarpOptions;
}
extern "C" {
    pub fn GDALWarpInitDstNoDataReal(arg1: *mut GDALWarpOptions, dNoDataReal: f64);
}
extern "C" {
    pub fn GDALWarpInitSrcNoDataReal(arg1: *mut GDALWarpOptions, dNoDataReal: f64);
}
extern "C" {
    pub fn GDALWarpInitNoDataReal(arg1: *mut GDALWarpOptions, dNoDataReal: f64);
}
extern "C" {
    pub fn GDALWarpInitDstNoDataImag(arg1: *mut GDALWarpOptions, dNoDataImag: f64);
}
extern "C" {
    pub fn GDALWarpInitSrcNoDataImag(arg1: *mut GDALWarpOptions, dNoDataImag: f64);
}
extern "C" {
    pub fn GDALWarpResolveWorkingDataType(arg1: *mut GDALWarpOptions);
}
extern "C" {
    pub fn GDALWarpInitDefaultBandMapping(arg1: *mut GDALWarpOptions, nBandCount: libc::c_int);
}
extern "C" {
    pub fn GDALSerializeWarpOptions(arg1: *const GDALWarpOptions) -> *mut CPLXMLNode;
}
extern "C" {
    pub fn GDALDeserializeWarpOptions(arg1: *mut CPLXMLNode) -> *mut GDALWarpOptions;
}
extern "C" {
    pub fn GDALReprojectImage(
        hSrcDS: GDALDatasetH,
        pszSrcWKT: *const libc::c_char,
        hDstDS: GDALDatasetH,
        pszDstWKT: *const libc::c_char,
        eResampleAlg: GDALResampleAlg::Type,
        dfWarpMemoryLimit: f64,
        dfMaxError: f64,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut libc::c_void,
        psOptions: *mut GDALWarpOptions,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALCreateAndReprojectImage(
        hSrcDS: GDALDatasetH,
        pszSrcWKT: *const libc::c_char,
        pszDstFilename: *const libc::c_char,
        pszDstWKT: *const libc::c_char,
        hDstDriver: GDALDriverH,
        papszCreateOptions: *mut *mut libc::c_char,
        eResampleAlg: GDALResampleAlg::Type,
        dfWarpMemoryLimit: f64,
        dfMaxError: f64,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut libc::c_void,
        psOptions: *mut GDALWarpOptions,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALAutoCreateWarpedVRT(
        hSrcDS: GDALDatasetH,
        pszSrcWKT: *const libc::c_char,
        pszDstWKT: *const libc::c_char,
        eResampleAlg: GDALResampleAlg::Type,
        dfMaxError: f64,
        psOptions: *const GDALWarpOptions,
    ) -> GDALDatasetH;
}
extern "C" {
    pub fn GDALAutoCreateWarpedVRTEx(
        hSrcDS: GDALDatasetH,
        pszSrcWKT: *const libc::c_char,
        pszDstWKT: *const libc::c_char,
        eResampleAlg: GDALResampleAlg::Type,
        dfMaxError: f64,
        psOptions: *const GDALWarpOptions,
        papszTransformerOptions: CSLConstList,
    ) -> GDALDatasetH;
}
extern "C" {
    pub fn GDALCreateWarpedVRT(
        hSrcDS: GDALDatasetH,
        nPixels: libc::c_int,
        nLines: libc::c_int,
        padfGeoTransform: *mut f64,
        psOptions: *mut GDALWarpOptions,
    ) -> GDALDatasetH;
}
extern "C" {
    pub fn GDALInitializeWarpedVRT(hDS: GDALDatasetH, psWO: *mut GDALWarpOptions) -> CPLErr::Type;
}
pub type GDALWarpOperationH = *mut libc::c_void;
extern "C" {
    pub fn GDALCreateWarpOperation(arg1: *const GDALWarpOptions) -> GDALWarpOperationH;
}
extern "C" {
    pub fn GDALDestroyWarpOperation(arg1: GDALWarpOperationH);
}
extern "C" {
    pub fn GDALChunkAndWarpImage(
        arg1: GDALWarpOperationH,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: libc::c_int,
        arg5: libc::c_int,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALChunkAndWarpMulti(
        arg1: GDALWarpOperationH,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: libc::c_int,
        arg5: libc::c_int,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALWarpRegion(
        arg1: GDALWarpOperationH,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: libc::c_int,
        arg5: libc::c_int,
        arg6: libc::c_int,
        arg7: libc::c_int,
        arg8: libc::c_int,
        arg9: libc::c_int,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALWarpRegionToBuffer(
        arg1: GDALWarpOperationH,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: libc::c_int,
        arg5: libc::c_int,
        arg6: *mut libc::c_void,
        arg7: GDALDataType::Type,
        arg8: libc::c_int,
        arg9: libc::c_int,
        arg10: libc::c_int,
        arg11: libc::c_int,
    ) -> CPLErr::Type;
}
pub mod OGRErr {
    #[doc = " Type for a OGR error"]
    #[doc = ""]
    #[doc = " <div rustbindgen replaces=\"OGRErr\"></div>"]
    pub type Type = libc::c_uint;
    #[doc = " Success"]
    #[doc = ""]
    #[doc = " <div rustbindgen replaces=\"OGRERR_NONE\"></div>"]
    pub const OGRERR_NONE: Type = 0;
    #[doc = " Not enough data to deserialize"]
    #[doc = ""]
    #[doc = " <div rustbindgen replaces=\"OGRERR_NOT_ENOUGH_DATA\"></div>"]
    pub const OGRERR_NOT_ENOUGH_DATA: Type = 1;
    #[doc = " Not enough memory"]
    #[doc = ""]
    #[doc = " <div rustbindgen replaces=\"OGRERR_NOT_ENOUGH_MEMORY\"></div>"]
    pub const OGRERR_NOT_ENOUGH_MEMORY: Type = 2;
    #[doc = " Unsupported geometry type"]
    #[doc = ""]
    #[doc = " <div rustbindgen replaces=\"OGRERR_UNSUPPORTED_GEOMETRY_TYPE\"></div>"]
    pub const OGRERR_UNSUPPORTED_GEOMETRY_TYPE: Type = 3;
    #[doc = " Unsupported operation"]
    #[doc = ""]
    #[doc = " <div rustbindgen replaces=\"OGRERR_UNSUPPORTED_OPERATION\"></div>"]
    pub const OGRERR_UNSUPPORTED_OPERATION: Type = 4;
    #[doc = " Corrupt data"]
    #[doc = ""]
    #[doc = " <div rustbindgen replaces=\"OGRERR_CORRUPT_DATA\"></div>"]
    pub const OGRERR_CORRUPT_DATA: Type = 5;
    #[doc = " Failure"]
    #[doc = ""]
    #[doc = " <div rustbindgen replaces=\"OGRERR_FAILURE\"></div>"]
    pub const OGRERR_FAILURE: Type = 6;
    #[doc = " Unsupported SRS"]
    #[doc = ""]
    #[doc = " <div rustbindgen replaces=\"OGRERR_UNSUPPORTED_SRS\"></div>"]
    pub const OGRERR_UNSUPPORTED_SRS: Type = 7;
    #[doc = " Invalid handle"]
    #[doc = ""]
    #[doc = " <div rustbindgen replaces=\"INVALID_HANDLE\"></div>"]
    pub const INVALID_HANDLE: Type = 8;
    #[doc = " Non existing feature. Added in GDAL 2.0"]
    #[doc = ""]
    #[doc = " <div rustbindgen replaces=\"NON_EXISTING_FEATURE\"></div>"]
    pub const NON_EXISTING_FEATURE: Type = 9;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: libc::c_uint,
    pub fp_offset: libc::c_uint,
    pub overflow_arg_area: *mut libc::c_void,
    pub reg_save_area: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
