/* automatically generated by rust-bindgen 0.63.0 */

pub type va_list = __builtin_va_list;
pub type __dev_t = libc::c_ulong;
pub type __uid_t = libc::c_uint;
pub type __gid_t = libc::c_uint;
pub type __ino_t = libc::c_ulong;
pub type __mode_t = libc::c_uint;
pub type __nlink_t = libc::c_ulong;
pub type __off_t = libc::c_long;
pub type __off64_t = libc::c_long;
pub type __time_t = libc::c_long;
pub type __blksize_t = libc::c_long;
pub type __blkcnt_t = libc::c_long;
pub type __syscall_slong_t = libc::c_long;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = libc::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: libc::c_int,
    pub _IO_read_ptr: *mut libc::c_char,
    pub _IO_read_end: *mut libc::c_char,
    pub _IO_read_base: *mut libc::c_char,
    pub _IO_write_base: *mut libc::c_char,
    pub _IO_write_ptr: *mut libc::c_char,
    pub _IO_write_end: *mut libc::c_char,
    pub _IO_buf_base: *mut libc::c_char,
    pub _IO_buf_end: *mut libc::c_char,
    pub _IO_save_base: *mut libc::c_char,
    pub _IO_backup_base: *mut libc::c_char,
    pub _IO_save_end: *mut libc::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: libc::c_int,
    pub _flags2: libc::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: libc::c_ushort,
    pub _vtable_offset: libc::c_schar,
    pub _shortbuf: [libc::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut libc::c_void,
    pub __pad5: usize,
    pub _mode: libc::c_int,
    pub _unused2: [libc::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    const UNINIT: ::std::mem::MaybeUninit<_IO_FILE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_end) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_base) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_base) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_end) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_base) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_end) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_base) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_backup_base) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_end) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._markers) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._chain) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._fileno) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._old_offset) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._cur_column) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._vtable_offset) as usize - ptr as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._shortbuf) as usize - ptr as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._codecvt) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._wide_data) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_list) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_buf) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad5) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mode) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._unused2) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type wchar_t = libc::c_int;
pub type time_t = __time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: libc::c_int,
    pub tm_min: libc::c_int,
    pub tm_hour: libc::c_int,
    pub tm_mday: libc::c_int,
    pub tm_mon: libc::c_int,
    pub tm_year: libc::c_int,
    pub tm_wday: libc::c_int,
    pub tm_yday: libc::c_int,
    pub tm_isdst: libc::c_int,
    pub tm_gmtoff: libc::c_long,
    pub tm_zone: *const libc::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    const UNINIT: ::std::mem::MaybeUninit<tm> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_min) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_hour) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mday) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mon) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_year) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_wday) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_yday) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_isdst) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_gmtoff) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_zone) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
#[doc = " Int32 type"]
pub type GInt32 = libc::c_int;
#[doc = " Unsigned int32 type"]
pub type GUInt32 = libc::c_uint;
#[doc = " Int16 type"]
pub type GInt16 = libc::c_short;
#[doc = " Unsigned byte type"]
pub type GByte = libc::c_uchar;
#[doc = " Large signed integer type (generally 64-bit integer type).\n  Use GInt64 when exactly 64 bit is needed"]
pub type GIntBig = libc::c_longlong;
#[doc = " Large unsigned integer type (generally 64-bit unsigned integer type).\n  Use GUInt64 when exactly 64 bit is needed"]
pub type GUIntBig = libc::c_ulonglong;
#[doc = " Signed 64 bit integer type"]
pub type GInt64 = GIntBig;
#[doc = " Unsigned 64 bit integer type"]
pub type GUInt64 = GUIntBig;
#[doc = " Integer type large enough to hold the difference between 2 addresses"]
pub type GPtrDiff_t = GIntBig;
#[doc = " Type of a constant null-terminated list of nul terminated strings.\n Seen as char** from C and const char* const* from C++"]
pub type CSLConstList = *mut *mut libc::c_char;
extern "C" {
    #[doc = " Add a value to a pointed integer in a thread and SMP-safe way\n and return the resulting value of the operation.\n\n This function, which in most cases is implemented by a few\n efficient machine instructions, guarantees that the value pointed\n by ptr will be incremented in a thread and SMP-safe way.\n The variables for this function must be aligned on a 32-bit boundary.\n\n Depending on the platforms, this function can also act as a\n memory barrier, but this should not be assumed.\n\n Current platforms/architectures where an efficient implementation\n exists are MacOSX, MS Windows, i386/x86_64 with GCC and platforms\n supported by GCC 4.1 or higher. For other platforms supporting\n the pthread library, and when GDAL is configured with thread-support,\n the atomicity will be done with a mutex, but with\n reduced efficiency. For the remaining platforms, a simple addition\n with no locking will be done...\n\n @param ptr a pointer to an integer to increment\n @param increment the amount to add to the pointed integer\n @return the pointed value AFTER the result of the addition"]
    pub fn CPLAtomicAdd(ptr: *mut libc::c_int, increment: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Compares *ptr with oldval. If *ptr == oldval, then *ptr is assigned\n newval and TRUE is returned. Otherwise nothing is done, and FALSE is returned.\n\n Current platforms/architectures where an efficient implementation\n exists are MacOSX, MS Windows, i386/x86_64 with GCC and platforms\n supported by GCC 4.1 or higher. For other platforms supporting\n the pthread library, and when GDAL is configured with thread-support,\n the atomicity will be done with a mutex, but with\n reduced efficiency. For the remaining platforms, a simple compare and\n exchange with no locking will be done...\n\n @param ptr a pointer to an integer (aligned on 32bit boundary).\n @param oldval old value\n @param newval new value\n @return TRUE if the exchange has been done"]
    pub fn CPLAtomicCompareAndExchange(
        ptr: *mut libc::c_int,
        oldval: libc::c_int,
        newval: libc::c_int,
    ) -> libc::c_int;
}
pub type GDALProgressFunc = ::std::option::Option<
    unsafe extern "C" fn(
        dfComplete: f64,
        pszMessage: *const libc::c_char,
        pProgressArg: *mut libc::c_void,
    ) -> libc::c_int,
>;
extern "C" {
    pub fn GDALDummyProgress(
        arg1: f64,
        arg2: *const libc::c_char,
        arg3: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALTermProgress(
        arg1: f64,
        arg2: *const libc::c_char,
        arg3: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALScaledProgress(
        arg1: f64,
        arg2: *const libc::c_char,
        arg3: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALCreateScaledProgress(
        arg1: f64,
        arg2: f64,
        arg3: GDALProgressFunc,
        arg4: *mut libc::c_void,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn GDALDestroyScaledProgress(arg1: *mut libc::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stat {
    pub st_dev: __dev_t,
    pub st_ino: __ino_t,
    pub st_nlink: __nlink_t,
    pub st_mode: __mode_t,
    pub st_uid: __uid_t,
    pub st_gid: __gid_t,
    pub __pad0: libc::c_int,
    pub st_rdev: __dev_t,
    pub st_size: __off_t,
    pub st_blksize: __blksize_t,
    pub st_blocks: __blkcnt_t,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    pub __glibc_reserved: [__syscall_slong_t; 3usize],
}
#[test]
fn bindgen_test_layout_stat() {
    const UNINIT: ::std::mem::MaybeUninit<stat> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<stat>(),
        144usize,
        concat!("Size of: ", stringify!(stat))
    );
    assert_eq!(
        ::std::mem::align_of::<stat>(),
        8usize,
        concat!("Alignment of ", stringify!(stat))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_dev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_dev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_ino) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_ino)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_nlink) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_nlink)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_mode) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_uid) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_gid) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_gid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad0) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(__pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_rdev) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_rdev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_size) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_blksize) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_blksize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_blocks) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_blocks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_atim) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_atim)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_mtim) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_mtim)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_ctim) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_ctim)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__glibc_reserved) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(__glibc_reserved)
        )
    );
}
extern "C" {
    #[doc = " @cond Doxygen_Suppress"]
    pub fn VSIFOpen(arg1: *const libc::c_char, arg2: *const libc::c_char) -> *mut FILE;
}
extern "C" {
    pub fn VSIFClose(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn VSIFSeek(arg1: *mut FILE, arg2: libc::c_long, arg3: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn VSIFTell(arg1: *mut FILE) -> libc::c_long;
}
extern "C" {
    pub fn VSIRewind(arg1: *mut FILE);
}
extern "C" {
    pub fn VSIFFlush(arg1: *mut FILE);
}
extern "C" {
    pub fn VSIFRead(arg1: *mut libc::c_void, arg2: usize, arg3: usize, arg4: *mut FILE) -> usize;
}
extern "C" {
    pub fn VSIFWrite(arg1: *const libc::c_void, arg2: usize, arg3: usize, arg4: *mut FILE)
        -> usize;
}
extern "C" {
    pub fn VSIFGets(
        arg1: *mut libc::c_char,
        arg2: libc::c_int,
        arg3: *mut FILE,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn VSIFPuts(arg1: *const libc::c_char, arg2: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn VSIFPrintf(arg1: *mut FILE, arg2: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn VSIFGetc(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn VSIFPutc(arg1: libc::c_int, arg2: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn VSIUngetc(arg1: libc::c_int, arg2: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn VSIFEof(arg1: *mut FILE) -> libc::c_int;
}
#[doc = " @cond Doxygen_Suppress"]
pub type VSIStatBuf = stat;
extern "C" {
    pub fn VSIStat(arg1: *const libc::c_char, arg2: *mut VSIStatBuf) -> libc::c_int;
}
#[doc = " Type for a file offset"]
pub type vsi_l_offset = GUIntBig;
#[doc = " Opaque type for a FILE that implements the VSIVirtualHandle API"]
pub type VSILFILE = FILE;
extern "C" {
    pub fn VSIFOpenL(arg1: *const libc::c_char, arg2: *const libc::c_char) -> *mut VSILFILE;
}
extern "C" {
    pub fn VSIFOpenExL(
        arg1: *const libc::c_char,
        arg2: *const libc::c_char,
        arg3: libc::c_int,
    ) -> *mut VSILFILE;
}
extern "C" {
    pub fn VSIFOpenEx2L(
        arg1: *const libc::c_char,
        arg2: *const libc::c_char,
        arg3: libc::c_int,
        arg4: CSLConstList,
    ) -> *mut VSILFILE;
}
extern "C" {
    pub fn VSIFCloseL(arg1: *mut VSILFILE) -> libc::c_int;
}
extern "C" {
    pub fn VSIFSeekL(arg1: *mut VSILFILE, arg2: vsi_l_offset, arg3: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn VSIFTellL(arg1: *mut VSILFILE) -> vsi_l_offset;
}
extern "C" {
    pub fn VSIRewindL(arg1: *mut VSILFILE);
}
extern "C" {
    pub fn VSIFReadL(
        arg1: *mut libc::c_void,
        arg2: usize,
        arg3: usize,
        arg4: *mut VSILFILE,
    ) -> usize;
}
extern "C" {
    pub fn VSIFReadMultiRangeL(
        nRanges: libc::c_int,
        ppData: *mut *mut libc::c_void,
        panOffsets: *const vsi_l_offset,
        panSizes: *const usize,
        arg1: *mut VSILFILE,
    ) -> libc::c_int;
}
extern "C" {
    pub fn VSIFWriteL(
        arg1: *const libc::c_void,
        arg2: usize,
        arg3: usize,
        arg4: *mut VSILFILE,
    ) -> usize;
}
extern "C" {
    pub fn VSIFEofL(arg1: *mut VSILFILE) -> libc::c_int;
}
extern "C" {
    pub fn VSIFTruncateL(arg1: *mut VSILFILE, arg2: vsi_l_offset) -> libc::c_int;
}
extern "C" {
    pub fn VSIFFlushL(arg1: *mut VSILFILE) -> libc::c_int;
}
extern "C" {
    pub fn VSIFPrintfL(arg1: *mut VSILFILE, arg2: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn VSIFPutcL(arg1: libc::c_int, arg2: *mut VSILFILE) -> libc::c_int;
}
pub mod VSIRangeStatus {
    #[doc = " Range status"]
    pub type Type = libc::c_uint;
    #[doc = "< Unknown"]
    pub const VSI_RANGE_STATUS_UNKNOWN: Type = 0;
    #[doc = "< Data present"]
    pub const VSI_RANGE_STATUS_DATA: Type = 1;
    #[doc = "< Hole"]
    pub const VSI_RANGE_STATUS_HOLE: Type = 2;
}
extern "C" {
    pub fn VSIFGetRangeStatusL(
        fp: *mut VSILFILE,
        nStart: vsi_l_offset,
        nLength: vsi_l_offset,
    ) -> VSIRangeStatus::Type;
}
extern "C" {
    pub fn VSIIngestFile(
        fp: *mut VSILFILE,
        pszFilename: *const libc::c_char,
        ppabyRet: *mut *mut GByte,
        pnSize: *mut vsi_l_offset,
        nMaxSize: GIntBig,
    ) -> libc::c_int;
}
extern "C" {
    pub fn VSIOverwriteFile(
        fpTarget: *mut VSILFILE,
        pszSourceFilename: *const libc::c_char,
    ) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stat64 {
    _unused: [u8; 0],
}
#[doc = " Type for VSIStatL()"]
pub type VSIStatBufL = stat64;
extern "C" {
    pub fn VSIStatL(arg1: *const libc::c_char, arg2: *mut VSIStatBufL) -> libc::c_int;
}
extern "C" {
    pub fn VSIStatExL(
        pszFilename: *const libc::c_char,
        psStatBuf: *mut VSIStatBufL,
        nFlags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn VSIIsCaseSensitiveFS(pszFilename: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn VSISupportsSparseFiles(pszPath: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn VSIIsLocal(pszPath: *const libc::c_char) -> bool;
}
extern "C" {
    pub fn VSISupportsSequentialWrite(
        pszPath: *const libc::c_char,
        bAllowLocalTempFile: bool,
    ) -> bool;
}
extern "C" {
    pub fn VSISupportsRandomWrite(pszPath: *const libc::c_char, bAllowLocalTempFile: bool) -> bool;
}
extern "C" {
    pub fn VSIHasOptimizedReadMultiRange(pszPath: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn VSIGetActualURL(pszFilename: *const libc::c_char) -> *const libc::c_char;
}
extern "C" {
    pub fn VSIGetSignedURL(
        pszFilename: *const libc::c_char,
        papszOptions: CSLConstList,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn VSIGetFileSystemOptions(pszFilename: *const libc::c_char) -> *const libc::c_char;
}
extern "C" {
    pub fn VSIGetFileSystemsPrefixes() -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn VSIFGetNativeFileDescriptorL(arg1: *mut VSILFILE) -> *mut libc::c_void;
}
extern "C" {
    pub fn VSIGetFileMetadata(
        pszFilename: *const libc::c_char,
        pszDomain: *const libc::c_char,
        papszOptions: CSLConstList,
    ) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn VSISetFileMetadata(
        pszFilename: *const libc::c_char,
        papszMetadata: CSLConstList,
        pszDomain: *const libc::c_char,
        papszOptions: CSLConstList,
    ) -> libc::c_int;
}
extern "C" {
    pub fn VSISetPathSpecificOption(
        pszPathPrefix: *const libc::c_char,
        pszKey: *const libc::c_char,
        pszValue: *const libc::c_char,
    );
}
extern "C" {
    pub fn VSIClearPathSpecificOptions(pszPathPrefix: *const libc::c_char);
}
extern "C" {
    pub fn VSIGetPathSpecificOption(
        pszPath: *const libc::c_char,
        pszKey: *const libc::c_char,
        pszDefault: *const libc::c_char,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn VSISetCredential(
        pszPathPrefix: *const libc::c_char,
        pszKey: *const libc::c_char,
        pszValue: *const libc::c_char,
    );
}
extern "C" {
    pub fn VSIClearCredentials(pszPathPrefix: *const libc::c_char);
}
extern "C" {
    pub fn VSIGetCredential(
        pszPath: *const libc::c_char,
        pszKey: *const libc::c_char,
        pszDefault: *const libc::c_char,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn VSICalloc(arg1: usize, arg2: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn VSIMalloc(arg1: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn VSIFree(arg1: *mut libc::c_void);
}
extern "C" {
    pub fn VSIRealloc(arg1: *mut libc::c_void, arg2: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn VSIStrdup(arg1: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn VSIMallocAligned(nAlignment: usize, nSize: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn VSIMallocAlignedAuto(nSize: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn VSIFreeAligned(ptr: *mut libc::c_void);
}
extern "C" {
    pub fn VSIMallocAlignedAutoVerbose(
        nSize: usize,
        pszFile: *const libc::c_char,
        nLine: libc::c_int,
    ) -> *mut libc::c_void;
}
extern "C" {
    #[doc = "VSIMalloc2 allocates (nSize1 * nSize2) bytes.\nIn case of overflow of the multiplication, or if memory allocation fails, a\nNULL pointer is returned and a CE_Failure error is raised with CPLError().\nIf nSize1 == 0 || nSize2 == 0, a NULL pointer will also be returned.\nCPLFree() or VSIFree() can be used to free memory allocated by this function."]
    pub fn VSIMalloc2(nSize1: usize, nSize2: usize) -> *mut libc::c_void;
}
extern "C" {
    #[doc = "VSIMalloc3 allocates (nSize1 * nSize2 * nSize3) bytes.\nIn case of overflow of the multiplication, or if memory allocation fails, a\nNULL pointer is returned and a CE_Failure error is raised with CPLError().\nIf nSize1 == 0 || nSize2 == 0 || nSize3 == 0, a NULL pointer will also be returned.\nCPLFree() or VSIFree() can be used to free memory allocated by this function."]
    pub fn VSIMalloc3(nSize1: usize, nSize2: usize, nSize3: usize) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " VSIMallocVerbose"]
    pub fn VSIMallocVerbose(
        nSize: usize,
        pszFile: *const libc::c_char,
        nLine: libc::c_int,
    ) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " VSIMalloc2Verbose"]
    pub fn VSIMalloc2Verbose(
        nSize1: usize,
        nSize2: usize,
        pszFile: *const libc::c_char,
        nLine: libc::c_int,
    ) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " VSIMalloc3Verbose"]
    pub fn VSIMalloc3Verbose(
        nSize1: usize,
        nSize2: usize,
        nSize3: usize,
        pszFile: *const libc::c_char,
        nLine: libc::c_int,
    ) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " VSICallocVerbose"]
    pub fn VSICallocVerbose(
        nCount: usize,
        nSize: usize,
        pszFile: *const libc::c_char,
        nLine: libc::c_int,
    ) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " VSIReallocVerbose"]
    pub fn VSIReallocVerbose(
        pOldPtr: *mut libc::c_void,
        nNewSize: usize,
        pszFile: *const libc::c_char,
        nLine: libc::c_int,
    ) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " VSIStrdupVerbose"]
    pub fn VSIStrdupVerbose(
        pszStr: *const libc::c_char,
        pszFile: *const libc::c_char,
        nLine: libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn CPLGetPhysicalRAM() -> GIntBig;
}
extern "C" {
    pub fn CPLGetUsablePhysicalRAM() -> GIntBig;
}
extern "C" {
    pub fn VSIReadDir(arg1: *const libc::c_char) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn VSIReadDirRecursive(pszPath: *const libc::c_char) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn VSIReadDirEx(
        pszPath: *const libc::c_char,
        nMaxFiles: libc::c_int,
    ) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn VSISiblingFiles(pszPath: *const libc::c_char) -> *mut *mut libc::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VSIDIR {
    _unused: [u8; 0],
}
extern "C" {
    pub fn VSIOpenDir(
        pszPath: *const libc::c_char,
        nRecurseDepth: libc::c_int,
        papszOptions: *const *const libc::c_char,
    ) -> *mut VSIDIR;
}
#[doc = " Directory entry."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VSIDIREntry {
    #[doc = " Filename"]
    pub pszName: *mut libc::c_char,
    #[doc = " File mode. See VSI_ISREG() / VSI_ISDIR()"]
    pub nMode: libc::c_int,
    #[doc = " File size"]
    pub nSize: vsi_l_offset,
    #[doc = " Last modification time (seconds since 1970/01/01)"]
    pub nMTime: GIntBig,
    #[doc = " Whether nMode is known: 0 = unknown, 1 = known."]
    pub bModeKnown: libc::c_char,
    #[doc = " Whether nSize is known: 0 = unknown, 1 = known."]
    pub bSizeKnown: libc::c_char,
    #[doc = " Whether nMTime is known: 0 = unknown, 1 = known."]
    pub bMTimeKnown: libc::c_char,
    #[doc = " NULL-terminated list of extra properties."]
    pub papszExtra: *mut *mut libc::c_char,
}
#[test]
fn bindgen_test_layout_VSIDIREntry() {
    const UNINIT: ::std::mem::MaybeUninit<VSIDIREntry> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VSIDIREntry>(),
        48usize,
        concat!("Size of: ", stringify!(VSIDIREntry))
    );
    assert_eq!(
        ::std::mem::align_of::<VSIDIREntry>(),
        8usize,
        concat!("Alignment of ", stringify!(VSIDIREntry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pszName) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIDIREntry),
            "::",
            stringify!(pszName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nMode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIDIREntry),
            "::",
            stringify!(nMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nSize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIDIREntry),
            "::",
            stringify!(nSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nMTime) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIDIREntry),
            "::",
            stringify!(nMTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bModeKnown) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIDIREntry),
            "::",
            stringify!(bModeKnown)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bSizeKnown) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIDIREntry),
            "::",
            stringify!(bSizeKnown)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bMTimeKnown) as usize - ptr as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIDIREntry),
            "::",
            stringify!(bMTimeKnown)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).papszExtra) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIDIREntry),
            "::",
            stringify!(papszExtra)
        )
    );
}
extern "C" {
    pub fn VSIGetNextDirEntry(dir: *mut VSIDIR) -> *const VSIDIREntry;
}
extern "C" {
    pub fn VSICloseDir(dir: *mut VSIDIR);
}
extern "C" {
    pub fn VSIMkdir(pszPathname: *const libc::c_char, mode: libc::c_long) -> libc::c_int;
}
extern "C" {
    pub fn VSIMkdirRecursive(pszPathname: *const libc::c_char, mode: libc::c_long) -> libc::c_int;
}
extern "C" {
    pub fn VSIRmdir(pszDirname: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn VSIRmdirRecursive(pszDirname: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn VSIUnlink(pszFilename: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn VSIUnlinkBatch(papszFiles: CSLConstList) -> *mut libc::c_int;
}
extern "C" {
    pub fn VSIRename(oldpath: *const libc::c_char, newpath: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn VSISync(
        pszSource: *const libc::c_char,
        pszTarget: *const libc::c_char,
        papszOptions: *const *const libc::c_char,
        pProgressFunc: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
        ppapszOutputs: *mut *mut *mut libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn VSIAbortPendingUploads(pszFilename: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn VSIStrerror(arg1: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn VSIGetDiskFreeSpace(pszDirname: *const libc::c_char) -> GIntBig;
}
extern "C" {
    pub fn VSINetworkStatsReset();
}
extern "C" {
    pub fn VSINetworkStatsGetAsSerializedJSON(
        papszOptions: *mut *mut libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn VSIInstallMemFileHandler();
}
extern "C" {
    #[doc = " @cond Doxygen_Suppress"]
    pub fn VSIInstallLargeFileHandler();
}
extern "C" {
    #[doc = " @endcond"]
    pub fn VSIInstallSubFileHandler();
}
extern "C" {
    pub fn VSIInstallCurlFileHandler();
}
extern "C" {
    pub fn VSICurlClearCache();
}
extern "C" {
    pub fn VSICurlPartialClearCache(pszFilenamePrefix: *const libc::c_char);
}
extern "C" {
    pub fn VSIInstallCurlStreamingFileHandler();
}
extern "C" {
    pub fn VSIInstallS3FileHandler();
}
extern "C" {
    pub fn VSIInstallS3StreamingFileHandler();
}
extern "C" {
    pub fn VSIInstallGSFileHandler();
}
extern "C" {
    pub fn VSIInstallGSStreamingFileHandler();
}
extern "C" {
    pub fn VSIInstallAzureFileHandler();
}
extern "C" {
    pub fn VSIInstallAzureStreamingFileHandler();
}
extern "C" {
    pub fn VSIInstallADLSFileHandler();
}
extern "C" {
    pub fn VSIInstallOSSFileHandler();
}
extern "C" {
    pub fn VSIInstallOSSStreamingFileHandler();
}
extern "C" {
    pub fn VSIInstallSwiftFileHandler();
}
extern "C" {
    pub fn VSIInstallSwiftStreamingFileHandler();
}
extern "C" {
    pub fn VSIInstallGZipFileHandler();
}
extern "C" {
    pub fn VSIInstallZipFileHandler();
}
extern "C" {
    pub fn VSIInstallStdinHandler();
}
extern "C" {
    pub fn VSIInstallHdfsHandler();
}
extern "C" {
    pub fn VSIInstallWebHdfsHandler();
}
extern "C" {
    pub fn VSIInstallStdoutHandler();
}
extern "C" {
    pub fn VSIInstallSparseFileHandler();
}
extern "C" {
    pub fn VSIInstallTarFileHandler();
}
extern "C" {
    pub fn VSIInstallCryptFileHandler();
}
extern "C" {
    pub fn VSISetCryptKey(pabyKey: *const GByte, nKeySize: libc::c_int);
}
extern "C" {
    #[doc = " @cond Doxygen_Suppress"]
    pub fn VSICleanupFileManager();
}
extern "C" {
    #[doc = " @endcond"]
    pub fn VSIFileFromMemBuffer(
        pszFilename: *const libc::c_char,
        pabyData: *mut GByte,
        nDataLength: vsi_l_offset,
        bTakeOwnership: libc::c_int,
    ) -> *mut VSILFILE;
}
extern "C" {
    pub fn VSIGetMemFileBuffer(
        pszFilename: *const libc::c_char,
        pnDataLength: *mut vsi_l_offset,
        bUnlinkAndSeize: libc::c_int,
    ) -> *mut GByte;
}
#[doc = " Callback used by VSIStdoutSetRedirection()"]
pub type VSIWriteFunction = ::std::option::Option<
    unsafe extern "C" fn(
        ptr: *const libc::c_void,
        size: usize,
        nmemb: usize,
        stream: *mut FILE,
    ) -> usize,
>;
extern "C" {
    pub fn VSIStdoutSetRedirection(pFct: VSIWriteFunction, stream: *mut FILE);
}
#[doc = " Return information about a handle. Optional (driver dependent)\n @since GDAL 3.0"]
pub type VSIFilesystemPluginStatCallback = ::std::option::Option<
    unsafe extern "C" fn(
        pUserData: *mut libc::c_void,
        pszFilename: *const libc::c_char,
        pStatBuf: *mut VSIStatBufL,
        nFlags: libc::c_int,
    ) -> libc::c_int,
>;
#[doc = " Remove handle by name. Optional\n @since GDAL 3.0"]
pub type VSIFilesystemPluginUnlinkCallback = ::std::option::Option<
    unsafe extern "C" fn(
        pUserData: *mut libc::c_void,
        pszFilename: *const libc::c_char,
    ) -> libc::c_int,
>;
#[doc = " Rename handle. Optional\n @since GDAL 3.0"]
pub type VSIFilesystemPluginRenameCallback = ::std::option::Option<
    unsafe extern "C" fn(
        pUserData: *mut libc::c_void,
        oldpath: *const libc::c_char,
        newpath: *const libc::c_char,
    ) -> libc::c_int,
>;
#[doc = " Create Directory. Optional\n @since GDAL 3.0"]
pub type VSIFilesystemPluginMkdirCallback = ::std::option::Option<
    unsafe extern "C" fn(
        pUserData: *mut libc::c_void,
        pszDirname: *const libc::c_char,
        nMode: libc::c_long,
    ) -> libc::c_int,
>;
#[doc = "  Delete Directory. Optional\n @since GDAL 3.0"]
pub type VSIFilesystemPluginRmdirCallback = ::std::option::Option<
    unsafe extern "C" fn(
        pUserData: *mut libc::c_void,
        pszDirname: *const libc::c_char,
    ) -> libc::c_int,
>;
#[doc = " List directory content. Optional\n @since GDAL 3.0"]
pub type VSIFilesystemPluginReadDirCallback = ::std::option::Option<
    unsafe extern "C" fn(
        pUserData: *mut libc::c_void,
        pszDirname: *const libc::c_char,
        nMaxFiles: libc::c_int,
    ) -> *mut *mut libc::c_char,
>;
#[doc = " List related files. Must return NULL if unknown, or a list of relative filenames\n that can be opened along the main file. If no other file than pszFilename needs to\n be opened, return static_cast<char**> (CPLCalloc(1,sizeof(char*)));\n\n Optional\n @since GDAL 3.2"]
pub type VSIFilesystemPluginSiblingFilesCallback = ::std::option::Option<
    unsafe extern "C" fn(
        pUserData: *mut libc::c_void,
        pszDirname: *const libc::c_char,
    ) -> *mut *mut libc::c_char,
>;
#[doc = " Open a handle. Mandatory. Returns an opaque pointer that will be used in subsequent file I/O calls.\n Should return null and/or set errno if the handle does not exist or the access mode is incorrect.\n @since GDAL 3.0"]
pub type VSIFilesystemPluginOpenCallback = ::std::option::Option<
    unsafe extern "C" fn(
        pUserData: *mut libc::c_void,
        pszFilename: *const libc::c_char,
        pszAccess: *const libc::c_char,
    ) -> *mut libc::c_void,
>;
#[doc = " Return current position in handle. Mandatory\n @since GDAL 3.0"]
pub type VSIFilesystemPluginTellCallback =
    ::std::option::Option<unsafe extern "C" fn(pFile: *mut libc::c_void) -> vsi_l_offset>;
#[doc = " Seek to position in handle. Mandatory except for write only handles\n @since GDAL 3.0"]
pub type VSIFilesystemPluginSeekCallback = ::std::option::Option<
    unsafe extern "C" fn(
        pFile: *mut libc::c_void,
        nOffset: vsi_l_offset,
        nWhence: libc::c_int,
    ) -> libc::c_int,
>;
#[doc = " Read data from current position, returns the number of blocks correctly read.\n Mandatory except for write only handles\n @since GDAL 3.0"]
pub type VSIFilesystemPluginReadCallback = ::std::option::Option<
    unsafe extern "C" fn(
        pFile: *mut libc::c_void,
        pBuffer: *mut libc::c_void,
        nSize: usize,
        nCount: usize,
    ) -> usize,
>;
#[doc = " Read from multiple offsets. Optional, will be replaced by multiple calls to Read() if not provided\n @since GDAL 3.0"]
pub type VSIFilesystemPluginReadMultiRangeCallback = ::std::option::Option<
    unsafe extern "C" fn(
        pFile: *mut libc::c_void,
        nRanges: libc::c_int,
        ppData: *mut *mut libc::c_void,
        panOffsets: *const vsi_l_offset,
        panSizes: *const usize,
    ) -> libc::c_int,
>;
#[doc = " Get empty ranges. Optional\n @since GDAL 3.0"]
pub type VSIFilesystemPluginGetRangeStatusCallback = ::std::option::Option<
    unsafe extern "C" fn(
        pFile: *mut libc::c_void,
        nOffset: vsi_l_offset,
        nLength: vsi_l_offset,
    ) -> VSIRangeStatus::Type,
>;
#[doc = " Has end of file been reached. Mandatory? for read handles.\n @since GDAL 3.0"]
pub type VSIFilesystemPluginEofCallback =
    ::std::option::Option<unsafe extern "C" fn(pFile: *mut libc::c_void) -> libc::c_int>;
#[doc = " Write bytes at current offset. Mandatory for writable handles\n @since GDAL 3.0"]
pub type VSIFilesystemPluginWriteCallback = ::std::option::Option<
    unsafe extern "C" fn(
        pFile: *mut libc::c_void,
        pBuffer: *const libc::c_void,
        nSize: usize,
        nCount: usize,
    ) -> usize,
>;
#[doc = " Sync written bytes. Optional\n @since GDAL 3.0"]
pub type VSIFilesystemPluginFlushCallback =
    ::std::option::Option<unsafe extern "C" fn(pFile: *mut libc::c_void) -> libc::c_int>;
#[doc = " Truncate handle. Mandatory (driver dependent?) for write handles"]
pub type VSIFilesystemPluginTruncateCallback = ::std::option::Option<
    unsafe extern "C" fn(pFile: *mut libc::c_void, nNewSize: vsi_l_offset) -> libc::c_int,
>;
#[doc = " Close file handle. Optional\n @since GDAL 3.0"]
pub type VSIFilesystemPluginCloseCallback =
    ::std::option::Option<unsafe extern "C" fn(pFile: *mut libc::c_void) -> libc::c_int>;
#[doc = " struct containing callbacks to used by the handler.\n (rw), (r), (w) or () at the end indicate whether the given callback is mandatory\n for reading and or writing handlers. A (?) indicates that the callback might\n be mandatory for certain drivers only.\n @since GDAL 3.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VSIFilesystemPluginCallbacksStruct {
    #[doc = " Optional opaque pointer passed back to filemanager callbacks (e.g. open, stat, rmdir)"]
    pub pUserData: *mut libc::c_void,
    #[doc = "< stat handle by name (rw)"]
    pub stat: VSIFilesystemPluginStatCallback,
    #[doc = "< unlink handle by name ()"]
    pub unlink: VSIFilesystemPluginUnlinkCallback,
    #[doc = "< rename handle ()"]
    pub rename: VSIFilesystemPluginRenameCallback,
    #[doc = "< make directory ()"]
    pub mkdir: VSIFilesystemPluginMkdirCallback,
    #[doc = "< remove directory ()"]
    pub rmdir: VSIFilesystemPluginRmdirCallback,
    #[doc = "< list directory content (r?)"]
    pub read_dir: VSIFilesystemPluginReadDirCallback,
    #[doc = "< open handle by name (rw)"]
    pub open: VSIFilesystemPluginOpenCallback,
    #[doc = "< get current position of handle (rw)"]
    pub tell: VSIFilesystemPluginTellCallback,
    #[doc = "< set current position of handle (rw)"]
    pub seek: VSIFilesystemPluginSeekCallback,
    #[doc = "< read from current position (r)"]
    pub read: VSIFilesystemPluginReadCallback,
    #[doc = "< read multiple blocks ()"]
    pub read_multi_range: VSIFilesystemPluginReadMultiRangeCallback,
    #[doc = "< get range status ()"]
    pub get_range_status: VSIFilesystemPluginGetRangeStatusCallback,
    #[doc = "< has end of file been reached (r?)"]
    pub eof: VSIFilesystemPluginEofCallback,
    #[doc = "< write bytes to current position (w)"]
    pub write: VSIFilesystemPluginWriteCallback,
    #[doc = "< sync bytes (w)"]
    pub flush: VSIFilesystemPluginFlushCallback,
    #[doc = "< truncate handle (w?)"]
    pub truncate: VSIFilesystemPluginTruncateCallback,
    #[doc = "< close handle  (rw)"]
    pub close: VSIFilesystemPluginCloseCallback,
    #[doc = "< buffer small reads (makes handler read only)"]
    pub nBufferSize: usize,
    #[doc = "< max mem to use per file when buffering"]
    pub nCacheSize: usize,
    #[doc = "< list related files"]
    pub sibling_files: VSIFilesystemPluginSiblingFilesCallback,
}
#[test]
fn bindgen_test_layout_VSIFilesystemPluginCallbacksStruct() {
    const UNINIT: ::std::mem::MaybeUninit<VSIFilesystemPluginCallbacksStruct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VSIFilesystemPluginCallbacksStruct>(),
        168usize,
        concat!("Size of: ", stringify!(VSIFilesystemPluginCallbacksStruct))
    );
    assert_eq!(
        ::std::mem::align_of::<VSIFilesystemPluginCallbacksStruct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VSIFilesystemPluginCallbacksStruct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pUserData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIFilesystemPluginCallbacksStruct),
            "::",
            stringify!(pUserData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stat) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIFilesystemPluginCallbacksStruct),
            "::",
            stringify!(stat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unlink) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIFilesystemPluginCallbacksStruct),
            "::",
            stringify!(unlink)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rename) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIFilesystemPluginCallbacksStruct),
            "::",
            stringify!(rename)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mkdir) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIFilesystemPluginCallbacksStruct),
            "::",
            stringify!(mkdir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rmdir) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIFilesystemPluginCallbacksStruct),
            "::",
            stringify!(rmdir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_dir) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIFilesystemPluginCallbacksStruct),
            "::",
            stringify!(read_dir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).open) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIFilesystemPluginCallbacksStruct),
            "::",
            stringify!(open)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tell) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIFilesystemPluginCallbacksStruct),
            "::",
            stringify!(tell)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seek) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIFilesystemPluginCallbacksStruct),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIFilesystemPluginCallbacksStruct),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_multi_range) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIFilesystemPluginCallbacksStruct),
            "::",
            stringify!(read_multi_range)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_range_status) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIFilesystemPluginCallbacksStruct),
            "::",
            stringify!(get_range_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eof) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIFilesystemPluginCallbacksStruct),
            "::",
            stringify!(eof)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIFilesystemPluginCallbacksStruct),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flush) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIFilesystemPluginCallbacksStruct),
            "::",
            stringify!(flush)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).truncate) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIFilesystemPluginCallbacksStruct),
            "::",
            stringify!(truncate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIFilesystemPluginCallbacksStruct),
            "::",
            stringify!(close)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nBufferSize) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIFilesystemPluginCallbacksStruct),
            "::",
            stringify!(nBufferSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nCacheSize) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIFilesystemPluginCallbacksStruct),
            "::",
            stringify!(nCacheSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sibling_files) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(VSIFilesystemPluginCallbacksStruct),
            "::",
            stringify!(sibling_files)
        )
    );
}
extern "C" {
    #[doc = " return a VSIFilesystemPluginCallbacksStruct to be populated at runtime with handler callbacks\n @since GDAL 3.0"]
    pub fn VSIAllocFilesystemPluginCallbacksStruct() -> *mut VSIFilesystemPluginCallbacksStruct;
}
extern "C" {
    #[doc = " free resources allocated by VSIAllocFilesystemPluginCallbacksStruct\n @since GDAL 3.0"]
    pub fn VSIFreeFilesystemPluginCallbacksStruct(poCb: *mut VSIFilesystemPluginCallbacksStruct);
}
extern "C" {
    #[doc = " register a handler on the given prefix. All IO on datasets opened with the filename /prefix/xxxxxx\n will go through these callbacks.\n pszPrefix must begin and end with a '/'\n @since GDAL 3.0"]
    pub fn VSIInstallPluginHandler(
        pszPrefix: *const libc::c_char,
        poCb: *const VSIFilesystemPluginCallbacksStruct,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @cond Doxygen_Suppress"]
    pub fn VSITime(arg1: *mut libc::c_ulong) -> libc::c_ulong;
}
extern "C" {
    pub fn VSICTime(arg1: libc::c_ulong) -> *const libc::c_char;
}
extern "C" {
    pub fn VSIGMTime(pnTime: *const time_t, poBrokenTime: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn VSILocalTime(pnTime: *const time_t, poBrokenTime: *mut tm) -> *mut tm;
}
pub mod CPLErr {
    #[doc = " Error category"]
    pub type Type = libc::c_uint;
    pub const CE_None: Type = 0;
    pub const CE_Debug: Type = 1;
    pub const CE_Warning: Type = 2;
    pub const CE_Failure: Type = 3;
    pub const CE_Fatal: Type = 4;
}
#[doc = " Error number"]
pub type CPLErrorNum = libc::c_int;
extern "C" {
    pub fn CPLError(eErrClass: CPLErr::Type, err_no: CPLErrorNum, fmt: *const libc::c_char, ...);
}
extern "C" {
    pub fn CPLErrorV(
        arg1: CPLErr::Type,
        arg2: CPLErrorNum,
        arg3: *const libc::c_char,
        arg4: *mut __va_list_tag,
    );
}
extern "C" {
    pub fn CPLEmergencyError(arg1: *const libc::c_char) -> !;
}
extern "C" {
    pub fn CPLErrorReset();
}
extern "C" {
    pub fn CPLGetLastErrorNo() -> CPLErrorNum;
}
extern "C" {
    pub fn CPLGetLastErrorType() -> CPLErr::Type;
}
extern "C" {
    pub fn CPLGetLastErrorMsg() -> *const libc::c_char;
}
extern "C" {
    pub fn CPLGetErrorCounter() -> GUInt32;
}
extern "C" {
    pub fn CPLGetErrorHandlerUserData() -> *mut libc::c_void;
}
extern "C" {
    pub fn CPLErrorSetState(
        eErrClass: CPLErr::Type,
        err_no: CPLErrorNum,
        pszMsg: *const libc::c_char,
    );
}
extern "C" {
    #[doc = " @cond Doxygen_Suppress"]
    pub fn CPLCleanupErrorMutex();
}
#[doc = " Callback for a custom error handler"]
pub type CPLErrorHandler = ::std::option::Option<
    unsafe extern "C" fn(arg1: CPLErr::Type, arg2: CPLErrorNum, arg3: *const libc::c_char),
>;
extern "C" {
    pub fn CPLLoggingErrorHandler(arg1: CPLErr::Type, arg2: CPLErrorNum, arg3: *const libc::c_char);
}
extern "C" {
    pub fn CPLDefaultErrorHandler(arg1: CPLErr::Type, arg2: CPLErrorNum, arg3: *const libc::c_char);
}
extern "C" {
    pub fn CPLQuietErrorHandler(arg1: CPLErr::Type, arg2: CPLErrorNum, arg3: *const libc::c_char);
}
extern "C" {
    pub fn CPLTurnFailureIntoWarning(bOn: libc::c_int);
}
extern "C" {
    pub fn CPLSetErrorHandler(arg1: CPLErrorHandler) -> CPLErrorHandler;
}
extern "C" {
    pub fn CPLSetErrorHandlerEx(arg1: CPLErrorHandler, arg2: *mut libc::c_void) -> CPLErrorHandler;
}
extern "C" {
    pub fn CPLPushErrorHandler(arg1: CPLErrorHandler);
}
extern "C" {
    pub fn CPLPushErrorHandlerEx(arg1: CPLErrorHandler, arg2: *mut libc::c_void);
}
extern "C" {
    pub fn CPLSetCurrentErrorHandlerCatchDebug(bCatchDebug: libc::c_int);
}
extern "C" {
    pub fn CPLPopErrorHandler();
}
extern "C" {
    pub fn CPLDebug(arg1: *const libc::c_char, arg2: *const libc::c_char, ...);
}
extern "C" {
    #[doc = " @cond Doxygen_Suppress"]
    pub fn CPLVerifyConfiguration();
}
extern "C" {
    #[doc = " @endcond"]
    pub fn CPLGetConfigOption(
        arg1: *const libc::c_char,
        arg2: *const libc::c_char,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLGetThreadLocalConfigOption(
        arg1: *const libc::c_char,
        arg2: *const libc::c_char,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLSetConfigOption(arg1: *const libc::c_char, arg2: *const libc::c_char);
}
extern "C" {
    pub fn CPLSetThreadLocalConfigOption(
        pszKey: *const libc::c_char,
        pszValue: *const libc::c_char,
    );
}
extern "C" {
    #[doc = " @cond Doxygen_Suppress"]
    pub fn CPLFreeConfig();
}
extern "C" {
    #[doc = " @endcond"]
    pub fn CPLGetConfigOptions() -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn CPLSetConfigOptions(papszConfigOptions: *const *const libc::c_char);
}
extern "C" {
    pub fn CPLGetThreadLocalConfigOptions() -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn CPLSetThreadLocalConfigOptions(papszConfigOptions: *const *const libc::c_char);
}
extern "C" {
    pub fn CPLLoadConfigOptionsFromFile(
        pszFilename: *const libc::c_char,
        bOverrideEnvVars: libc::c_int,
    );
}
extern "C" {
    pub fn CPLLoadConfigOptionsFromPredefinedFiles();
}
extern "C" {
    pub fn CPLMalloc(arg1: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn CPLCalloc(arg1: usize, arg2: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn CPLRealloc(arg1: *mut libc::c_void, arg2: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn CPLStrdup(arg1: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn CPLStrlwr(arg1: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn CPLFGets(
        arg1: *mut libc::c_char,
        arg2: libc::c_int,
        arg3: *mut FILE,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn CPLReadLine(arg1: *mut FILE) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLReadLineL(arg1: *mut VSILFILE) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLReadLine2L(
        arg1: *mut VSILFILE,
        arg2: libc::c_int,
        arg3: CSLConstList,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLReadLine3L(
        arg1: *mut VSILFILE,
        arg2: libc::c_int,
        arg3: *mut libc::c_int,
        arg4: CSLConstList,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLAtof(arg1: *const libc::c_char) -> f64;
}
extern "C" {
    pub fn CPLAtofDelim(arg1: *const libc::c_char, arg2: libc::c_char) -> f64;
}
extern "C" {
    pub fn CPLStrtod(arg1: *const libc::c_char, arg2: *mut *mut libc::c_char) -> f64;
}
extern "C" {
    pub fn CPLStrtodDelim(
        arg1: *const libc::c_char,
        arg2: *mut *mut libc::c_char,
        arg3: libc::c_char,
    ) -> f64;
}
extern "C" {
    pub fn CPLStrtof(arg1: *const libc::c_char, arg2: *mut *mut libc::c_char) -> f32;
}
extern "C" {
    pub fn CPLStrtofDelim(
        arg1: *const libc::c_char,
        arg2: *mut *mut libc::c_char,
        arg3: libc::c_char,
    ) -> f32;
}
extern "C" {
    pub fn CPLAtofM(arg1: *const libc::c_char) -> f64;
}
extern "C" {
    pub fn CPLScanString(
        arg1: *const libc::c_char,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn CPLScanDouble(arg1: *const libc::c_char, arg2: libc::c_int) -> f64;
}
extern "C" {
    pub fn CPLScanLong(arg1: *const libc::c_char, arg2: libc::c_int) -> libc::c_long;
}
extern "C" {
    pub fn CPLScanULong(arg1: *const libc::c_char, arg2: libc::c_int) -> libc::c_ulong;
}
extern "C" {
    pub fn CPLScanUIntBig(arg1: *const libc::c_char, arg2: libc::c_int) -> GUIntBig;
}
extern "C" {
    pub fn CPLAtoGIntBig(pszString: *const libc::c_char) -> GIntBig;
}
extern "C" {
    pub fn CPLAtoGIntBigEx(
        pszString: *const libc::c_char,
        bWarn: libc::c_int,
        pbOverflow: *mut libc::c_int,
    ) -> GIntBig;
}
extern "C" {
    pub fn CPLScanPointer(arg1: *const libc::c_char, arg2: libc::c_int) -> *mut libc::c_void;
}
extern "C" {
    pub fn CPLPrintString(
        arg1: *mut libc::c_char,
        arg2: *const libc::c_char,
        arg3: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CPLPrintStringFill(
        arg1: *mut libc::c_char,
        arg2: *const libc::c_char,
        arg3: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CPLPrintInt32(arg1: *mut libc::c_char, arg2: GInt32, arg3: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn CPLPrintUIntBig(
        arg1: *mut libc::c_char,
        arg2: GUIntBig,
        arg3: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CPLPrintDouble(
        arg1: *mut libc::c_char,
        arg2: *const libc::c_char,
        arg3: f64,
        arg4: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CPLPrintTime(
        arg1: *mut libc::c_char,
        arg2: libc::c_int,
        arg3: *const libc::c_char,
        arg4: *const tm,
        arg5: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CPLPrintPointer(
        arg1: *mut libc::c_char,
        arg2: *mut libc::c_void,
        arg3: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CPLGetSymbol(arg1: *const libc::c_char, arg2: *const libc::c_char) -> *mut libc::c_void;
}
extern "C" {
    pub fn CPLGetExecPath(pszPathBuf: *mut libc::c_char, nMaxLength: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn CPLGetPath(arg1: *const libc::c_char) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLGetDirname(arg1: *const libc::c_char) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLGetFilename(arg1: *const libc::c_char) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLGetBasename(arg1: *const libc::c_char) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLGetExtension(arg1: *const libc::c_char) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLGetCurrentDir() -> *mut libc::c_char;
}
extern "C" {
    pub fn CPLFormFilename(
        pszPath: *const libc::c_char,
        pszBasename: *const libc::c_char,
        pszExtension: *const libc::c_char,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLFormCIFilename(
        pszPath: *const libc::c_char,
        pszBasename: *const libc::c_char,
        pszExtension: *const libc::c_char,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLResetExtension(
        arg1: *const libc::c_char,
        arg2: *const libc::c_char,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLProjectRelativeFilename(
        pszProjectDir: *const libc::c_char,
        pszSecondaryFilename: *const libc::c_char,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLIsFilenameRelative(pszFilename: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn CPLExtractRelativePath(
        arg1: *const libc::c_char,
        arg2: *const libc::c_char,
        arg3: *mut libc::c_int,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLCleanTrailingSlash(arg1: *const libc::c_char) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLCorrespondingPaths(
        pszOldFilename: *const libc::c_char,
        pszNewFilename: *const libc::c_char,
        papszFileList: *mut *mut libc::c_char,
    ) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn CPLCheckForFile(
        pszFilename: *mut libc::c_char,
        papszSiblingList: *mut *mut libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CPLGenerateTempFilename(pszStem: *const libc::c_char) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLExpandTilde(pszFilename: *const libc::c_char) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLGetHomeDir() -> *const libc::c_char;
}
extern "C" {
    pub fn CPLLaunderForFilename(
        pszName: *const libc::c_char,
        pszOutputPath: *const libc::c_char,
    ) -> *const libc::c_char;
}
#[doc = " Callback for CPLPushFileFinder"]
pub type CPLFileFinder = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const libc::c_char,
        arg2: *const libc::c_char,
    ) -> *const libc::c_char,
>;
extern "C" {
    pub fn CPLFindFile(
        pszClass: *const libc::c_char,
        pszBasename: *const libc::c_char,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLDefaultFindFile(
        pszClass: *const libc::c_char,
        pszBasename: *const libc::c_char,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLPushFileFinder(pfnFinder: CPLFileFinder);
}
extern "C" {
    pub fn CPLPopFileFinder() -> CPLFileFinder;
}
extern "C" {
    pub fn CPLPushFinderLocation(arg1: *const libc::c_char);
}
extern "C" {
    pub fn CPLPopFinderLocation();
}
extern "C" {
    pub fn CPLFinderClean();
}
extern "C" {
    pub fn CPLStat(arg1: *const libc::c_char, arg2: *mut VSIStatBuf) -> libc::c_int;
}
#[doc = " Information on a shared file"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CPLSharedFileInfo {
    #[doc = "< File pointer"]
    pub fp: *mut FILE,
    #[doc = "< Reference counter"]
    pub nRefCount: libc::c_int,
    #[doc = "< Whether fp must be interpreted as VSIFILE*"]
    pub bLarge: libc::c_int,
    #[doc = "< Filename"]
    pub pszFilename: *mut libc::c_char,
    #[doc = "< Access mode"]
    pub pszAccess: *mut libc::c_char,
}
#[test]
fn bindgen_test_layout_CPLSharedFileInfo() {
    const UNINIT: ::std::mem::MaybeUninit<CPLSharedFileInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CPLSharedFileInfo>(),
        32usize,
        concat!("Size of: ", stringify!(CPLSharedFileInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CPLSharedFileInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CPLSharedFileInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CPLSharedFileInfo),
            "::",
            stringify!(fp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nRefCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CPLSharedFileInfo),
            "::",
            stringify!(nRefCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bLarge) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CPLSharedFileInfo),
            "::",
            stringify!(bLarge)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pszFilename) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CPLSharedFileInfo),
            "::",
            stringify!(pszFilename)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pszAccess) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CPLSharedFileInfo),
            "::",
            stringify!(pszAccess)
        )
    );
}
extern "C" {
    pub fn CPLOpenShared(
        arg1: *const libc::c_char,
        arg2: *const libc::c_char,
        arg3: libc::c_int,
    ) -> *mut FILE;
}
extern "C" {
    pub fn CPLCloseShared(arg1: *mut FILE);
}
extern "C" {
    pub fn CPLGetSharedList(arg1: *mut libc::c_int) -> *mut CPLSharedFileInfo;
}
extern "C" {
    pub fn CPLDumpSharedList(arg1: *mut FILE);
}
extern "C" {
    #[doc = " @cond Doxygen_Suppress"]
    pub fn CPLCleanupSharedFileMutex();
}
extern "C" {
    #[doc = " @endcond"]
    pub fn CPLDMSToDec(is: *const libc::c_char) -> f64;
}
extern "C" {
    pub fn CPLDecToDMS(
        dfAngle: f64,
        pszAxis: *const libc::c_char,
        nPrecision: libc::c_int,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLPackedDMSToDec(arg1: f64) -> f64;
}
extern "C" {
    pub fn CPLDecToPackedDMS(dfDec: f64) -> f64;
}
extern "C" {
    pub fn CPLStringToComplex(pszString: *const libc::c_char, pdfReal: *mut f64, pdfImag: *mut f64);
}
extern "C" {
    pub fn CPLUnlinkTree(arg1: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn CPLCopyFile(
        pszNewPath: *const libc::c_char,
        pszOldPath: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CPLCopyTree(
        pszNewPath: *const libc::c_char,
        pszOldPath: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CPLMoveFile(
        pszNewPath: *const libc::c_char,
        pszOldPath: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CPLSymlink(
        pszOldPath: *const libc::c_char,
        pszNewPath: *const libc::c_char,
        papszOptions: CSLConstList,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @endcond"]
    pub fn CPLCreateZip(
        pszZipFilename: *const libc::c_char,
        papszOptions: *mut *mut libc::c_char,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn CPLCreateFileInZip(
        hZip: *mut libc::c_void,
        pszFilename: *const libc::c_char,
        papszOptions: *mut *mut libc::c_char,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn CPLWriteFileInZip(
        hZip: *mut libc::c_void,
        pBuffer: *const libc::c_void,
        nBufferSize: libc::c_int,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn CPLCloseFileInZip(hZip: *mut libc::c_void) -> CPLErr::Type;
}
extern "C" {
    pub fn CPLCloseZip(hZip: *mut libc::c_void) -> CPLErr::Type;
}
extern "C" {
    pub fn CPLZLibDeflate(
        ptr: *const libc::c_void,
        nBytes: usize,
        nLevel: libc::c_int,
        outptr: *mut libc::c_void,
        nOutAvailableBytes: usize,
        pnOutBytes: *mut usize,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn CPLZLibInflate(
        ptr: *const libc::c_void,
        nBytes: usize,
        outptr: *mut libc::c_void,
        nOutAvailableBytes: usize,
        pnOutBytes: *mut usize,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn CPLValidateXML(
        pszXMLFilename: *const libc::c_char,
        pszXSDFilename: *const libc::c_char,
        papszOptions: CSLConstList,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CPLsetlocale(category: libc::c_int, locale: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " @cond Doxygen_Suppress"]
    pub fn CPLCleanupSetlocaleMutex();
}
extern "C" {
    #[doc = "CPLIsPowerOfTwo()\n@param i - tested number\n@return TRUE if i is power of two otherwise return FALSE"]
    pub fn CPLIsPowerOfTwo(i: libc::c_uint) -> libc::c_int;
}
extern "C" {
    #[doc = " \\file cpl_string.h\n\n Various convenience functions for working with strings and string lists.\n\n A StringList is just an array of strings with the last pointer being\n NULL.  An empty StringList may be either a NULL pointer, or a pointer to\n a pointer memory location with a NULL value.\n\n A common convention for StringLists is to use them to store name/value\n lists.  In this case the contents are treated like a dictionary of\n name/value pairs.  The actual data is formatted with each string having\n the format \"<name>:<value>\" (though \"=\" is also an acceptable separator).\n A number of the functions in the file operate on name/value style\n string lists (such as CSLSetNameValue(), and CSLFetchNameValue()).\n\n To some extent the CPLStringList C++ class can be used to abstract\n managing string lists a bit but still be able to return them from C\n functions.\n"]
    pub fn CSLAddString(
        papszStrList: *mut *mut libc::c_char,
        pszNewString: *const libc::c_char,
    ) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn CSLAddStringMayFail(
        papszStrList: *mut *mut libc::c_char,
        pszNewString: *const libc::c_char,
    ) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn CSLCount(papszStrList: CSLConstList) -> libc::c_int;
}
extern "C" {
    pub fn CSLGetField(arg1: CSLConstList, arg2: libc::c_int) -> *const libc::c_char;
}
extern "C" {
    pub fn CSLDestroy(papszStrList: *mut *mut libc::c_char);
}
extern "C" {
    pub fn CSLDuplicate(papszStrList: CSLConstList) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn CSLMerge(
        papszOrig: *mut *mut libc::c_char,
        papszOverride: CSLConstList,
    ) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn CSLTokenizeString(pszString: *const libc::c_char) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn CSLTokenizeStringComplex(
        pszString: *const libc::c_char,
        pszDelimiter: *const libc::c_char,
        bHonourStrings: libc::c_int,
        bAllowEmptyTokens: libc::c_int,
    ) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn CSLTokenizeString2(
        pszString: *const libc::c_char,
        pszDelimiter: *const libc::c_char,
        nCSLTFlags: libc::c_int,
    ) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn CSLPrint(papszStrList: CSLConstList, fpOut: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn CSLLoad(pszFname: *const libc::c_char) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn CSLLoad2(
        pszFname: *const libc::c_char,
        nMaxLines: libc::c_int,
        nMaxCols: libc::c_int,
        papszOptions: CSLConstList,
    ) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn CSLSave(papszStrList: CSLConstList, pszFname: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn CSLInsertStrings(
        papszStrList: *mut *mut libc::c_char,
        nInsertAtLineNo: libc::c_int,
        papszNewLines: CSLConstList,
    ) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn CSLInsertString(
        papszStrList: *mut *mut libc::c_char,
        nInsertAtLineNo: libc::c_int,
        pszNewLine: *const libc::c_char,
    ) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn CSLRemoveStrings(
        papszStrList: *mut *mut libc::c_char,
        nFirstLineToDelete: libc::c_int,
        nNumToRemove: libc::c_int,
        ppapszRetStrings: *mut *mut *mut libc::c_char,
    ) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn CSLFindString(papszList: CSLConstList, pszTarget: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn CSLFindStringCaseSensitive(
        papszList: CSLConstList,
        pszTarget: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CSLPartialFindString(
        papszHaystack: CSLConstList,
        pszNeedle: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CSLFindName(papszStrList: CSLConstList, pszName: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn CSLFetchBoolean(
        papszStrList: CSLConstList,
        pszKey: *const libc::c_char,
        bDefault: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CSLTestBoolean(pszValue: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn CPLTestBoolean(pszValue: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn CPLTestBool(pszValue: *const libc::c_char) -> bool;
}
extern "C" {
    pub fn CPLFetchBool(
        papszStrList: CSLConstList,
        pszKey: *const libc::c_char,
        bDefault: bool,
    ) -> bool;
}
extern "C" {
    pub fn CPLParseNameValue(
        pszNameValue: *const libc::c_char,
        ppszKey: *mut *mut libc::c_char,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn CSLFetchNameValue(
        papszStrList: CSLConstList,
        pszName: *const libc::c_char,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn CSLFetchNameValueDef(
        papszStrList: CSLConstList,
        pszName: *const libc::c_char,
        pszDefault: *const libc::c_char,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn CSLFetchNameValueMultiple(
        papszStrList: CSLConstList,
        pszName: *const libc::c_char,
    ) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn CSLAddNameValue(
        papszStrList: *mut *mut libc::c_char,
        pszName: *const libc::c_char,
        pszValue: *const libc::c_char,
    ) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn CSLSetNameValue(
        papszStrList: *mut *mut libc::c_char,
        pszName: *const libc::c_char,
        pszValue: *const libc::c_char,
    ) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn CSLSetNameValueSeparator(
        papszStrList: *mut *mut libc::c_char,
        pszSeparator: *const libc::c_char,
    );
}
extern "C" {
    pub fn CSLParseCommandLine(pszCommandLine: *const libc::c_char) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn CPLEscapeString(
        pszString: *const libc::c_char,
        nLength: libc::c_int,
        nScheme: libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn CPLUnescapeString(
        pszString: *const libc::c_char,
        pnLength: *mut libc::c_int,
        nScheme: libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn CPLBinaryToHex(nBytes: libc::c_int, pabyData: *const GByte) -> *mut libc::c_char;
}
extern "C" {
    pub fn CPLHexToBinary(pszHex: *const libc::c_char, pnBytes: *mut libc::c_int) -> *mut GByte;
}
extern "C" {
    pub fn CPLBase64Encode(nBytes: libc::c_int, pabyData: *const GByte) -> *mut libc::c_char;
}
extern "C" {
    pub fn CPLBase64DecodeInPlace(pszBase64: *mut GByte) -> libc::c_int;
}
pub mod CPLValueType {
    #[doc = " Type of value"]
    pub type Type = libc::c_uint;
    #[doc = "< String"]
    pub const CPL_VALUE_STRING: Type = 0;
    #[doc = "< Real number"]
    pub const CPL_VALUE_REAL: Type = 1;
    #[doc = "< Integer"]
    pub const CPL_VALUE_INTEGER: Type = 2;
}
extern "C" {
    pub fn CPLGetValueType(pszValue: *const libc::c_char) -> CPLValueType::Type;
}
extern "C" {
    pub fn CPLStrlcpy(
        pszDest: *mut libc::c_char,
        pszSrc: *const libc::c_char,
        nDestSize: usize,
    ) -> usize;
}
extern "C" {
    pub fn CPLStrlcat(
        pszDest: *mut libc::c_char,
        pszSrc: *const libc::c_char,
        nDestSize: usize,
    ) -> usize;
}
extern "C" {
    pub fn CPLStrnlen(pszStr: *const libc::c_char, nMaxLen: usize) -> usize;
}
extern "C" {
    pub fn CPLvsnprintf(
        str_: *mut libc::c_char,
        size: usize,
        fmt: *const libc::c_char,
        args: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CPLsnprintf(
        str_: *mut libc::c_char,
        size: usize,
        fmt: *const libc::c_char,
        ...
    ) -> libc::c_int;
}
extern "C" {
    pub fn CPLsprintf(str_: *mut libc::c_char, fmt: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    #[doc = " @endcond"]
    pub fn CPLprintf(fmt: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    #[doc = " @cond Doxygen_Suppress"]
    pub fn CPLsscanf(str_: *const libc::c_char, fmt: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    #[doc = " @endcond"]
    pub fn CPLSPrintf(fmt: *const libc::c_char, ...) -> *const libc::c_char;
}
extern "C" {
    pub fn CSLAppendPrintf(
        papszStrList: *mut *mut libc::c_char,
        fmt: *const libc::c_char,
        ...
    ) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn CPLVASPrintf(
        buf: *mut *mut libc::c_char,
        fmt: *const libc::c_char,
        args: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CPLEncodingCharSize(pszEncoding: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = " @cond Doxygen_Suppress"]
    pub fn CPLClearRecodeWarningFlags();
}
extern "C" {
    #[doc = " @endcond"]
    pub fn CPLRecode(
        pszSource: *const libc::c_char,
        pszSrcEncoding: *const libc::c_char,
        pszDstEncoding: *const libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn CPLRecodeFromWChar(
        pwszSource: *const wchar_t,
        pszSrcEncoding: *const libc::c_char,
        pszDstEncoding: *const libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn CPLRecodeToWChar(
        pszSource: *const libc::c_char,
        pszSrcEncoding: *const libc::c_char,
        pszDstEncoding: *const libc::c_char,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn CPLIsUTF8(pabyData: *const libc::c_char, nLen: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn CPLIsASCII(pabyData: *const libc::c_char, nLen: usize) -> bool;
}
extern "C" {
    pub fn CPLForceToASCII(
        pabyData: *const libc::c_char,
        nLen: libc::c_int,
        chReplacementChar: libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn CPLStrlenUTF8(pszUTF8Str: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn CPLCanRecode(
        pszTestStr: *const libc::c_char,
        pszSrcEncoding: *const libc::c_char,
        pszDstEncoding: *const libc::c_char,
    ) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CPLHashSet {
    _unused: [u8; 0],
}
#[doc = " Opaque type for a hash set"]
pub type CPLHashSet = _CPLHashSet;
#[doc = " CPLHashSetHashFunc"]
pub type CPLHashSetHashFunc =
    ::std::option::Option<unsafe extern "C" fn(elt: *const libc::c_void) -> libc::c_ulong>;
#[doc = " CPLHashSetEqualFunc"]
pub type CPLHashSetEqualFunc = ::std::option::Option<
    unsafe extern "C" fn(elt1: *const libc::c_void, elt2: *const libc::c_void) -> libc::c_int,
>;
#[doc = " CPLHashSetFreeEltFunc"]
pub type CPLHashSetFreeEltFunc =
    ::std::option::Option<unsafe extern "C" fn(elt: *mut libc::c_void)>;
#[doc = " CPLHashSetIterEltFunc"]
pub type CPLHashSetIterEltFunc = ::std::option::Option<
    unsafe extern "C" fn(elt: *mut libc::c_void, user_data: *mut libc::c_void) -> libc::c_int,
>;
extern "C" {
    pub fn CPLHashSetNew(
        fnHashFunc: CPLHashSetHashFunc,
        fnEqualFunc: CPLHashSetEqualFunc,
        fnFreeEltFunc: CPLHashSetFreeEltFunc,
    ) -> *mut CPLHashSet;
}
extern "C" {
    pub fn CPLHashSetDestroy(set: *mut CPLHashSet);
}
extern "C" {
    pub fn CPLHashSetClear(set: *mut CPLHashSet);
}
extern "C" {
    pub fn CPLHashSetSize(set: *const CPLHashSet) -> libc::c_int;
}
extern "C" {
    pub fn CPLHashSetForeach(
        set: *mut CPLHashSet,
        fnIterFunc: CPLHashSetIterEltFunc,
        user_data: *mut libc::c_void,
    );
}
extern "C" {
    pub fn CPLHashSetInsert(set: *mut CPLHashSet, elt: *mut libc::c_void) -> libc::c_int;
}
extern "C" {
    pub fn CPLHashSetLookup(set: *mut CPLHashSet, elt: *const libc::c_void) -> *mut libc::c_void;
}
extern "C" {
    pub fn CPLHashSetRemove(set: *mut CPLHashSet, elt: *const libc::c_void) -> libc::c_int;
}
extern "C" {
    pub fn CPLHashSetRemoveDeferRehash(
        set: *mut CPLHashSet,
        elt: *const libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CPLHashSetHashPointer(elt: *const libc::c_void) -> libc::c_ulong;
}
extern "C" {
    pub fn CPLHashSetEqualPointer(
        elt1: *const libc::c_void,
        elt2: *const libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CPLHashSetHashStr(pszStr: *const libc::c_void) -> libc::c_ulong;
}
extern "C" {
    pub fn CPLHashSetEqualStr(
        pszStr1: *const libc::c_void,
        pszStr2: *const libc::c_void,
    ) -> libc::c_int;
}
#[doc = " List element structure."]
pub type CPLList = _CPLList;
#[doc = " List element structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CPLList {
    #[doc = " Pointer to the data object. Should be allocated and freed by the\n caller."]
    pub pData: *mut libc::c_void,
    #[doc = " Pointer to the next element in list. NULL, if current element is the\n last one."]
    pub psNext: *mut _CPLList,
}
#[test]
fn bindgen_test_layout__CPLList() {
    const UNINIT: ::std::mem::MaybeUninit<_CPLList> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CPLList>(),
        16usize,
        concat!("Size of: ", stringify!(_CPLList))
    );
    assert_eq!(
        ::std::mem::align_of::<_CPLList>(),
        8usize,
        concat!("Alignment of ", stringify!(_CPLList))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CPLList),
            "::",
            stringify!(pData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).psNext) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CPLList),
            "::",
            stringify!(psNext)
        )
    );
}
extern "C" {
    pub fn CPLListAppend(psList: *mut CPLList, pData: *mut libc::c_void) -> *mut CPLList;
}
extern "C" {
    pub fn CPLListInsert(
        psList: *mut CPLList,
        pData: *mut libc::c_void,
        nPosition: libc::c_int,
    ) -> *mut CPLList;
}
extern "C" {
    pub fn CPLListGetLast(psList: *mut CPLList) -> *mut CPLList;
}
extern "C" {
    pub fn CPLListGet(psList: *mut CPLList, nPosition: libc::c_int) -> *mut CPLList;
}
extern "C" {
    pub fn CPLListCount(psList: *const CPLList) -> libc::c_int;
}
extern "C" {
    pub fn CPLListRemove(psList: *mut CPLList, nPosition: libc::c_int) -> *mut CPLList;
}
extern "C" {
    pub fn CPLListDestroy(psList: *mut CPLList);
}
extern "C" {
    pub fn CPLListGetNext(psElement: *const CPLList) -> *mut CPLList;
}
extern "C" {
    pub fn CPLListGetData(psElement: *const CPLList) -> *mut libc::c_void;
}
pub mod CPLXMLNodeType {
    #[doc = " XML node type"]
    pub type Type = libc::c_uint;
    #[doc = " Node is an element"]
    pub const CXT_Element: Type = 0;
    #[doc = " Node is a raw text value"]
    pub const CXT_Text: Type = 1;
    #[doc = " Node is attribute"]
    pub const CXT_Attribute: Type = 2;
    #[doc = " Node is an XML comment."]
    pub const CXT_Comment: Type = 3;
    #[doc = " Node is a special literal"]
    pub const CXT_Literal: Type = 4;
}
#[doc = " Document node structure.\n\n This C structure is used to hold a single text fragment representing a\n component of the document when parsed.   It should be allocated with the\n appropriate CPL function, and freed with CPLDestroyXMLNode().  The structure\n contents should not normally be altered by application code, but may be\n freely examined by application code.\n\n Using the psChild and psNext pointers, a hierarchical tree structure\n for a document can be represented as a tree of CPLXMLNode structures."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CPLXMLNode {
    #[doc = " \\brief Node type\n\n One of CXT_Element, CXT_Text, CXT_Attribute, CXT_Comment,\n or CXT_Literal."]
    pub eType: CPLXMLNodeType::Type,
    #[doc = " \\brief Node value\n\n For CXT_Element this is the name of the element, without the angle\n brackets.  Note there is a single CXT_Element even when the document\n contains a start and end element tag.  The node represents the pair.\n All text or other elements between the start and end tag will appear\n as children nodes of this CXT_Element node.\n\n For CXT_Attribute the pszValue is the attribute name.  The value of\n the attribute will be a CXT_Text child.\n\n For CXT_Text this is the text itself (value of an attribute, or a\n text fragment between an element start and end tags.\n\n For CXT_Literal it is all the literal text.  Currently this is just\n used for !DOCTYPE lines, and the value would be the entire line.\n\n For CXT_Comment the value is all the literal text within the comment,\n but not including the comment start/end indicators (\"<--\" and \"-->\")."]
    pub pszValue: *mut libc::c_char,
    #[doc = " \\brief Next sibling.\n\n Pointer to next sibling, that is the next node appearing after this\n one that has the same parent as this node.  NULL if this node is the\n last child of the parent element."]
    pub psNext: *mut CPLXMLNode,
    #[doc = " \\brief Child node.\n\n Pointer to first child node, if any.  Only CXT_Element and CXT_Attribute\n nodes should have children.  For CXT_Attribute it should be a single\n CXT_Text value node, while CXT_Element can have any kind of child.\n The full list of children for a node are identified by walking the\n psNext's starting with the psChild node."]
    pub psChild: *mut CPLXMLNode,
}
#[test]
fn bindgen_test_layout_CPLXMLNode() {
    const UNINIT: ::std::mem::MaybeUninit<CPLXMLNode> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CPLXMLNode>(),
        32usize,
        concat!("Size of: ", stringify!(CPLXMLNode))
    );
    assert_eq!(
        ::std::mem::align_of::<CPLXMLNode>(),
        8usize,
        concat!("Alignment of ", stringify!(CPLXMLNode))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CPLXMLNode),
            "::",
            stringify!(eType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pszValue) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CPLXMLNode),
            "::",
            stringify!(pszValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).psNext) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CPLXMLNode),
            "::",
            stringify!(psNext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).psChild) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CPLXMLNode),
            "::",
            stringify!(psChild)
        )
    );
}
extern "C" {
    pub fn CPLParseXMLString(arg1: *const libc::c_char) -> *mut CPLXMLNode;
}
extern "C" {
    pub fn CPLDestroyXMLNode(arg1: *mut CPLXMLNode);
}
extern "C" {
    pub fn CPLGetXMLNode(poRoot: *mut CPLXMLNode, pszPath: *const libc::c_char) -> *mut CPLXMLNode;
}
extern "C" {
    pub fn CPLSearchXMLNode(
        poRoot: *mut CPLXMLNode,
        pszTarget: *const libc::c_char,
    ) -> *mut CPLXMLNode;
}
extern "C" {
    pub fn CPLGetXMLValue(
        poRoot: *const CPLXMLNode,
        pszPath: *const libc::c_char,
        pszDefault: *const libc::c_char,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLCreateXMLNode(
        poParent: *mut CPLXMLNode,
        eType: CPLXMLNodeType::Type,
        pszText: *const libc::c_char,
    ) -> *mut CPLXMLNode;
}
extern "C" {
    pub fn CPLSerializeXMLTree(psNode: *const CPLXMLNode) -> *mut libc::c_char;
}
extern "C" {
    pub fn CPLAddXMLChild(psParent: *mut CPLXMLNode, psChild: *mut CPLXMLNode);
}
extern "C" {
    pub fn CPLRemoveXMLChild(psParent: *mut CPLXMLNode, psChild: *mut CPLXMLNode) -> libc::c_int;
}
extern "C" {
    pub fn CPLAddXMLSibling(psOlderSibling: *mut CPLXMLNode, psNewSibling: *mut CPLXMLNode);
}
extern "C" {
    pub fn CPLCreateXMLElementAndValue(
        psParent: *mut CPLXMLNode,
        pszName: *const libc::c_char,
        pszValue: *const libc::c_char,
    ) -> *mut CPLXMLNode;
}
extern "C" {
    pub fn CPLAddXMLAttributeAndValue(
        psParent: *mut CPLXMLNode,
        pszName: *const libc::c_char,
        pszValue: *const libc::c_char,
    );
}
extern "C" {
    pub fn CPLCloneXMLTree(psTree: *const CPLXMLNode) -> *mut CPLXMLNode;
}
extern "C" {
    pub fn CPLSetXMLValue(
        psRoot: *mut CPLXMLNode,
        pszPath: *const libc::c_char,
        pszValue: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CPLStripXMLNamespace(
        psRoot: *mut CPLXMLNode,
        pszNameSpace: *const libc::c_char,
        bRecurse: libc::c_int,
    );
}
extern "C" {
    pub fn CPLCleanXMLElementName(arg1: *mut libc::c_char);
}
extern "C" {
    pub fn CPLParseXMLFile(pszFilename: *const libc::c_char) -> *mut CPLXMLNode;
}
extern "C" {
    pub fn CPLSerializeXMLTreeToFile(
        psTree: *const CPLXMLNode,
        pszFilename: *const libc::c_char,
    ) -> libc::c_int;
}
#[doc = " Describe a rectangle"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CPLRectObj {
    #[doc = "< Minimum x"]
    pub minx: f64,
    #[doc = "< Minimum y"]
    pub miny: f64,
    #[doc = "< Maximum x"]
    pub maxx: f64,
    #[doc = "< Maximum y"]
    pub maxy: f64,
}
#[test]
fn bindgen_test_layout_CPLRectObj() {
    const UNINIT: ::std::mem::MaybeUninit<CPLRectObj> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CPLRectObj>(),
        32usize,
        concat!("Size of: ", stringify!(CPLRectObj))
    );
    assert_eq!(
        ::std::mem::align_of::<CPLRectObj>(),
        8usize,
        concat!("Alignment of ", stringify!(CPLRectObj))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CPLRectObj),
            "::",
            stringify!(minx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).miny) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CPLRectObj),
            "::",
            stringify!(miny)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxx) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CPLRectObj),
            "::",
            stringify!(maxx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxy) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CPLRectObj),
            "::",
            stringify!(maxy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CPLQuadTree {
    _unused: [u8; 0],
}
#[doc = " Opaque type for a quad tree"]
pub type CPLQuadTree = _CPLQuadTree;
#[doc = " CPLQuadTreeGetBoundsFunc"]
pub type CPLQuadTreeGetBoundsFunc = ::std::option::Option<
    unsafe extern "C" fn(hFeature: *const libc::c_void, pBounds: *mut CPLRectObj),
>;
#[doc = " CPLQuadTreeGetBoundsExFunc"]
pub type CPLQuadTreeGetBoundsExFunc = ::std::option::Option<
    unsafe extern "C" fn(
        hFeature: *const libc::c_void,
        pUserData: *mut libc::c_void,
        pBounds: *mut CPLRectObj,
    ),
>;
#[doc = " CPLQuadTreeForeachFunc"]
pub type CPLQuadTreeForeachFunc = ::std::option::Option<
    unsafe extern "C" fn(pElt: *mut libc::c_void, pUserData: *mut libc::c_void) -> libc::c_int,
>;
#[doc = " CPLQuadTreeDumpFeatureFunc"]
pub type CPLQuadTreeDumpFeatureFunc = ::std::option::Option<
    unsafe extern "C" fn(
        hFeature: *const libc::c_void,
        nIndentLevel: libc::c_int,
        pUserData: *mut libc::c_void,
    ),
>;
extern "C" {
    pub fn CPLQuadTreeCreate(
        pGlobalBounds: *const CPLRectObj,
        pfnGetBounds: CPLQuadTreeGetBoundsFunc,
    ) -> *mut CPLQuadTree;
}
extern "C" {
    pub fn CPLQuadTreeCreateEx(
        pGlobalBounds: *const CPLRectObj,
        pfnGetBounds: CPLQuadTreeGetBoundsExFunc,
        pUserData: *mut libc::c_void,
    ) -> *mut CPLQuadTree;
}
extern "C" {
    pub fn CPLQuadTreeDestroy(hQuadtree: *mut CPLQuadTree);
}
extern "C" {
    pub fn CPLQuadTreeSetBucketCapacity(hQuadtree: *mut CPLQuadTree, nBucketCapacity: libc::c_int);
}
extern "C" {
    pub fn CPLQuadTreeForceUseOfSubNodes(hQuadTree: *mut CPLQuadTree);
}
extern "C" {
    pub fn CPLQuadTreeGetAdvisedMaxDepth(nExpectedFeatures: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn CPLQuadTreeSetMaxDepth(hQuadtree: *mut CPLQuadTree, nMaxDepth: libc::c_int);
}
extern "C" {
    pub fn CPLQuadTreeInsert(hQuadtree: *mut CPLQuadTree, hFeature: *mut libc::c_void);
}
extern "C" {
    pub fn CPLQuadTreeInsertWithBounds(
        hQuadtree: *mut CPLQuadTree,
        hFeature: *mut libc::c_void,
        psBounds: *const CPLRectObj,
    );
}
extern "C" {
    pub fn CPLQuadTreeRemove(
        hQuadtree: *mut CPLQuadTree,
        hFeature: *mut libc::c_void,
        psBounds: *const CPLRectObj,
    );
}
extern "C" {
    pub fn CPLQuadTreeSearch(
        hQuadtree: *const CPLQuadTree,
        pAoi: *const CPLRectObj,
        pnFeatureCount: *mut libc::c_int,
    ) -> *mut *mut libc::c_void;
}
extern "C" {
    pub fn CPLQuadTreeForeach(
        hQuadtree: *const CPLQuadTree,
        pfnForeach: CPLQuadTreeForeachFunc,
        pUserData: *mut libc::c_void,
    );
}
extern "C" {
    pub fn CPLQuadTreeDump(
        hQuadtree: *const CPLQuadTree,
        pfnDumpFeatureFunc: CPLQuadTreeDumpFeatureFunc,
        pUserData: *mut libc::c_void,
    );
}
extern "C" {
    pub fn CPLQuadTreeGetStats(
        hQuadtree: *const CPLQuadTree,
        pnFeatureCount: *mut libc::c_int,
        pnNodeCount: *mut libc::c_int,
        pnMaxDepth: *mut libc::c_int,
        pnMaxBucketCapacity: *mut libc::c_int,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CPLVirtualMem {
    _unused: [u8; 0],
}
#[doc = " Callback triggered when a still unmapped page of virtual memory is accessed.\n The callback has the responsibility of filling the page with relevant values\n\n @param ctxt virtual memory handle.\n @param nOffset offset of the page in the memory mapping.\n @param pPageToFill address of the page to fill. Note that the address might\n                    be a temporary location, and not at CPLVirtualMemGetAddr() + nOffset.\n @param nToFill number of bytes of the page.\n @param pUserData user data that was passed to CPLVirtualMemNew()."]
pub type CPLVirtualMemCachePageCbk = ::std::option::Option<
    unsafe extern "C" fn(
        ctxt: *mut CPLVirtualMem,
        nOffset: usize,
        pPageToFill: *mut libc::c_void,
        nToFill: usize,
        pUserData: *mut libc::c_void,
    ),
>;
#[doc = " Callback triggered when a dirty mapped page is going to be freed.\n (saturation of cache, or termination of the virtual memory mapping).\n\n @param ctxt virtual memory handle.\n @param nOffset offset of the page in the memory mapping.\n @param pPageToBeEvicted address of the page that will be flushed. Note that the address might\n                    be a temporary location, and not at CPLVirtualMemGetAddr() + nOffset.\n @param nToBeEvicted number of bytes of the page.\n @param pUserData user data that was passed to CPLVirtualMemNew()."]
pub type CPLVirtualMemUnCachePageCbk = ::std::option::Option<
    unsafe extern "C" fn(
        ctxt: *mut CPLVirtualMem,
        nOffset: usize,
        pPageToBeEvicted: *const libc::c_void,
        nToBeEvicted: usize,
        pUserData: *mut libc::c_void,
    ),
>;
#[doc = " Callback triggered when a virtual memory mapping is destroyed.\n @param pUserData user data that was passed to CPLVirtualMemNew()."]
pub type CPLVirtualMemFreeUserData =
    ::std::option::Option<unsafe extern "C" fn(pUserData: *mut libc::c_void)>;
pub mod CPLVirtualMemAccessMode {
    #[doc = " Access mode of a virtual memory mapping."]
    pub type Type = libc::c_uint;
    #[doc = " The mapping is meant at being read-only, but writes will not be prevented.\nNote that any content written will be lost."]
    pub const VIRTUALMEM_READONLY: Type = 0;
    #[doc = " The mapping is meant at being read-only, and this will be enforced\nthrough the operating system page protection mechanism."]
    pub const VIRTUALMEM_READONLY_ENFORCED: Type = 1;
    #[doc = " The mapping is meant at being read-write, and modified pages can be saved\nthanks to the pfnUnCachePage callback"]
    pub const VIRTUALMEM_READWRITE: Type = 2;
}
extern "C" {
    #[doc = " Return the size of a page of virtual memory.\n\n @return the page size.\n\n @since GDAL 1.11"]
    pub fn CPLGetPageSize() -> usize;
}
extern "C" {
    #[doc = " Create a new virtual memory mapping.\n\n This will reserve an area of virtual memory of size nSize, whose size\n might be potentially much larger than the physical memory available. Initially,\n no physical memory will be allocated. As soon as memory pages will be accessed,\n they will be allocated transparently and filled with the pfnCachePage callback.\n When the allowed cache size is reached, the least recently used pages will\n be unallocated.\n\n On Linux AMD64 platforms, the maximum value for nSize is 128 TB.\n On Linux x86 platforms, the maximum value for nSize is 2 GB.\n\n Only supported on Linux for now.\n\n Note that on Linux, this function will install a SIGSEGV handler. The\n original handler will be restored by CPLVirtualMemManagerTerminate().\n\n @param nSize size in bytes of the virtual memory mapping.\n @param nCacheSize   size in bytes of the maximum memory that will be really\n                     allocated (must ideally fit into RAM).\n @param nPageSizeHint hint for the page size. Must be a multiple of the\n                      system page size, returned by CPLGetPageSize().\n                      Minimum value is generally 4096. Might be set to 0 to\n                      let the function determine a default page size.\n @param bSingleThreadUsage set to TRUE if there will be no concurrent threads\n                           that will access the virtual memory mapping. This can\n                           optimize performance a bit.\n @param eAccessMode permission to use for the virtual memory mapping.\n @param pfnCachePage callback triggered when a still unmapped page of virtual\n                     memory is accessed. The callback has the responsibility\n                     of filling the page with relevant values.\n @param pfnUnCachePage callback triggered when a dirty mapped page is going to\n                       be freed (saturation of cache, or termination of the\n                       virtual memory mapping). Might be NULL.\n @param pfnFreeUserData callback that can be used to free pCbkUserData. Might be\n                        NULL\n @param pCbkUserData user data passed to pfnCachePage and pfnUnCachePage.\n\n @return a virtual memory object that must be freed by CPLVirtualMemFree(),\n         or NULL in case of failure.\n\n @since GDAL 1.11"]
    pub fn CPLVirtualMemNew(
        nSize: usize,
        nCacheSize: usize,
        nPageSizeHint: usize,
        bSingleThreadUsage: libc::c_int,
        eAccessMode: CPLVirtualMemAccessMode::Type,
        pfnCachePage: CPLVirtualMemCachePageCbk,
        pfnUnCachePage: CPLVirtualMemUnCachePageCbk,
        pfnFreeUserData: CPLVirtualMemFreeUserData,
        pCbkUserData: *mut libc::c_void,
    ) -> *mut CPLVirtualMem;
}
extern "C" {
    #[doc = " Return if virtual memory mapping of a file is available.\n\n @return TRUE if virtual memory mapping of a file is available.\n @since GDAL 1.11"]
    pub fn CPLIsVirtualMemFileMapAvailable() -> libc::c_int;
}
extern "C" {
    #[doc = " Create a new virtual memory mapping from a file.\n\n The file must be a \"real\" file recognized by the operating system, and not\n a VSI extended virtual file.\n\n In VIRTUALMEM_READWRITE mode, updates to the memory mapping will be written\n in the file.\n\n On Linux AMD64 platforms, the maximum value for nLength is 128 TB.\n On Linux x86 platforms, the maximum value for nLength is 2 GB.\n\n Supported on Linux only in GDAL <= 2.0, and all POSIX systems supporting\n mmap() in GDAL >= 2.1\n\n @param  fp       Virtual file handle.\n @param  nOffset  Offset in the file to start the mapping from.\n @param  nLength  Length of the portion of the file to map into memory.\n @param eAccessMode Permission to use for the virtual memory mapping. This must\n                    be consistent with how the file has been opened.\n @param pfnFreeUserData callback that is called when the object is destroyed.\n @param pCbkUserData user data passed to pfnFreeUserData.\n @return a virtual memory object that must be freed by CPLVirtualMemFree(),\n         or NULL in case of failure.\n\n @since GDAL 1.11"]
    pub fn CPLVirtualMemFileMapNew(
        fp: *mut VSILFILE,
        nOffset: vsi_l_offset,
        nLength: vsi_l_offset,
        eAccessMode: CPLVirtualMemAccessMode::Type,
        pfnFreeUserData: CPLVirtualMemFreeUserData,
        pCbkUserData: *mut libc::c_void,
    ) -> *mut CPLVirtualMem;
}
extern "C" {
    #[doc = " Create a new virtual memory mapping derived from an other virtual memory\n  mapping.\n\n This may be useful in case of creating mapping for pixel interleaved data.\n\n The new mapping takes a reference on the base mapping.\n\n @param pVMemBase Base virtual memory mapping\n @param nOffset   Offset in the base virtual memory mapping from which to start\n                  the new mapping.\n @param nSize     Size of the base virtual memory mapping to expose in the\n                  the new mapping.\n @param pfnFreeUserData callback that is called when the object is destroyed.\n @param pCbkUserData user data passed to pfnFreeUserData.\n @return a virtual memory object that must be freed by CPLVirtualMemFree(),\n         or NULL in case of failure.\n\n @since GDAL 1.11"]
    pub fn CPLVirtualMemDerivedNew(
        pVMemBase: *mut CPLVirtualMem,
        nOffset: vsi_l_offset,
        nSize: vsi_l_offset,
        pfnFreeUserData: CPLVirtualMemFreeUserData,
        pCbkUserData: *mut libc::c_void,
    ) -> *mut CPLVirtualMem;
}
extern "C" {
    #[doc = " Free a virtual memory mapping.\n\n The pointer returned by CPLVirtualMemGetAddr() will no longer be valid.\n If the virtual memory mapping was created with read/write permissions and that\n they are dirty (i.e. modified) pages, they will be flushed through the\n pfnUnCachePage callback before being freed.\n\n @param ctxt context returned by CPLVirtualMemNew().\n\n @since GDAL 1.11"]
    pub fn CPLVirtualMemFree(ctxt: *mut CPLVirtualMem);
}
extern "C" {
    #[doc = " Return the pointer to the start of a virtual memory mapping.\n\n The bytes in the range [p:p+CPLVirtualMemGetSize()-1] where p is the pointer\n returned by this function will be valid, until CPLVirtualMemFree() is called.\n\n Note that if a range of bytes used as an argument of a system call\n (such as read() or write()) contains pages that have not been \"realized\", the\n system call will fail with EFAULT. CPLVirtualMemPin() can be used to work\n around this issue.\n\n @param ctxt context returned by CPLVirtualMemNew().\n @return the pointer to the start of a virtual memory mapping.\n\n @since GDAL 1.11"]
    pub fn CPLVirtualMemGetAddr(ctxt: *mut CPLVirtualMem) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Return the size of the virtual memory mapping.\n\n @param ctxt context returned by CPLVirtualMemNew().\n @return the size of the virtual memory mapping.\n\n @since GDAL 1.11"]
    pub fn CPLVirtualMemGetSize(ctxt: *mut CPLVirtualMem) -> usize;
}
extern "C" {
    #[doc = " Return if the virtual memory mapping is a direct file mapping.\n\n @param ctxt context returned by CPLVirtualMemNew().\n @return TRUE if the virtual memory mapping is a direct file mapping.\n\n @since GDAL 1.11"]
    pub fn CPLVirtualMemIsFileMapping(ctxt: *mut CPLVirtualMem) -> libc::c_int;
}
extern "C" {
    #[doc = " Return the access mode of the virtual memory mapping.\n\n @param ctxt context returned by CPLVirtualMemNew().\n @return the access mode of the virtual memory mapping.\n\n @since GDAL 1.11"]
    pub fn CPLVirtualMemGetAccessMode(ctxt: *mut CPLVirtualMem) -> CPLVirtualMemAccessMode::Type;
}
extern "C" {
    #[doc = " Return the page size associated to a virtual memory mapping.\n\n The value returned will be at least CPLGetPageSize(), but potentially\n larger.\n\n @param ctxt context returned by CPLVirtualMemNew().\n @return the page size\n\n @since GDAL 1.11"]
    pub fn CPLVirtualMemGetPageSize(ctxt: *mut CPLVirtualMem) -> usize;
}
extern "C" {
    #[doc = " Return TRUE if this memory mapping can be accessed safely from concurrent\n  threads.\n\n The situation that can cause problems is when several threads try to access\n a page of the mapping that is not yet mapped.\n\n The return value of this function depends on whether bSingleThreadUsage has\n been set of not in CPLVirtualMemNew() and/or the implementation.\n\n On Linux, this will always return TRUE if bSingleThreadUsage = FALSE.\n\n @param ctxt context returned by CPLVirtualMemNew().\n @return TRUE if this memory mapping can be accessed safely from concurrent\n         threads.\n\n @since GDAL 1.11"]
    pub fn CPLVirtualMemIsAccessThreadSafe(ctxt: *mut CPLVirtualMem) -> libc::c_int;
}
extern "C" {
    #[doc = " Declare that a thread will access a virtual memory mapping.\n\n This function must be called by a thread that wants to access the\n content of a virtual memory mapping, except if the virtual memory mapping has\n been created with bSingleThreadUsage = TRUE.\n\n This function must be paired with CPLVirtualMemUnDeclareThread().\n\n @param ctxt context returned by CPLVirtualMemNew().\n\n @since GDAL 1.11"]
    pub fn CPLVirtualMemDeclareThread(ctxt: *mut CPLVirtualMem);
}
extern "C" {
    #[doc = " Declare that a thread will stop accessing a virtual memory mapping.\n\n This function must be called by a thread that will no longer access the\n content of a virtual memory mapping, except if the virtual memory mapping has\n been created with bSingleThreadUsage = TRUE.\n\n This function must be paired with CPLVirtualMemDeclareThread().\n\n @param ctxt context returned by CPLVirtualMemNew().\n\n @since GDAL 1.11"]
    pub fn CPLVirtualMemUnDeclareThread(ctxt: *mut CPLVirtualMem);
}
extern "C" {
    #[doc = " Make sure that a region of virtual memory will be realized.\n\n Calling this function is not required, but might be useful when debugging\n a process with tools like gdb or valgrind that do not naturally like\n segmentation fault signals.\n\n It is also needed when wanting to provide part of virtual memory mapping\n to a system call such as read() or write(). If read() or write() is called\n on a memory region not yet realized, the call will fail with EFAULT.\n\n @param ctxt context returned by CPLVirtualMemNew().\n @param pAddr the memory region to pin.\n @param nSize the size of the memory region.\n @param bWriteOp set to TRUE if the memory are will be accessed in write mode.\n\n @since GDAL 1.11"]
    pub fn CPLVirtualMemPin(
        ctxt: *mut CPLVirtualMem,
        pAddr: *mut libc::c_void,
        nSize: usize,
        bWriteOp: libc::c_int,
    );
}
extern "C" {
    #[doc = " Cleanup any resource and handlers related to virtual memory.\n\n This function must be called after the last CPLVirtualMem object has\n been freed.\n\n @since GDAL 2.0"]
    pub fn CPLVirtualMemManagerTerminate();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OGREnvelope {
    pub MinX: f64,
    pub MaxX: f64,
    pub MinY: f64,
    pub MaxY: f64,
}
#[test]
fn bindgen_test_layout_OGREnvelope() {
    const UNINIT: ::std::mem::MaybeUninit<OGREnvelope> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OGREnvelope>(),
        32usize,
        concat!("Size of: ", stringify!(OGREnvelope))
    );
    assert_eq!(
        ::std::mem::align_of::<OGREnvelope>(),
        8usize,
        concat!("Alignment of ", stringify!(OGREnvelope))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MinX) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGREnvelope),
            "::",
            stringify!(MinX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxX) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OGREnvelope),
            "::",
            stringify!(MaxX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MinY) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OGREnvelope),
            "::",
            stringify!(MinY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxY) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(OGREnvelope),
            "::",
            stringify!(MaxY)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OGREnvelope3D {
    pub MinX: f64,
    pub MaxX: f64,
    pub MinY: f64,
    pub MaxY: f64,
    pub MinZ: f64,
    pub MaxZ: f64,
}
#[test]
fn bindgen_test_layout_OGREnvelope3D() {
    const UNINIT: ::std::mem::MaybeUninit<OGREnvelope3D> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OGREnvelope3D>(),
        48usize,
        concat!("Size of: ", stringify!(OGREnvelope3D))
    );
    assert_eq!(
        ::std::mem::align_of::<OGREnvelope3D>(),
        8usize,
        concat!("Alignment of ", stringify!(OGREnvelope3D))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MinX) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGREnvelope3D),
            "::",
            stringify!(MinX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxX) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OGREnvelope3D),
            "::",
            stringify!(MaxX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MinY) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OGREnvelope3D),
            "::",
            stringify!(MinY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxY) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(OGREnvelope3D),
            "::",
            stringify!(MaxY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MinZ) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(OGREnvelope3D),
            "::",
            stringify!(MinZ)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxZ) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(OGREnvelope3D),
            "::",
            stringify!(MaxZ)
        )
    );
}
extern "C" {
    #[doc = " @cond Doxygen_Suppress"]
    pub fn OGRMalloc(arg1: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn OGRCalloc(arg1: usize, arg2: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn OGRRealloc(arg1: *mut libc::c_void, arg2: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn OGRStrdup(arg1: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn OGRFree(arg1: *mut libc::c_void);
}
pub mod OGRwkbGeometryType {
    #[doc = " List of well known binary geometry types.  These are used within the BLOBs\n but are also returned from OGRGeometry::getGeometryType() to identify the\n type of a geometry object."]
    pub type Type = libc::c_uint;
    #[doc = "< unknown type, non-standard"]
    pub const wkbUnknown: Type = 0;
    #[doc = "< 0-dimensional geometric object, standard WKB"]
    pub const wkbPoint: Type = 1;
    #[doc = "< 1-dimensional geometric object with linear\n   interpolation between Points, standard WKB"]
    pub const wkbLineString: Type = 2;
    #[doc = "< planar 2-dimensional geometric object defined\n   by 1 exterior boundary and 0 or more interior\n   boundaries, standard WKB"]
    pub const wkbPolygon: Type = 3;
    #[doc = "< GeometryCollection of Points, standard WKB"]
    pub const wkbMultiPoint: Type = 4;
    #[doc = "< GeometryCollection of LineStrings, standard WKB"]
    pub const wkbMultiLineString: Type = 5;
    #[doc = "< GeometryCollection of Polygons, standard WKB"]
    pub const wkbMultiPolygon: Type = 6;
    #[doc = "< geometric object that is a collection of 1\nor more geometric objects, standard WKB"]
    pub const wkbGeometryCollection: Type = 7;
    #[doc = "< one or more circular arc segments connected end to end,\n   ISO SQL/MM Part 3. GDAL &gt;= 2.0"]
    pub const wkbCircularString: Type = 8;
    #[doc = "< sequence of contiguous curves, ISO SQL/MM Part 3. GDAL &gt;= 2.0"]
    pub const wkbCompoundCurve: Type = 9;
    #[doc = "< planar surface, defined by 1 exterior boundary\n   and zero or more interior boundaries, that are curves.\n    ISO SQL/MM Part 3. GDAL &gt;= 2.0"]
    pub const wkbCurvePolygon: Type = 10;
    #[doc = "< GeometryCollection of Curves, ISO SQL/MM Part 3. GDAL &gt;= 2.0"]
    pub const wkbMultiCurve: Type = 11;
    #[doc = "< GeometryCollection of Surfaces, ISO SQL/MM Part 3. GDAL &gt;= 2.0"]
    pub const wkbMultiSurface: Type = 12;
    #[doc = "< Curve (abstract type). ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbCurve: Type = 13;
    #[doc = "< Surface (abstract type). ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbSurface: Type = 14;
    #[doc = "< a contiguous collection of polygons, which share common boundary segments,\n   ISO SQL/MM Part 3. GDAL &gt;= 2.3"]
    pub const wkbPolyhedralSurface: Type = 15;
    #[doc = "< a PolyhedralSurface consisting only of Triangle patches\n    ISO SQL/MM Part 3. GDAL &gt;= 2.3"]
    pub const wkbTIN: Type = 16;
    #[doc = "< a Triangle. ISO SQL/MM Part 3. GDAL &gt;= 2.3"]
    pub const wkbTriangle: Type = 17;
    #[doc = "< non-standard, for pure attribute records"]
    pub const wkbNone: Type = 100;
    #[doc = "< non-standard, just for createGeometry()"]
    pub const wkbLinearRing: Type = 101;
    #[doc = "< wkbCircularString with Z component. ISO SQL/MM Part 3. GDAL &gt;= 2.0"]
    pub const wkbCircularStringZ: Type = 1008;
    #[doc = "< wkbCompoundCurve with Z component. ISO SQL/MM Part 3. GDAL &gt;= 2.0"]
    pub const wkbCompoundCurveZ: Type = 1009;
    #[doc = "< wkbCurvePolygon with Z component. ISO SQL/MM Part 3. GDAL &gt;= 2.0"]
    pub const wkbCurvePolygonZ: Type = 1010;
    #[doc = "< wkbMultiCurve with Z component. ISO SQL/MM Part 3. GDAL &gt;= 2.0"]
    pub const wkbMultiCurveZ: Type = 1011;
    #[doc = "< wkbMultiSurface with Z component. ISO SQL/MM Part 3. GDAL &gt;= 2.0"]
    pub const wkbMultiSurfaceZ: Type = 1012;
    #[doc = "< wkbCurve with Z component. ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbCurveZ: Type = 1013;
    #[doc = "< wkbSurface with Z component. ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbSurfaceZ: Type = 1014;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.3"]
    pub const wkbPolyhedralSurfaceZ: Type = 1015;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.3"]
    pub const wkbTINZ: Type = 1016;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.3"]
    pub const wkbTriangleZ: Type = 1017;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbPointM: Type = 2001;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbLineStringM: Type = 2002;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbPolygonM: Type = 2003;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbMultiPointM: Type = 2004;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbMultiLineStringM: Type = 2005;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbMultiPolygonM: Type = 2006;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbGeometryCollectionM: Type = 2007;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbCircularStringM: Type = 2008;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbCompoundCurveM: Type = 2009;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbCurvePolygonM: Type = 2010;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbMultiCurveM: Type = 2011;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbMultiSurfaceM: Type = 2012;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbCurveM: Type = 2013;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbSurfaceM: Type = 2014;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.3"]
    pub const wkbPolyhedralSurfaceM: Type = 2015;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.3"]
    pub const wkbTINM: Type = 2016;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.3"]
    pub const wkbTriangleM: Type = 2017;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbPointZM: Type = 3001;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbLineStringZM: Type = 3002;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbPolygonZM: Type = 3003;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbMultiPointZM: Type = 3004;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbMultiLineStringZM: Type = 3005;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbMultiPolygonZM: Type = 3006;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbGeometryCollectionZM: Type = 3007;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbCircularStringZM: Type = 3008;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbCompoundCurveZM: Type = 3009;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbCurvePolygonZM: Type = 3010;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbMultiCurveZM: Type = 3011;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbMultiSurfaceZM: Type = 3012;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbCurveZM: Type = 3013;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
    pub const wkbSurfaceZM: Type = 3014;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.3"]
    pub const wkbPolyhedralSurfaceZM: Type = 3015;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.3"]
    pub const wkbTINZM: Type = 3016;
    #[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.3"]
    pub const wkbTriangleZM: Type = 3017;
    #[doc = "< 2.5D extension as per 99-402"]
    pub const wkbPoint25D: Type = 2147483649;
    #[doc = "< 2.5D extension as per 99-402"]
    pub const wkbLineString25D: Type = 2147483650;
    #[doc = "< 2.5D extension as per 99-402"]
    pub const wkbPolygon25D: Type = 2147483651;
    #[doc = "< 2.5D extension as per 99-402"]
    pub const wkbMultiPoint25D: Type = 2147483652;
    #[doc = "< 2.5D extension as per 99-402"]
    pub const wkbMultiLineString25D: Type = 2147483653;
    #[doc = "< 2.5D extension as per 99-402"]
    pub const wkbMultiPolygon25D: Type = 2147483654;
    #[doc = "< 2.5D extension as per 99-402"]
    pub const wkbGeometryCollection25D: Type = 2147483655;
}
extern "C" {
    pub fn OGRGeometryTypeToName(eType: OGRwkbGeometryType::Type) -> *const libc::c_char;
}
extern "C" {
    pub fn OGRMergeGeometryTypes(
        eMain: OGRwkbGeometryType::Type,
        eExtra: OGRwkbGeometryType::Type,
    ) -> OGRwkbGeometryType::Type;
}
extern "C" {
    pub fn OGRMergeGeometryTypesEx(
        eMain: OGRwkbGeometryType::Type,
        eExtra: OGRwkbGeometryType::Type,
        bAllowPromotingToCurves: libc::c_int,
    ) -> OGRwkbGeometryType::Type;
}
extern "C" {
    pub fn OGR_GT_Flatten(eType: OGRwkbGeometryType::Type) -> OGRwkbGeometryType::Type;
}
extern "C" {
    pub fn OGR_GT_SetZ(eType: OGRwkbGeometryType::Type) -> OGRwkbGeometryType::Type;
}
extern "C" {
    pub fn OGR_GT_SetM(eType: OGRwkbGeometryType::Type) -> OGRwkbGeometryType::Type;
}
extern "C" {
    pub fn OGR_GT_SetModifier(
        eType: OGRwkbGeometryType::Type,
        bSetZ: libc::c_int,
        bSetM: libc::c_int,
    ) -> OGRwkbGeometryType::Type;
}
extern "C" {
    pub fn OGR_GT_HasZ(eType: OGRwkbGeometryType::Type) -> libc::c_int;
}
extern "C" {
    pub fn OGR_GT_HasM(eType: OGRwkbGeometryType::Type) -> libc::c_int;
}
extern "C" {
    pub fn OGR_GT_IsSubClassOf(
        eType: OGRwkbGeometryType::Type,
        eSuperType: OGRwkbGeometryType::Type,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OGR_GT_IsCurve(arg1: OGRwkbGeometryType::Type) -> libc::c_int;
}
extern "C" {
    pub fn OGR_GT_IsSurface(arg1: OGRwkbGeometryType::Type) -> libc::c_int;
}
extern "C" {
    pub fn OGR_GT_IsNonLinear(arg1: OGRwkbGeometryType::Type) -> libc::c_int;
}
extern "C" {
    pub fn OGR_GT_GetCollection(eType: OGRwkbGeometryType::Type) -> OGRwkbGeometryType::Type;
}
extern "C" {
    pub fn OGR_GT_GetCurve(eType: OGRwkbGeometryType::Type) -> OGRwkbGeometryType::Type;
}
extern "C" {
    pub fn OGR_GT_GetLinear(eType: OGRwkbGeometryType::Type) -> OGRwkbGeometryType::Type;
}
pub mod OGRwkbByteOrder {
    #[doc = " Enumeration to describe byte order"]
    pub type Type = libc::c_uint;
    #[doc = "< MSB/Sun/Motorola: Most Significant Byte First"]
    pub const wkbXDR: Type = 0;
    #[doc = "< LSB/Intel/Vax: Least Significant Byte First"]
    pub const wkbNDR: Type = 1;
}
pub mod OGRFieldType {
    #[doc = " List of feature field types.  This list is likely to be extended in the\n future ... avoid coding applications based on the assumption that all\n field types can be known."]
    pub type Type = libc::c_uint;
    #[doc = " Simple 32bit integer"]
    pub const OFTInteger: Type = 0;
    #[doc = " List of 32bit integers"]
    pub const OFTIntegerList: Type = 1;
    #[doc = " Double Precision floating point"]
    pub const OFTReal: Type = 2;
    #[doc = " List of doubles"]
    pub const OFTRealList: Type = 3;
    #[doc = " String of ASCII chars"]
    pub const OFTString: Type = 4;
    #[doc = " Array of strings"]
    pub const OFTStringList: Type = 5;
    #[doc = " deprecated"]
    pub const OFTWideString: Type = 6;
    #[doc = " deprecated"]
    pub const OFTWideStringList: Type = 7;
    #[doc = " Raw Binary data"]
    pub const OFTBinary: Type = 8;
    #[doc = " Date"]
    pub const OFTDate: Type = 9;
    #[doc = " Time"]
    pub const OFTTime: Type = 10;
    #[doc = " Date and Time"]
    pub const OFTDateTime: Type = 11;
    #[doc = " Single 64bit integer"]
    pub const OFTInteger64: Type = 12;
    #[doc = " List of 64bit integers"]
    pub const OFTInteger64List: Type = 13;
    #[doc = " List of 64bit integers"]
    pub const OFTMaxType: Type = 13;
}
pub mod OGRFieldSubType {
    #[doc = " List of field subtypes. A subtype represents a hint, a restriction of the\n main type, that is not strictly necessary to consult.\n This list is likely to be extended in the\n future ... avoid coding applications based on the assumption that all\n field types can be known.\n Most subtypes only make sense for a restricted set of main types.\n @since GDAL 2.0"]
    pub type Type = libc::c_uint;
    #[doc = " No subtype. This is the default value"]
    pub const OFSTNone: Type = 0;
    #[doc = " Boolean integer. Only valid for OFTInteger and OFTIntegerList."]
    pub const OFSTBoolean: Type = 1;
    #[doc = " Signed 16-bit integer. Only valid for OFTInteger and OFTIntegerList."]
    pub const OFSTInt16: Type = 2;
    #[doc = " Single precision (32 bit) floating point. Only valid for OFTReal and OFTRealList."]
    pub const OFSTFloat32: Type = 3;
    #[doc = " JSON content. Only valid for OFTString.\n @since GDAL 2.4"]
    pub const OFSTJSON: Type = 4;
    #[doc = " UUID string representation. Only valid for OFTString.\n @since GDAL 3.3"]
    pub const OFSTUUID: Type = 5;
    #[doc = " UUID string representation. Only valid for OFTString.\n @since GDAL 3.3"]
    pub const OFSTMaxSubType: Type = 5;
}
pub mod OGRJustification {
    #[doc = " Display justification for field values."]
    pub type Type = libc::c_uint;
    pub const OJUndefined: Type = 0;
    pub const OJLeft: Type = 1;
    pub const OJRight: Type = 2;
}
#[doc = " OGRFeature field attribute value union."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union OGRField {
    #[doc = " @cond Doxygen_Suppress"]
    pub Integer: libc::c_int,
    pub Integer64: GIntBig,
    pub Real: f64,
    pub String: *mut libc::c_char,
    pub IntegerList: OGRField__bindgen_ty_1,
    pub Integer64List: OGRField__bindgen_ty_2,
    pub RealList: OGRField__bindgen_ty_3,
    pub StringList: OGRField__bindgen_ty_4,
    pub Binary: OGRField__bindgen_ty_5,
    pub Set: OGRField__bindgen_ty_6,
    pub Date: OGRField__bindgen_ty_7,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OGRField__bindgen_ty_1 {
    pub nCount: libc::c_int,
    pub paList: *mut libc::c_int,
}
#[test]
fn bindgen_test_layout_OGRField__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<OGRField__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OGRField__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(OGRField__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<OGRField__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(OGRField__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_1),
            "::",
            stringify!(nCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).paList) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_1),
            "::",
            stringify!(paList)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OGRField__bindgen_ty_2 {
    pub nCount: libc::c_int,
    pub paList: *mut GIntBig,
}
#[test]
fn bindgen_test_layout_OGRField__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<OGRField__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OGRField__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(OGRField__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<OGRField__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(OGRField__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_2),
            "::",
            stringify!(nCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).paList) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_2),
            "::",
            stringify!(paList)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OGRField__bindgen_ty_3 {
    pub nCount: libc::c_int,
    pub paList: *mut f64,
}
#[test]
fn bindgen_test_layout_OGRField__bindgen_ty_3() {
    const UNINIT: ::std::mem::MaybeUninit<OGRField__bindgen_ty_3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OGRField__bindgen_ty_3>(),
        16usize,
        concat!("Size of: ", stringify!(OGRField__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<OGRField__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(OGRField__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_3),
            "::",
            stringify!(nCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).paList) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_3),
            "::",
            stringify!(paList)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OGRField__bindgen_ty_4 {
    pub nCount: libc::c_int,
    pub paList: *mut *mut libc::c_char,
}
#[test]
fn bindgen_test_layout_OGRField__bindgen_ty_4() {
    const UNINIT: ::std::mem::MaybeUninit<OGRField__bindgen_ty_4> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OGRField__bindgen_ty_4>(),
        16usize,
        concat!("Size of: ", stringify!(OGRField__bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<OGRField__bindgen_ty_4>(),
        8usize,
        concat!("Alignment of ", stringify!(OGRField__bindgen_ty_4))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_4),
            "::",
            stringify!(nCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).paList) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_4),
            "::",
            stringify!(paList)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OGRField__bindgen_ty_5 {
    pub nCount: libc::c_int,
    pub paData: *mut GByte,
}
#[test]
fn bindgen_test_layout_OGRField__bindgen_ty_5() {
    const UNINIT: ::std::mem::MaybeUninit<OGRField__bindgen_ty_5> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OGRField__bindgen_ty_5>(),
        16usize,
        concat!("Size of: ", stringify!(OGRField__bindgen_ty_5))
    );
    assert_eq!(
        ::std::mem::align_of::<OGRField__bindgen_ty_5>(),
        8usize,
        concat!("Alignment of ", stringify!(OGRField__bindgen_ty_5))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_5),
            "::",
            stringify!(nCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).paData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_5),
            "::",
            stringify!(paData)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OGRField__bindgen_ty_6 {
    pub nMarker1: libc::c_int,
    pub nMarker2: libc::c_int,
    pub nMarker3: libc::c_int,
}
#[test]
fn bindgen_test_layout_OGRField__bindgen_ty_6() {
    const UNINIT: ::std::mem::MaybeUninit<OGRField__bindgen_ty_6> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OGRField__bindgen_ty_6>(),
        12usize,
        concat!("Size of: ", stringify!(OGRField__bindgen_ty_6))
    );
    assert_eq!(
        ::std::mem::align_of::<OGRField__bindgen_ty_6>(),
        4usize,
        concat!("Alignment of ", stringify!(OGRField__bindgen_ty_6))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nMarker1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_6),
            "::",
            stringify!(nMarker1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nMarker2) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_6),
            "::",
            stringify!(nMarker2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nMarker3) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_6),
            "::",
            stringify!(nMarker3)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OGRField__bindgen_ty_7 {
    pub Year: GInt16,
    pub Month: GByte,
    pub Day: GByte,
    pub Hour: GByte,
    pub Minute: GByte,
    pub TZFlag: GByte,
    pub Reserved: GByte,
    pub Second: f32,
}
#[test]
fn bindgen_test_layout_OGRField__bindgen_ty_7() {
    const UNINIT: ::std::mem::MaybeUninit<OGRField__bindgen_ty_7> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OGRField__bindgen_ty_7>(),
        12usize,
        concat!("Size of: ", stringify!(OGRField__bindgen_ty_7))
    );
    assert_eq!(
        ::std::mem::align_of::<OGRField__bindgen_ty_7>(),
        4usize,
        concat!("Alignment of ", stringify!(OGRField__bindgen_ty_7))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Year) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_7),
            "::",
            stringify!(Year)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Month) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_7),
            "::",
            stringify!(Month)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Day) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_7),
            "::",
            stringify!(Day)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Hour) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_7),
            "::",
            stringify!(Hour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Minute) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_7),
            "::",
            stringify!(Minute)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TZFlag) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_7),
            "::",
            stringify!(TZFlag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_7),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Second) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_7),
            "::",
            stringify!(Second)
        )
    );
}
#[test]
fn bindgen_test_layout_OGRField() {
    const UNINIT: ::std::mem::MaybeUninit<OGRField> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OGRField>(),
        16usize,
        concat!("Size of: ", stringify!(OGRField))
    );
    assert_eq!(
        ::std::mem::align_of::<OGRField>(),
        8usize,
        concat!("Alignment of ", stringify!(OGRField))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Integer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField),
            "::",
            stringify!(Integer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Integer64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField),
            "::",
            stringify!(Integer64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Real) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField),
            "::",
            stringify!(Real)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).String) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField),
            "::",
            stringify!(String)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IntegerList) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField),
            "::",
            stringify!(IntegerList)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Integer64List) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField),
            "::",
            stringify!(Integer64List)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RealList) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField),
            "::",
            stringify!(RealList)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StringList) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField),
            "::",
            stringify!(StringList)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Binary) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField),
            "::",
            stringify!(Binary)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Set) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField),
            "::",
            stringify!(Set)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Date) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField),
            "::",
            stringify!(Date)
        )
    );
}
extern "C" {
    pub fn OGRParseDate(
        pszInput: *const libc::c_char,
        psOutput: *mut OGRField,
        nOptions: libc::c_int,
    ) -> libc::c_int;
}
pub mod ogr_style_tool_class_id {
    #[doc = " OGRStyleTool derived class types (returned by GetType())."]
    pub type Type = libc::c_uint;
    #[doc = "< None"]
    pub const OGRSTCNone: Type = 0;
    #[doc = "< Pen"]
    pub const OGRSTCPen: Type = 1;
    #[doc = "< Brush"]
    pub const OGRSTCBrush: Type = 2;
    #[doc = "< Symbol"]
    pub const OGRSTCSymbol: Type = 3;
    #[doc = "< Label"]
    pub const OGRSTCLabel: Type = 4;
    #[doc = "< Vector"]
    pub const OGRSTCVector: Type = 5;
}
#[doc = " OGRStyleTool derived class types (returned by GetType())."]
pub use self::ogr_style_tool_class_id::Type as OGRSTClassId;
pub mod ogr_style_tool_units_id {
    #[doc = " List of units supported by OGRStyleTools."]
    pub type Type = libc::c_uint;
    #[doc = "< Ground unit"]
    pub const OGRSTUGround: Type = 0;
    #[doc = "< Pixel"]
    pub const OGRSTUPixel: Type = 1;
    #[doc = "< Points"]
    pub const OGRSTUPoints: Type = 2;
    #[doc = "< Millimeter"]
    pub const OGRSTUMM: Type = 3;
    #[doc = "< Centimeter"]
    pub const OGRSTUCM: Type = 4;
    #[doc = "< Inch"]
    pub const OGRSTUInches: Type = 5;
}
#[doc = " List of units supported by OGRStyleTools."]
pub use self::ogr_style_tool_units_id::Type as OGRSTUnitId;
#[doc = " Associates a code and a value\n\n @since GDAL 3.3"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OGRCodedValue {
    #[doc = " Code. Content should be of the type of the OGRFieldDomain"]
    pub pszCode: *mut libc::c_char,
    #[doc = " Value. Might be NULL"]
    pub pszValue: *mut libc::c_char,
}
#[test]
fn bindgen_test_layout_OGRCodedValue() {
    const UNINIT: ::std::mem::MaybeUninit<OGRCodedValue> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OGRCodedValue>(),
        16usize,
        concat!("Size of: ", stringify!(OGRCodedValue))
    );
    assert_eq!(
        ::std::mem::align_of::<OGRCodedValue>(),
        8usize,
        concat!("Alignment of ", stringify!(OGRCodedValue))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pszCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRCodedValue),
            "::",
            stringify!(pszCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pszValue) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRCodedValue),
            "::",
            stringify!(pszValue)
        )
    );
}
pub mod OGRFieldDomainType {
    #[doc = " Type of field domain.\n\n @since GDAL 3.3"]
    pub type Type = libc::c_uint;
    #[doc = " Coded"]
    pub const OFDT_CODED: Type = 0;
    #[doc = " Range (min/max)"]
    pub const OFDT_RANGE: Type = 1;
    #[doc = " Glob (used by GeoPackage)"]
    pub const OFDT_GLOB: Type = 2;
}
pub mod OGRFieldDomainSplitPolicy {
    #[doc = " Split policy for field domains.\n\n When a feature is split in two, defines how the value of attributes\n following the domain are computed.\n\n @since GDAL 3.3"]
    pub type Type = libc::c_uint;
    #[doc = " Default value"]
    pub const OFDSP_DEFAULT_VALUE: Type = 0;
    #[doc = " Duplicate"]
    pub const OFDSP_DUPLICATE: Type = 1;
    #[doc = " New values are computed by the ratio of their area/length compared to the area/length of the original feature"]
    pub const OFDSP_GEOMETRY_RATIO: Type = 2;
}
pub mod OGRFieldDomainMergePolicy {
    #[doc = " Merge policy for field domains.\n\n When a feature is built by merging two features, defines how the value of\n attributes following the domain are computed.\n\n @since GDAL 3.3"]
    pub type Type = libc::c_uint;
    #[doc = " Default value"]
    pub const OFDMP_DEFAULT_VALUE: Type = 0;
    #[doc = " Sum"]
    pub const OFDMP_SUM: Type = 1;
    #[doc = " New values are computed as the weighted average of the source values."]
    pub const OFDMP_GEOMETRY_WEIGHTED: Type = 2;
}
extern "C" {
    pub fn GDALVersionInfo(arg1: *const libc::c_char) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Return TRUE if GDAL library version at runtime matches nVersionMajor.nVersionMinor.\n\nThe purpose of this method is to ensure that calling code will run with the GDAL\nversion it is compiled for. It is primarily indented for external plugins.\n\n@param nVersionMajor Major version to be tested against\n@param nVersionMinor Minor version to be tested against\n@param pszCallingComponentName If not NULL, in case of version mismatch, the method\nwill issue a failure mentioning the name of\nthe calling component."]
    pub fn GDALCheckVersion(
        nVersionMajor: libc::c_int,
        nVersionMinor: libc::c_int,
        pszCallingComponentName: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OGRGetGEOSVersion(
        pnMajor: *mut libc::c_int,
        pnMinor: *mut libc::c_int,
        pnPatch: *mut libc::c_int,
    ) -> bool;
}
#[doc = " Opaque type for a geometry"]
pub type OGRGeometryH = *mut libc::c_void;
#[doc = " Opaque type for a spatial reference system"]
pub type OGRSpatialReferenceH = *mut libc::c_void;
#[doc = " Opaque type for a coordinate transformation object"]
pub type OGRCoordinateTransformationH = *mut libc::c_void;
extern "C" {
    pub fn OGR_G_CreateFromWkb(
        arg1: *const libc::c_void,
        arg2: OGRSpatialReferenceH,
        arg3: *mut OGRGeometryH,
        arg4: libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_G_CreateFromWkbEx(
        arg1: *const libc::c_void,
        arg2: OGRSpatialReferenceH,
        arg3: *mut OGRGeometryH,
        arg4: usize,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_G_CreateFromWkt(
        arg1: *mut *mut libc::c_char,
        arg2: OGRSpatialReferenceH,
        arg3: *mut OGRGeometryH,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_G_CreateFromFgf(
        arg1: *const libc::c_void,
        arg2: OGRSpatialReferenceH,
        arg3: *mut OGRGeometryH,
        arg4: libc::c_int,
        arg5: *mut libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_G_DestroyGeometry(arg1: OGRGeometryH);
}
extern "C" {
    pub fn OGR_G_CreateGeometry(arg1: OGRwkbGeometryType::Type) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_ApproximateArcAngles(
        dfCenterX: f64,
        dfCenterY: f64,
        dfZ: f64,
        dfPrimaryRadius: f64,
        dfSecondaryAxis: f64,
        dfRotation: f64,
        dfStartAngle: f64,
        dfEndAngle: f64,
        dfMaxAngleStepSizeDegrees: f64,
    ) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_ForceToPolygon(arg1: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_ForceToLineString(arg1: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_ForceToMultiPolygon(arg1: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_ForceToMultiPoint(arg1: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_ForceToMultiLineString(arg1: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_ForceTo(
        hGeom: OGRGeometryH,
        eTargetType: OGRwkbGeometryType::Type,
        papszOptions: *mut *mut libc::c_char,
    ) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_RemoveLowerDimensionSubGeoms(hGeom: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_GetDimension(arg1: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_GetCoordinateDimension(arg1: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_CoordinateDimension(arg1: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_SetCoordinateDimension(arg1: OGRGeometryH, arg2: libc::c_int);
}
extern "C" {
    pub fn OGR_G_Is3D(arg1: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_IsMeasured(arg1: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_Set3D(arg1: OGRGeometryH, arg2: libc::c_int);
}
extern "C" {
    pub fn OGR_G_SetMeasured(arg1: OGRGeometryH, arg2: libc::c_int);
}
extern "C" {
    pub fn OGR_G_Clone(arg1: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_GetEnvelope(arg1: OGRGeometryH, arg2: *mut OGREnvelope);
}
extern "C" {
    pub fn OGR_G_GetEnvelope3D(arg1: OGRGeometryH, arg2: *mut OGREnvelope3D);
}
extern "C" {
    pub fn OGR_G_ImportFromWkb(
        arg1: OGRGeometryH,
        arg2: *const libc::c_void,
        arg3: libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_G_ExportToWkb(
        arg1: OGRGeometryH,
        arg2: OGRwkbByteOrder::Type,
        arg3: *mut libc::c_uchar,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_G_ExportToIsoWkb(
        arg1: OGRGeometryH,
        arg2: OGRwkbByteOrder::Type,
        arg3: *mut libc::c_uchar,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_G_WkbSize(hGeom: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_WkbSizeEx(hGeom: OGRGeometryH) -> usize;
}
extern "C" {
    pub fn OGR_G_ImportFromWkt(arg1: OGRGeometryH, arg2: *mut *mut libc::c_char) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_G_ExportToWkt(arg1: OGRGeometryH, arg2: *mut *mut libc::c_char) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_G_ExportToIsoWkt(arg1: OGRGeometryH, arg2: *mut *mut libc::c_char) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_G_GetGeometryType(arg1: OGRGeometryH) -> OGRwkbGeometryType::Type;
}
extern "C" {
    pub fn OGR_G_GetGeometryName(arg1: OGRGeometryH) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_G_DumpReadable(arg1: OGRGeometryH, arg2: *mut FILE, arg3: *const libc::c_char);
}
extern "C" {
    pub fn OGR_G_FlattenTo2D(arg1: OGRGeometryH);
}
extern "C" {
    pub fn OGR_G_CloseRings(arg1: OGRGeometryH);
}
extern "C" {
    pub fn OGR_G_CreateFromGML(arg1: *const libc::c_char) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_ExportToGML(arg1: OGRGeometryH) -> *mut libc::c_char;
}
extern "C" {
    pub fn OGR_G_ExportToGMLEx(
        arg1: OGRGeometryH,
        papszOptions: *mut *mut libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn OGR_G_CreateFromGMLTree(arg1: *const CPLXMLNode) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_ExportToGMLTree(arg1: OGRGeometryH) -> *mut CPLXMLNode;
}
extern "C" {
    pub fn OGR_G_ExportEnvelopeToGMLTree(arg1: OGRGeometryH) -> *mut CPLXMLNode;
}
extern "C" {
    pub fn OGR_G_ExportToKML(
        arg1: OGRGeometryH,
        pszAltitudeMode: *const libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn OGR_G_ExportToJson(arg1: OGRGeometryH) -> *mut libc::c_char;
}
extern "C" {
    pub fn OGR_G_ExportToJsonEx(
        arg1: OGRGeometryH,
        papszOptions: *mut *mut libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Create a OGR geometry from a GeoJSON geometry object"]
    pub fn OGR_G_CreateGeometryFromJson(arg1: *const libc::c_char) -> OGRGeometryH;
}
extern "C" {
    #[doc = " Create a OGR geometry from a ESRI JSON geometry object"]
    pub fn OGR_G_CreateGeometryFromEsriJson(arg1: *const libc::c_char) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_AssignSpatialReference(arg1: OGRGeometryH, arg2: OGRSpatialReferenceH);
}
extern "C" {
    pub fn OGR_G_GetSpatialReference(arg1: OGRGeometryH) -> OGRSpatialReferenceH;
}
extern "C" {
    pub fn OGR_G_Transform(arg1: OGRGeometryH, arg2: OGRCoordinateTransformationH) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_G_TransformTo(arg1: OGRGeometryH, arg2: OGRSpatialReferenceH) -> OGRErr::Type;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OGRGeomTransformer {
    _unused: [u8; 0],
}
#[doc = " Opaque type for a geometry transformer."]
pub type OGRGeomTransformerH = *mut OGRGeomTransformer;
extern "C" {
    pub fn OGR_GeomTransformer_Create(
        arg1: OGRCoordinateTransformationH,
        papszOptions: CSLConstList,
    ) -> OGRGeomTransformerH;
}
extern "C" {
    pub fn OGR_GeomTransformer_Transform(
        hTransformer: OGRGeomTransformerH,
        hGeom: OGRGeometryH,
    ) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_GeomTransformer_Destroy(hTransformer: OGRGeomTransformerH);
}
extern "C" {
    pub fn OGR_G_Simplify(hThis: OGRGeometryH, tolerance: f64) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_SimplifyPreserveTopology(hThis: OGRGeometryH, tolerance: f64) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_DelaunayTriangulation(
        hThis: OGRGeometryH,
        dfTolerance: f64,
        bOnlyEdges: libc::c_int,
    ) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_Segmentize(hGeom: OGRGeometryH, dfMaxLength: f64);
}
extern "C" {
    pub fn OGR_G_Intersects(arg1: OGRGeometryH, arg2: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_Equals(arg1: OGRGeometryH, arg2: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_Disjoint(arg1: OGRGeometryH, arg2: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_Touches(arg1: OGRGeometryH, arg2: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_Crosses(arg1: OGRGeometryH, arg2: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_Within(arg1: OGRGeometryH, arg2: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_Contains(arg1: OGRGeometryH, arg2: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_Overlaps(arg1: OGRGeometryH, arg2: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_Boundary(arg1: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_ConvexHull(arg1: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_ConcaveHull(arg1: OGRGeometryH, dfRatio: f64, bAllowHoles: bool) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_Buffer(arg1: OGRGeometryH, arg2: f64, arg3: libc::c_int) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_Intersection(arg1: OGRGeometryH, arg2: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_Union(arg1: OGRGeometryH, arg2: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_UnionCascaded(arg1: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_PointOnSurface(arg1: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_Difference(arg1: OGRGeometryH, arg2: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_SymDifference(arg1: OGRGeometryH, arg2: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_Distance(arg1: OGRGeometryH, arg2: OGRGeometryH) -> f64;
}
extern "C" {
    pub fn OGR_G_Distance3D(arg1: OGRGeometryH, arg2: OGRGeometryH) -> f64;
}
extern "C" {
    pub fn OGR_G_Length(arg1: OGRGeometryH) -> f64;
}
extern "C" {
    pub fn OGR_G_Area(arg1: OGRGeometryH) -> f64;
}
extern "C" {
    pub fn OGR_G_Centroid(arg1: OGRGeometryH, arg2: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_Value(arg1: OGRGeometryH, dfDistance: f64) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_Empty(arg1: OGRGeometryH);
}
extern "C" {
    pub fn OGR_G_IsEmpty(arg1: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_IsValid(arg1: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_MakeValid(arg1: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_MakeValidEx(arg1: OGRGeometryH, arg2: CSLConstList) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_Normalize(arg1: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_IsSimple(arg1: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_IsRing(arg1: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_Polygonize(arg1: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    #[doc = " @cond Doxygen_Suppress"]
    pub fn OGR_G_Intersect(arg1: OGRGeometryH, arg2: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_Equal(arg1: OGRGeometryH, arg2: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_SymmetricDifference(arg1: OGRGeometryH, arg2: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_GetArea(arg1: OGRGeometryH) -> f64;
}
extern "C" {
    pub fn OGR_G_GetBoundary(arg1: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    #[doc = " @endcond"]
    pub fn OGR_G_GetPointCount(arg1: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_GetPoints(
        hGeom: OGRGeometryH,
        pabyX: *mut libc::c_void,
        nXStride: libc::c_int,
        pabyY: *mut libc::c_void,
        nYStride: libc::c_int,
        pabyZ: *mut libc::c_void,
        nZStride: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_GetPointsZM(
        hGeom: OGRGeometryH,
        pabyX: *mut libc::c_void,
        nXStride: libc::c_int,
        pabyY: *mut libc::c_void,
        nYStride: libc::c_int,
        pabyZ: *mut libc::c_void,
        nZStride: libc::c_int,
        pabyM: *mut libc::c_void,
        nMStride: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_GetX(arg1: OGRGeometryH, arg2: libc::c_int) -> f64;
}
extern "C" {
    pub fn OGR_G_GetY(arg1: OGRGeometryH, arg2: libc::c_int) -> f64;
}
extern "C" {
    pub fn OGR_G_GetZ(arg1: OGRGeometryH, arg2: libc::c_int) -> f64;
}
extern "C" {
    pub fn OGR_G_GetM(arg1: OGRGeometryH, arg2: libc::c_int) -> f64;
}
extern "C" {
    pub fn OGR_G_GetPoint(
        arg1: OGRGeometryH,
        iPoint: libc::c_int,
        arg2: *mut f64,
        arg3: *mut f64,
        arg4: *mut f64,
    );
}
extern "C" {
    pub fn OGR_G_GetPointZM(
        arg1: OGRGeometryH,
        iPoint: libc::c_int,
        arg2: *mut f64,
        arg3: *mut f64,
        arg4: *mut f64,
        arg5: *mut f64,
    );
}
extern "C" {
    pub fn OGR_G_SetPointCount(hGeom: OGRGeometryH, nNewPointCount: libc::c_int);
}
extern "C" {
    pub fn OGR_G_SetPoint(arg1: OGRGeometryH, iPoint: libc::c_int, arg2: f64, arg3: f64, arg4: f64);
}
extern "C" {
    pub fn OGR_G_SetPoint_2D(arg1: OGRGeometryH, iPoint: libc::c_int, arg2: f64, arg3: f64);
}
extern "C" {
    pub fn OGR_G_SetPointM(
        arg1: OGRGeometryH,
        iPoint: libc::c_int,
        arg2: f64,
        arg3: f64,
        arg4: f64,
    );
}
extern "C" {
    pub fn OGR_G_SetPointZM(
        arg1: OGRGeometryH,
        iPoint: libc::c_int,
        arg2: f64,
        arg3: f64,
        arg4: f64,
        arg5: f64,
    );
}
extern "C" {
    pub fn OGR_G_AddPoint(arg1: OGRGeometryH, arg2: f64, arg3: f64, arg4: f64);
}
extern "C" {
    pub fn OGR_G_AddPoint_2D(arg1: OGRGeometryH, arg2: f64, arg3: f64);
}
extern "C" {
    pub fn OGR_G_AddPointM(arg1: OGRGeometryH, arg2: f64, arg3: f64, arg4: f64);
}
extern "C" {
    pub fn OGR_G_AddPointZM(arg1: OGRGeometryH, arg2: f64, arg3: f64, arg4: f64, arg5: f64);
}
extern "C" {
    pub fn OGR_G_SetPoints(
        hGeom: OGRGeometryH,
        nPointsIn: libc::c_int,
        pabyX: *const libc::c_void,
        nXStride: libc::c_int,
        pabyY: *const libc::c_void,
        nYStride: libc::c_int,
        pabyZ: *const libc::c_void,
        nZStride: libc::c_int,
    );
}
extern "C" {
    pub fn OGR_G_SetPointsZM(
        hGeom: OGRGeometryH,
        nPointsIn: libc::c_int,
        pabyX: *const libc::c_void,
        nXStride: libc::c_int,
        pabyY: *const libc::c_void,
        nYStride: libc::c_int,
        pabyZ: *const libc::c_void,
        nZStride: libc::c_int,
        pabyM: *const libc::c_void,
        nMStride: libc::c_int,
    );
}
extern "C" {
    pub fn OGR_G_SwapXY(hGeom: OGRGeometryH);
}
extern "C" {
    pub fn OGR_G_GetGeometryCount(arg1: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_GetGeometryRef(arg1: OGRGeometryH, arg2: libc::c_int) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_AddGeometry(arg1: OGRGeometryH, arg2: OGRGeometryH) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_G_AddGeometryDirectly(arg1: OGRGeometryH, arg2: OGRGeometryH) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_G_RemoveGeometry(
        arg1: OGRGeometryH,
        arg2: libc::c_int,
        arg3: libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_G_HasCurveGeometry(
        arg1: OGRGeometryH,
        bLookForNonLinear: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_GetLinearGeometry(
        hGeom: OGRGeometryH,
        dfMaxAngleStepSizeDegrees: f64,
        papszOptions: *mut *mut libc::c_char,
    ) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_GetCurveGeometry(
        hGeom: OGRGeometryH,
        papszOptions: *mut *mut libc::c_char,
    ) -> OGRGeometryH;
}
extern "C" {
    pub fn OGRBuildPolygonFromEdges(
        hLinesAsCollection: OGRGeometryH,
        bBestEffort: libc::c_int,
        bAutoClose: libc::c_int,
        dfTolerance: f64,
        peErr: *mut OGRErr::Type,
    ) -> OGRGeometryH;
}
extern "C" {
    #[doc = " @cond Doxygen_Suppress"]
    pub fn OGRSetGenerate_DB2_V72_BYTE_ORDER(
        bGenerate_DB2_V72_BYTE_ORDER: libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGRGetGenerate_DB2_V72_BYTE_ORDER() -> libc::c_int;
}
extern "C" {
    #[doc = " @endcond"]
    pub fn OGRSetNonLinearGeometriesEnabledFlag(bFlag: libc::c_int);
}
extern "C" {
    pub fn OGRGetNonLinearGeometriesEnabledFlag() -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OGRPreparedGeometry {
    _unused: [u8; 0],
}
#[doc = " Opaque type for a prepared geometry"]
pub type OGRPreparedGeometryH = *mut _OGRPreparedGeometry;
extern "C" {
    pub fn OGRHasPreparedGeometrySupport() -> libc::c_int;
}
extern "C" {
    pub fn OGRCreatePreparedGeometry(hGeom: OGRGeometryH) -> OGRPreparedGeometryH;
}
extern "C" {
    pub fn OGRDestroyPreparedGeometry(hPreparedGeom: OGRPreparedGeometryH);
}
extern "C" {
    pub fn OGRPreparedGeometryIntersects(
        hPreparedGeom: OGRPreparedGeometryH,
        hOtherGeom: OGRGeometryH,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OGRPreparedGeometryContains(
        hPreparedGeom: OGRPreparedGeometryH,
        hOtherGeom: OGRGeometryH,
    ) -> libc::c_int;
}
#[doc = " Opaque type for a field definition (OGRFieldDefn)"]
pub type OGRFieldDefnH = *mut libc::c_void;
#[doc = " Opaque type for a feature definition (OGRFeatureDefn)"]
pub type OGRFeatureDefnH = *mut libc::c_void;
#[doc = " Opaque type for a feature (OGRFeature)"]
pub type OGRFeatureH = *mut libc::c_void;
#[doc = " Opaque type for a style table (OGRStyleTable)"]
pub type OGRStyleTableH = *mut libc::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OGRGeomFieldDefnHS {
    _unused: [u8; 0],
}
#[doc = " Opaque type for a geometry field definition (OGRGeomFieldDefn)"]
pub type OGRGeomFieldDefnH = *mut OGRGeomFieldDefnHS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OGRFieldDomainHS {
    _unused: [u8; 0],
}
#[doc = " Opaque type for a field domain definition (OGRFieldDomain)"]
pub type OGRFieldDomainH = *mut OGRFieldDomainHS;
extern "C" {
    pub fn OGR_Fld_Create(arg1: *const libc::c_char, arg2: OGRFieldType::Type) -> OGRFieldDefnH;
}
extern "C" {
    pub fn OGR_Fld_Destroy(arg1: OGRFieldDefnH);
}
extern "C" {
    pub fn OGR_Fld_SetName(arg1: OGRFieldDefnH, arg2: *const libc::c_char);
}
extern "C" {
    pub fn OGR_Fld_GetNameRef(arg1: OGRFieldDefnH) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_Fld_SetAlternativeName(arg1: OGRFieldDefnH, arg2: *const libc::c_char);
}
extern "C" {
    pub fn OGR_Fld_GetAlternativeNameRef(arg1: OGRFieldDefnH) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_Fld_GetType(arg1: OGRFieldDefnH) -> OGRFieldType::Type;
}
extern "C" {
    pub fn OGR_Fld_SetType(arg1: OGRFieldDefnH, arg2: OGRFieldType::Type);
}
extern "C" {
    pub fn OGR_Fld_GetSubType(arg1: OGRFieldDefnH) -> OGRFieldSubType::Type;
}
extern "C" {
    pub fn OGR_Fld_SetSubType(arg1: OGRFieldDefnH, arg2: OGRFieldSubType::Type);
}
extern "C" {
    pub fn OGR_Fld_GetJustify(arg1: OGRFieldDefnH) -> OGRJustification::Type;
}
extern "C" {
    pub fn OGR_Fld_SetJustify(arg1: OGRFieldDefnH, arg2: OGRJustification::Type);
}
extern "C" {
    pub fn OGR_Fld_GetWidth(arg1: OGRFieldDefnH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_Fld_SetWidth(arg1: OGRFieldDefnH, arg2: libc::c_int);
}
extern "C" {
    pub fn OGR_Fld_GetPrecision(arg1: OGRFieldDefnH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_Fld_SetPrecision(arg1: OGRFieldDefnH, arg2: libc::c_int);
}
extern "C" {
    pub fn OGR_Fld_Set(
        arg1: OGRFieldDefnH,
        arg2: *const libc::c_char,
        arg3: OGRFieldType::Type,
        arg4: libc::c_int,
        arg5: libc::c_int,
        arg6: OGRJustification::Type,
    );
}
extern "C" {
    pub fn OGR_Fld_IsIgnored(hDefn: OGRFieldDefnH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_Fld_SetIgnored(hDefn: OGRFieldDefnH, arg1: libc::c_int);
}
extern "C" {
    pub fn OGR_Fld_IsNullable(hDefn: OGRFieldDefnH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_Fld_SetNullable(hDefn: OGRFieldDefnH, arg1: libc::c_int);
}
extern "C" {
    pub fn OGR_Fld_IsUnique(hDefn: OGRFieldDefnH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_Fld_SetUnique(hDefn: OGRFieldDefnH, arg1: libc::c_int);
}
extern "C" {
    pub fn OGR_Fld_GetDefault(hDefn: OGRFieldDefnH) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_Fld_SetDefault(hDefn: OGRFieldDefnH, arg1: *const libc::c_char);
}
extern "C" {
    pub fn OGR_Fld_IsDefaultDriverSpecific(hDefn: OGRFieldDefnH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_Fld_GetDomainName(hDefn: OGRFieldDefnH) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_Fld_SetDomainName(hDefn: OGRFieldDefnH, arg1: *const libc::c_char);
}
extern "C" {
    pub fn OGR_GetFieldTypeName(arg1: OGRFieldType::Type) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_GetFieldSubTypeName(arg1: OGRFieldSubType::Type) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_AreTypeSubTypeCompatible(
        eType: OGRFieldType::Type,
        eSubType: OGRFieldSubType::Type,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OGR_GFld_Create(
        arg1: *const libc::c_char,
        arg2: OGRwkbGeometryType::Type,
    ) -> OGRGeomFieldDefnH;
}
extern "C" {
    pub fn OGR_GFld_Destroy(arg1: OGRGeomFieldDefnH);
}
extern "C" {
    pub fn OGR_GFld_SetName(arg1: OGRGeomFieldDefnH, arg2: *const libc::c_char);
}
extern "C" {
    pub fn OGR_GFld_GetNameRef(arg1: OGRGeomFieldDefnH) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_GFld_GetType(arg1: OGRGeomFieldDefnH) -> OGRwkbGeometryType::Type;
}
extern "C" {
    pub fn OGR_GFld_SetType(arg1: OGRGeomFieldDefnH, arg2: OGRwkbGeometryType::Type);
}
extern "C" {
    pub fn OGR_GFld_GetSpatialRef(arg1: OGRGeomFieldDefnH) -> OGRSpatialReferenceH;
}
extern "C" {
    pub fn OGR_GFld_SetSpatialRef(arg1: OGRGeomFieldDefnH, hSRS: OGRSpatialReferenceH);
}
extern "C" {
    pub fn OGR_GFld_IsNullable(hDefn: OGRGeomFieldDefnH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_GFld_SetNullable(hDefn: OGRGeomFieldDefnH, arg1: libc::c_int);
}
extern "C" {
    pub fn OGR_GFld_IsIgnored(hDefn: OGRGeomFieldDefnH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_GFld_SetIgnored(hDefn: OGRGeomFieldDefnH, arg1: libc::c_int);
}
extern "C" {
    pub fn OGR_FD_Create(arg1: *const libc::c_char) -> OGRFeatureDefnH;
}
extern "C" {
    pub fn OGR_FD_Destroy(arg1: OGRFeatureDefnH);
}
extern "C" {
    pub fn OGR_FD_Release(arg1: OGRFeatureDefnH);
}
extern "C" {
    pub fn OGR_FD_GetName(arg1: OGRFeatureDefnH) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_FD_GetFieldCount(arg1: OGRFeatureDefnH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_FD_GetFieldDefn(arg1: OGRFeatureDefnH, arg2: libc::c_int) -> OGRFieldDefnH;
}
extern "C" {
    pub fn OGR_FD_GetFieldIndex(arg1: OGRFeatureDefnH, arg2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn OGR_FD_AddFieldDefn(arg1: OGRFeatureDefnH, arg2: OGRFieldDefnH);
}
extern "C" {
    pub fn OGR_FD_DeleteFieldDefn(hDefn: OGRFeatureDefnH, iField: libc::c_int) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_FD_ReorderFieldDefns(
        hDefn: OGRFeatureDefnH,
        panMap: *const libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_FD_GetGeomType(arg1: OGRFeatureDefnH) -> OGRwkbGeometryType::Type;
}
extern "C" {
    pub fn OGR_FD_SetGeomType(arg1: OGRFeatureDefnH, arg2: OGRwkbGeometryType::Type);
}
extern "C" {
    pub fn OGR_FD_IsGeometryIgnored(arg1: OGRFeatureDefnH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_FD_SetGeometryIgnored(arg1: OGRFeatureDefnH, arg2: libc::c_int);
}
extern "C" {
    pub fn OGR_FD_IsStyleIgnored(arg1: OGRFeatureDefnH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_FD_SetStyleIgnored(arg1: OGRFeatureDefnH, arg2: libc::c_int);
}
extern "C" {
    pub fn OGR_FD_Reference(arg1: OGRFeatureDefnH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_FD_Dereference(arg1: OGRFeatureDefnH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_FD_GetReferenceCount(arg1: OGRFeatureDefnH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_FD_GetGeomFieldCount(hFDefn: OGRFeatureDefnH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_FD_GetGeomFieldDefn(hFDefn: OGRFeatureDefnH, i: libc::c_int) -> OGRGeomFieldDefnH;
}
extern "C" {
    pub fn OGR_FD_GetGeomFieldIndex(
        hFDefn: OGRFeatureDefnH,
        pszName: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OGR_FD_AddGeomFieldDefn(hFDefn: OGRFeatureDefnH, hGFldDefn: OGRGeomFieldDefnH);
}
extern "C" {
    pub fn OGR_FD_DeleteGeomFieldDefn(
        hFDefn: OGRFeatureDefnH,
        iGeomField: libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_FD_IsSame(hFDefn: OGRFeatureDefnH, hOtherFDefn: OGRFeatureDefnH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_F_Create(arg1: OGRFeatureDefnH) -> OGRFeatureH;
}
extern "C" {
    pub fn OGR_F_Destroy(arg1: OGRFeatureH);
}
extern "C" {
    pub fn OGR_F_GetDefnRef(arg1: OGRFeatureH) -> OGRFeatureDefnH;
}
extern "C" {
    pub fn OGR_F_SetGeometryDirectly(arg1: OGRFeatureH, arg2: OGRGeometryH) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_F_SetGeometry(arg1: OGRFeatureH, arg2: OGRGeometryH) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_F_GetGeometryRef(arg1: OGRFeatureH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_F_StealGeometry(arg1: OGRFeatureH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_F_StealGeometryEx(arg1: OGRFeatureH, iGeomField: libc::c_int) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_F_Clone(arg1: OGRFeatureH) -> OGRFeatureH;
}
extern "C" {
    pub fn OGR_F_Equal(arg1: OGRFeatureH, arg2: OGRFeatureH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_F_GetFieldCount(arg1: OGRFeatureH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_F_GetFieldDefnRef(arg1: OGRFeatureH, arg2: libc::c_int) -> OGRFieldDefnH;
}
extern "C" {
    pub fn OGR_F_GetFieldIndex(arg1: OGRFeatureH, arg2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn OGR_F_IsFieldSet(arg1: OGRFeatureH, arg2: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn OGR_F_UnsetField(arg1: OGRFeatureH, arg2: libc::c_int);
}
extern "C" {
    pub fn OGR_F_IsFieldNull(arg1: OGRFeatureH, arg2: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn OGR_F_IsFieldSetAndNotNull(arg1: OGRFeatureH, arg2: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn OGR_F_SetFieldNull(arg1: OGRFeatureH, arg2: libc::c_int);
}
extern "C" {
    pub fn OGR_F_GetRawFieldRef(arg1: OGRFeatureH, arg2: libc::c_int) -> *mut OGRField;
}
extern "C" {
    pub fn OGR_RawField_IsUnset(arg1: *const OGRField) -> libc::c_int;
}
extern "C" {
    pub fn OGR_RawField_IsNull(arg1: *const OGRField) -> libc::c_int;
}
extern "C" {
    pub fn OGR_RawField_SetUnset(arg1: *mut OGRField);
}
extern "C" {
    pub fn OGR_RawField_SetNull(arg1: *mut OGRField);
}
extern "C" {
    pub fn OGR_F_GetFieldAsInteger(arg1: OGRFeatureH, arg2: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn OGR_F_GetFieldAsInteger64(arg1: OGRFeatureH, arg2: libc::c_int) -> GIntBig;
}
extern "C" {
    pub fn OGR_F_GetFieldAsDouble(arg1: OGRFeatureH, arg2: libc::c_int) -> f64;
}
extern "C" {
    pub fn OGR_F_GetFieldAsString(arg1: OGRFeatureH, arg2: libc::c_int) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_F_GetFieldAsIntegerList(
        arg1: OGRFeatureH,
        arg2: libc::c_int,
        arg3: *mut libc::c_int,
    ) -> *const libc::c_int;
}
extern "C" {
    pub fn OGR_F_GetFieldAsInteger64List(
        arg1: OGRFeatureH,
        arg2: libc::c_int,
        arg3: *mut libc::c_int,
    ) -> *const GIntBig;
}
extern "C" {
    pub fn OGR_F_GetFieldAsDoubleList(
        arg1: OGRFeatureH,
        arg2: libc::c_int,
        arg3: *mut libc::c_int,
    ) -> *const f64;
}
extern "C" {
    pub fn OGR_F_GetFieldAsStringList(
        arg1: OGRFeatureH,
        arg2: libc::c_int,
    ) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn OGR_F_GetFieldAsBinary(
        arg1: OGRFeatureH,
        arg2: libc::c_int,
        arg3: *mut libc::c_int,
    ) -> *mut GByte;
}
extern "C" {
    pub fn OGR_F_GetFieldAsDateTime(
        arg1: OGRFeatureH,
        arg2: libc::c_int,
        arg3: *mut libc::c_int,
        arg4: *mut libc::c_int,
        arg5: *mut libc::c_int,
        arg6: *mut libc::c_int,
        arg7: *mut libc::c_int,
        arg8: *mut libc::c_int,
        arg9: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OGR_F_GetFieldAsDateTimeEx(
        hFeat: OGRFeatureH,
        iField: libc::c_int,
        pnYear: *mut libc::c_int,
        pnMonth: *mut libc::c_int,
        pnDay: *mut libc::c_int,
        pnHour: *mut libc::c_int,
        pnMinute: *mut libc::c_int,
        pfSecond: *mut f32,
        pnTZFlag: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OGR_F_SetFieldInteger(arg1: OGRFeatureH, arg2: libc::c_int, arg3: libc::c_int);
}
extern "C" {
    pub fn OGR_F_SetFieldInteger64(arg1: OGRFeatureH, arg2: libc::c_int, arg3: GIntBig);
}
extern "C" {
    pub fn OGR_F_SetFieldDouble(arg1: OGRFeatureH, arg2: libc::c_int, arg3: f64);
}
extern "C" {
    pub fn OGR_F_SetFieldString(arg1: OGRFeatureH, arg2: libc::c_int, arg3: *const libc::c_char);
}
extern "C" {
    pub fn OGR_F_SetFieldIntegerList(
        arg1: OGRFeatureH,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: *const libc::c_int,
    );
}
extern "C" {
    pub fn OGR_F_SetFieldInteger64List(
        arg1: OGRFeatureH,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: *const GIntBig,
    );
}
extern "C" {
    pub fn OGR_F_SetFieldDoubleList(
        arg1: OGRFeatureH,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: *const f64,
    );
}
extern "C" {
    pub fn OGR_F_SetFieldStringList(arg1: OGRFeatureH, arg2: libc::c_int, arg3: CSLConstList);
}
extern "C" {
    pub fn OGR_F_SetFieldRaw(arg1: OGRFeatureH, arg2: libc::c_int, arg3: *const OGRField);
}
extern "C" {
    pub fn OGR_F_SetFieldBinary(
        arg1: OGRFeatureH,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: *const libc::c_void,
    );
}
extern "C" {
    pub fn OGR_F_SetFieldDateTime(
        arg1: OGRFeatureH,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: libc::c_int,
        arg5: libc::c_int,
        arg6: libc::c_int,
        arg7: libc::c_int,
        arg8: libc::c_int,
        arg9: libc::c_int,
    );
}
extern "C" {
    pub fn OGR_F_SetFieldDateTimeEx(
        arg1: OGRFeatureH,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: libc::c_int,
        arg5: libc::c_int,
        arg6: libc::c_int,
        arg7: libc::c_int,
        arg8: f32,
        arg9: libc::c_int,
    );
}
extern "C" {
    pub fn OGR_F_GetGeomFieldCount(hFeat: OGRFeatureH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_F_GetGeomFieldDefnRef(hFeat: OGRFeatureH, iField: libc::c_int) -> OGRGeomFieldDefnH;
}
extern "C" {
    pub fn OGR_F_GetGeomFieldIndex(hFeat: OGRFeatureH, pszName: *const libc::c_char)
        -> libc::c_int;
}
extern "C" {
    pub fn OGR_F_GetGeomFieldRef(hFeat: OGRFeatureH, iField: libc::c_int) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_F_SetGeomFieldDirectly(
        hFeat: OGRFeatureH,
        iField: libc::c_int,
        hGeom: OGRGeometryH,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_F_SetGeomField(
        hFeat: OGRFeatureH,
        iField: libc::c_int,
        hGeom: OGRGeometryH,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_F_GetFID(arg1: OGRFeatureH) -> GIntBig;
}
extern "C" {
    pub fn OGR_F_SetFID(arg1: OGRFeatureH, arg2: GIntBig) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_F_DumpReadable(arg1: OGRFeatureH, arg2: *mut FILE);
}
extern "C" {
    pub fn OGR_F_SetFrom(arg1: OGRFeatureH, arg2: OGRFeatureH, arg3: libc::c_int) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_F_SetFromWithMap(
        arg1: OGRFeatureH,
        arg2: OGRFeatureH,
        arg3: libc::c_int,
        arg4: *const libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_F_GetStyleString(arg1: OGRFeatureH) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_F_SetStyleString(arg1: OGRFeatureH, arg2: *const libc::c_char);
}
extern "C" {
    pub fn OGR_F_SetStyleStringDirectly(arg1: OGRFeatureH, arg2: *mut libc::c_char);
}
extern "C" {
    #[doc = " Return style table"]
    pub fn OGR_F_GetStyleTable(arg1: OGRFeatureH) -> OGRStyleTableH;
}
extern "C" {
    #[doc = " Set style table and take ownership"]
    pub fn OGR_F_SetStyleTableDirectly(arg1: OGRFeatureH, arg2: OGRStyleTableH);
}
extern "C" {
    #[doc = " Set style table"]
    pub fn OGR_F_SetStyleTable(arg1: OGRFeatureH, arg2: OGRStyleTableH);
}
extern "C" {
    pub fn OGR_F_GetNativeData(arg1: OGRFeatureH) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_F_SetNativeData(arg1: OGRFeatureH, arg2: *const libc::c_char);
}
extern "C" {
    pub fn OGR_F_GetNativeMediaType(arg1: OGRFeatureH) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_F_SetNativeMediaType(arg1: OGRFeatureH, arg2: *const libc::c_char);
}
extern "C" {
    pub fn OGR_F_FillUnsetWithDefault(
        hFeat: OGRFeatureH,
        bNotNullableOnly: libc::c_int,
        papszOptions: *mut *mut libc::c_char,
    );
}
extern "C" {
    pub fn OGR_F_Validate(
        arg1: OGRFeatureH,
        nValidateFlags: libc::c_int,
        bEmitError: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OGR_FldDomain_Destroy(arg1: OGRFieldDomainH);
}
extern "C" {
    pub fn OGR_FldDomain_GetName(arg1: OGRFieldDomainH) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_FldDomain_GetDescription(arg1: OGRFieldDomainH) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_FldDomain_GetDomainType(arg1: OGRFieldDomainH) -> OGRFieldDomainType::Type;
}
extern "C" {
    pub fn OGR_FldDomain_GetFieldType(arg1: OGRFieldDomainH) -> OGRFieldType::Type;
}
extern "C" {
    pub fn OGR_FldDomain_GetFieldSubType(arg1: OGRFieldDomainH) -> OGRFieldSubType::Type;
}
extern "C" {
    pub fn OGR_FldDomain_GetSplitPolicy(arg1: OGRFieldDomainH) -> OGRFieldDomainSplitPolicy::Type;
}
extern "C" {
    pub fn OGR_FldDomain_SetSplitPolicy(
        arg1: OGRFieldDomainH,
        arg2: OGRFieldDomainSplitPolicy::Type,
    );
}
extern "C" {
    pub fn OGR_FldDomain_GetMergePolicy(arg1: OGRFieldDomainH) -> OGRFieldDomainMergePolicy::Type;
}
extern "C" {
    pub fn OGR_FldDomain_SetMergePolicy(
        arg1: OGRFieldDomainH,
        arg2: OGRFieldDomainMergePolicy::Type,
    );
}
extern "C" {
    pub fn OGR_CodedFldDomain_Create(
        pszName: *const libc::c_char,
        pszDescription: *const libc::c_char,
        eFieldType: OGRFieldType::Type,
        eFieldSubType: OGRFieldSubType::Type,
        enumeration: *const OGRCodedValue,
    ) -> OGRFieldDomainH;
}
extern "C" {
    pub fn OGR_CodedFldDomain_GetEnumeration(arg1: OGRFieldDomainH) -> *const OGRCodedValue;
}
extern "C" {
    pub fn OGR_RangeFldDomain_Create(
        pszName: *const libc::c_char,
        pszDescription: *const libc::c_char,
        eFieldType: OGRFieldType::Type,
        eFieldSubType: OGRFieldSubType::Type,
        psMin: *const OGRField,
        bMinIsInclusive: bool,
        psMax: *const OGRField,
        bMaxIsInclusive: bool,
    ) -> OGRFieldDomainH;
}
extern "C" {
    pub fn OGR_RangeFldDomain_GetMin(
        arg1: OGRFieldDomainH,
        pbIsInclusiveOut: *mut bool,
    ) -> *const OGRField;
}
extern "C" {
    pub fn OGR_RangeFldDomain_GetMax(
        arg1: OGRFieldDomainH,
        pbIsInclusiveOut: *mut bool,
    ) -> *const OGRField;
}
extern "C" {
    pub fn OGR_GlobFldDomain_Create(
        pszName: *const libc::c_char,
        pszDescription: *const libc::c_char,
        eFieldType: OGRFieldType::Type,
        eFieldSubType: OGRFieldSubType::Type,
        pszGlob: *const libc::c_char,
    ) -> OGRFieldDomainH;
}
extern "C" {
    pub fn OGR_GlobFldDomain_GetGlob(arg1: OGRFieldDomainH) -> *const libc::c_char;
}
#[doc = " Opaque type for a layer (OGRLayer)"]
pub type OGRLayerH = *mut libc::c_void;
#[doc = " Opaque type for a OGR datasource (OGRDataSource)"]
pub type OGRDataSourceH = *mut libc::c_void;
#[doc = " Opaque type for a OGR driver (OGRSFDriver)"]
pub type OGRSFDriverH = *mut libc::c_void;
extern "C" {
    pub fn OGR_L_GetName(arg1: OGRLayerH) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_L_GetGeomType(arg1: OGRLayerH) -> OGRwkbGeometryType::Type;
}
#[doc = " Result item of OGR_L_GetGeometryTypes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OGRGeometryTypeCounter {
    #[doc = " Geometry type"]
    pub eGeomType: OGRwkbGeometryType::Type,
    #[doc = " Number of geometries of type eGeomType"]
    pub nCount: i64,
}
#[test]
fn bindgen_test_layout_OGRGeometryTypeCounter() {
    const UNINIT: ::std::mem::MaybeUninit<OGRGeometryTypeCounter> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OGRGeometryTypeCounter>(),
        16usize,
        concat!("Size of: ", stringify!(OGRGeometryTypeCounter))
    );
    assert_eq!(
        ::std::mem::align_of::<OGRGeometryTypeCounter>(),
        8usize,
        concat!("Alignment of ", stringify!(OGRGeometryTypeCounter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eGeomType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRGeometryTypeCounter),
            "::",
            stringify!(eGeomType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRGeometryTypeCounter),
            "::",
            stringify!(nCount)
        )
    );
}
extern "C" {
    pub fn OGR_L_GetGeometryTypes(
        hLayer: OGRLayerH,
        iGeomField: libc::c_int,
        nFlags: libc::c_int,
        pnEntryCount: *mut libc::c_int,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
    ) -> *mut OGRGeometryTypeCounter;
}
extern "C" {
    pub fn OGR_L_GetSpatialFilter(arg1: OGRLayerH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_L_SetSpatialFilter(arg1: OGRLayerH, arg2: OGRGeometryH);
}
extern "C" {
    pub fn OGR_L_SetSpatialFilterRect(arg1: OGRLayerH, arg2: f64, arg3: f64, arg4: f64, arg5: f64);
}
extern "C" {
    pub fn OGR_L_SetSpatialFilterEx(arg1: OGRLayerH, iGeomField: libc::c_int, hGeom: OGRGeometryH);
}
extern "C" {
    pub fn OGR_L_SetSpatialFilterRectEx(
        arg1: OGRLayerH,
        iGeomField: libc::c_int,
        dfMinX: f64,
        dfMinY: f64,
        dfMaxX: f64,
        dfMaxY: f64,
    );
}
extern "C" {
    pub fn OGR_L_SetAttributeFilter(arg1: OGRLayerH, arg2: *const libc::c_char) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_ResetReading(arg1: OGRLayerH);
}
extern "C" {
    pub fn OGR_L_GetNextFeature(arg1: OGRLayerH) -> OGRFeatureH;
}
#[doc = " Data type for a Arrow C stream Include ogr_recordbatch.h to get the definition."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArrowArrayStream {
    _unused: [u8; 0],
}
extern "C" {
    pub fn OGR_L_GetArrowStream(
        hLayer: OGRLayerH,
        out_stream: *mut ArrowArrayStream,
        papszOptions: *mut *mut libc::c_char,
    ) -> bool;
}
extern "C" {
    pub fn OGR_L_SetNextByIndex(arg1: OGRLayerH, arg2: GIntBig) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_GetFeature(arg1: OGRLayerH, arg2: GIntBig) -> OGRFeatureH;
}
extern "C" {
    pub fn OGR_L_SetFeature(arg1: OGRLayerH, arg2: OGRFeatureH) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_CreateFeature(arg1: OGRLayerH, arg2: OGRFeatureH) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_DeleteFeature(arg1: OGRLayerH, arg2: GIntBig) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_UpsertFeature(arg1: OGRLayerH, arg2: OGRFeatureH) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_GetLayerDefn(arg1: OGRLayerH) -> OGRFeatureDefnH;
}
extern "C" {
    pub fn OGR_L_GetSpatialRef(arg1: OGRLayerH) -> OGRSpatialReferenceH;
}
extern "C" {
    pub fn OGR_L_FindFieldIndex(
        arg1: OGRLayerH,
        arg2: *const libc::c_char,
        bExactMatch: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OGR_L_GetFeatureCount(arg1: OGRLayerH, arg2: libc::c_int) -> GIntBig;
}
extern "C" {
    pub fn OGR_L_GetExtent(
        arg1: OGRLayerH,
        arg2: *mut OGREnvelope,
        arg3: libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_GetExtentEx(
        arg1: OGRLayerH,
        iGeomField: libc::c_int,
        psExtent: *mut OGREnvelope,
        bForce: libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_TestCapability(arg1: OGRLayerH, arg2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn OGR_L_CreateField(
        arg1: OGRLayerH,
        arg2: OGRFieldDefnH,
        arg3: libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_CreateGeomField(
        hLayer: OGRLayerH,
        hFieldDefn: OGRGeomFieldDefnH,
        bForce: libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_DeleteField(arg1: OGRLayerH, iField: libc::c_int) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_ReorderFields(arg1: OGRLayerH, panMap: *mut libc::c_int) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_ReorderField(
        arg1: OGRLayerH,
        iOldFieldPos: libc::c_int,
        iNewFieldPos: libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_AlterFieldDefn(
        arg1: OGRLayerH,
        iField: libc::c_int,
        hNewFieldDefn: OGRFieldDefnH,
        nFlags: libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_AlterGeomFieldDefn(
        arg1: OGRLayerH,
        iField: libc::c_int,
        hNewGeomFieldDefn: OGRGeomFieldDefnH,
        nFlags: libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_StartTransaction(arg1: OGRLayerH) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_CommitTransaction(arg1: OGRLayerH) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_RollbackTransaction(arg1: OGRLayerH) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_Rename(hLayer: OGRLayerH, pszNewName: *const libc::c_char) -> OGRErr::Type;
}
extern "C" {
    #[doc = " @cond Doxygen_Suppress"]
    pub fn OGR_L_Reference(arg1: OGRLayerH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_L_Dereference(arg1: OGRLayerH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_L_GetRefCount(arg1: OGRLayerH) -> libc::c_int;
}
extern "C" {
    #[doc = " @endcond"]
    pub fn OGR_L_SyncToDisk(arg1: OGRLayerH) -> OGRErr::Type;
}
extern "C" {
    #[doc = " @cond Doxygen_Suppress"]
    pub fn OGR_L_GetFeaturesRead(arg1: OGRLayerH) -> GIntBig;
}
extern "C" {
    #[doc = " @endcond"]
    pub fn OGR_L_GetFIDColumn(arg1: OGRLayerH) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_L_GetGeometryColumn(arg1: OGRLayerH) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get style table"]
    pub fn OGR_L_GetStyleTable(arg1: OGRLayerH) -> OGRStyleTableH;
}
extern "C" {
    #[doc = " Set style table (and take ownership)"]
    pub fn OGR_L_SetStyleTableDirectly(arg1: OGRLayerH, arg2: OGRStyleTableH);
}
extern "C" {
    #[doc = " Set style table"]
    pub fn OGR_L_SetStyleTable(arg1: OGRLayerH, arg2: OGRStyleTableH);
}
extern "C" {
    pub fn OGR_L_SetIgnoredFields(arg1: OGRLayerH, arg2: *mut *const libc::c_char) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_Intersection(
        arg1: OGRLayerH,
        arg2: OGRLayerH,
        arg3: OGRLayerH,
        arg4: *mut *mut libc::c_char,
        arg5: GDALProgressFunc,
        arg6: *mut libc::c_void,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_Union(
        arg1: OGRLayerH,
        arg2: OGRLayerH,
        arg3: OGRLayerH,
        arg4: *mut *mut libc::c_char,
        arg5: GDALProgressFunc,
        arg6: *mut libc::c_void,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_SymDifference(
        arg1: OGRLayerH,
        arg2: OGRLayerH,
        arg3: OGRLayerH,
        arg4: *mut *mut libc::c_char,
        arg5: GDALProgressFunc,
        arg6: *mut libc::c_void,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_Identity(
        arg1: OGRLayerH,
        arg2: OGRLayerH,
        arg3: OGRLayerH,
        arg4: *mut *mut libc::c_char,
        arg5: GDALProgressFunc,
        arg6: *mut libc::c_void,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_Update(
        arg1: OGRLayerH,
        arg2: OGRLayerH,
        arg3: OGRLayerH,
        arg4: *mut *mut libc::c_char,
        arg5: GDALProgressFunc,
        arg6: *mut libc::c_void,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_Clip(
        arg1: OGRLayerH,
        arg2: OGRLayerH,
        arg3: OGRLayerH,
        arg4: *mut *mut libc::c_char,
        arg5: GDALProgressFunc,
        arg6: *mut libc::c_void,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_Erase(
        arg1: OGRLayerH,
        arg2: OGRLayerH,
        arg3: OGRLayerH,
        arg4: *mut *mut libc::c_char,
        arg5: GDALProgressFunc,
        arg6: *mut libc::c_void,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_DS_Destroy(arg1: OGRDataSourceH);
}
extern "C" {
    pub fn OGR_DS_GetName(arg1: OGRDataSourceH) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_DS_GetLayerCount(arg1: OGRDataSourceH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_DS_GetLayer(arg1: OGRDataSourceH, arg2: libc::c_int) -> OGRLayerH;
}
extern "C" {
    pub fn OGR_DS_GetLayerByName(arg1: OGRDataSourceH, arg2: *const libc::c_char) -> OGRLayerH;
}
extern "C" {
    pub fn OGR_DS_DeleteLayer(arg1: OGRDataSourceH, arg2: libc::c_int) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_DS_GetDriver(arg1: OGRDataSourceH) -> OGRSFDriverH;
}
extern "C" {
    pub fn OGR_DS_CreateLayer(
        arg1: OGRDataSourceH,
        arg2: *const libc::c_char,
        arg3: OGRSpatialReferenceH,
        arg4: OGRwkbGeometryType::Type,
        arg5: *mut *mut libc::c_char,
    ) -> OGRLayerH;
}
extern "C" {
    pub fn OGR_DS_CopyLayer(
        arg1: OGRDataSourceH,
        arg2: OGRLayerH,
        arg3: *const libc::c_char,
        arg4: *mut *mut libc::c_char,
    ) -> OGRLayerH;
}
extern "C" {
    pub fn OGR_DS_TestCapability(arg1: OGRDataSourceH, arg2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn OGR_DS_ExecuteSQL(
        arg1: OGRDataSourceH,
        arg2: *const libc::c_char,
        arg3: OGRGeometryH,
        arg4: *const libc::c_char,
    ) -> OGRLayerH;
}
extern "C" {
    pub fn OGR_DS_ReleaseResultSet(arg1: OGRDataSourceH, arg2: OGRLayerH);
}
extern "C" {
    #[doc = " @cond Doxygen_Suppress"]
    pub fn OGR_DS_Reference(arg1: OGRDataSourceH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_DS_Dereference(arg1: OGRDataSourceH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_DS_GetRefCount(arg1: OGRDataSourceH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_DS_GetSummaryRefCount(arg1: OGRDataSourceH) -> libc::c_int;
}
extern "C" {
    #[doc = " @endcond */\n/** Flush pending changes to disk. See GDALDataset::FlushCache()"]
    pub fn OGR_DS_SyncToDisk(arg1: OGRDataSourceH) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Get style table"]
    pub fn OGR_DS_GetStyleTable(arg1: OGRDataSourceH) -> OGRStyleTableH;
}
extern "C" {
    #[doc = " Set style table (and take ownership)"]
    pub fn OGR_DS_SetStyleTableDirectly(arg1: OGRDataSourceH, arg2: OGRStyleTableH);
}
extern "C" {
    #[doc = " Set style table"]
    pub fn OGR_DS_SetStyleTable(arg1: OGRDataSourceH, arg2: OGRStyleTableH);
}
extern "C" {
    pub fn OGR_Dr_GetName(arg1: OGRSFDriverH) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_Dr_Open(
        arg1: OGRSFDriverH,
        arg2: *const libc::c_char,
        arg3: libc::c_int,
    ) -> OGRDataSourceH;
}
extern "C" {
    pub fn OGR_Dr_TestCapability(arg1: OGRSFDriverH, arg2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn OGR_Dr_CreateDataSource(
        arg1: OGRSFDriverH,
        arg2: *const libc::c_char,
        arg3: *mut *mut libc::c_char,
    ) -> OGRDataSourceH;
}
extern "C" {
    pub fn OGR_Dr_CopyDataSource(
        arg1: OGRSFDriverH,
        arg2: OGRDataSourceH,
        arg3: *const libc::c_char,
        arg4: *mut *mut libc::c_char,
    ) -> OGRDataSourceH;
}
extern "C" {
    pub fn OGR_Dr_DeleteDataSource(arg1: OGRSFDriverH, arg2: *const libc::c_char) -> OGRErr::Type;
}
extern "C" {
    pub fn OGROpen(
        arg1: *const libc::c_char,
        arg2: libc::c_int,
        arg3: *mut OGRSFDriverH,
    ) -> OGRDataSourceH;
}
extern "C" {
    pub fn OGROpenShared(
        arg1: *const libc::c_char,
        arg2: libc::c_int,
        arg3: *mut OGRSFDriverH,
    ) -> OGRDataSourceH;
}
extern "C" {
    pub fn OGRReleaseDataSource(arg1: OGRDataSourceH) -> OGRErr::Type;
}
extern "C" {
    #[doc = " @cond Doxygen_Suppress"]
    pub fn OGRRegisterDriver(arg1: OGRSFDriverH);
}
extern "C" {
    pub fn OGRDeregisterDriver(arg1: OGRSFDriverH);
}
extern "C" {
    #[doc = " @endcond"]
    pub fn OGRGetDriverCount() -> libc::c_int;
}
extern "C" {
    pub fn OGRGetDriver(arg1: libc::c_int) -> OGRSFDriverH;
}
extern "C" {
    pub fn OGRGetDriverByName(arg1: *const libc::c_char) -> OGRSFDriverH;
}
extern "C" {
    #[doc = " @cond Doxygen_Suppress"]
    pub fn OGRGetOpenDSCount() -> libc::c_int;
}
extern "C" {
    pub fn OGRGetOpenDS(iDS: libc::c_int) -> OGRDataSourceH;
}
extern "C" {
    #[doc = " @endcond"]
    pub fn OGRRegisterAll();
}
extern "C" {
    #[doc = " Clean-up all drivers (including raster ones starting with GDAL 2.0.\n See GDALDestroyDriverManager()"]
    pub fn OGRCleanupAll();
}
#[doc = " Style manager opaque type"]
pub type OGRStyleMgrH = *mut libc::c_void;
#[doc = " Style tool opaque type"]
pub type OGRStyleToolH = *mut libc::c_void;
extern "C" {
    pub fn OGR_SM_Create(hStyleTable: OGRStyleTableH) -> OGRStyleMgrH;
}
extern "C" {
    pub fn OGR_SM_Destroy(hSM: OGRStyleMgrH);
}
extern "C" {
    pub fn OGR_SM_InitFromFeature(hSM: OGRStyleMgrH, hFeat: OGRFeatureH) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_SM_InitStyleString(
        hSM: OGRStyleMgrH,
        pszStyleString: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OGR_SM_GetPartCount(
        hSM: OGRStyleMgrH,
        pszStyleString: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OGR_SM_GetPart(
        hSM: OGRStyleMgrH,
        nPartId: libc::c_int,
        pszStyleString: *const libc::c_char,
    ) -> OGRStyleToolH;
}
extern "C" {
    pub fn OGR_SM_AddPart(hSM: OGRStyleMgrH, hST: OGRStyleToolH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_SM_AddStyle(
        hSM: OGRStyleMgrH,
        pszStyleName: *const libc::c_char,
        pszStyleString: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OGR_ST_Create(eClassId: OGRSTClassId) -> OGRStyleToolH;
}
extern "C" {
    pub fn OGR_ST_Destroy(hST: OGRStyleToolH);
}
extern "C" {
    pub fn OGR_ST_GetType(hST: OGRStyleToolH) -> OGRSTClassId;
}
extern "C" {
    pub fn OGR_ST_GetUnit(hST: OGRStyleToolH) -> OGRSTUnitId;
}
extern "C" {
    pub fn OGR_ST_SetUnit(hST: OGRStyleToolH, eUnit: OGRSTUnitId, dfGroundPaperScale: f64);
}
extern "C" {
    pub fn OGR_ST_GetParamStr(
        hST: OGRStyleToolH,
        eParam: libc::c_int,
        bValueIsNull: *mut libc::c_int,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_ST_GetParamNum(
        hST: OGRStyleToolH,
        eParam: libc::c_int,
        bValueIsNull: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OGR_ST_GetParamDbl(
        hST: OGRStyleToolH,
        eParam: libc::c_int,
        bValueIsNull: *mut libc::c_int,
    ) -> f64;
}
extern "C" {
    pub fn OGR_ST_SetParamStr(
        hST: OGRStyleToolH,
        eParam: libc::c_int,
        pszValue: *const libc::c_char,
    );
}
extern "C" {
    pub fn OGR_ST_SetParamNum(hST: OGRStyleToolH, eParam: libc::c_int, nValue: libc::c_int);
}
extern "C" {
    pub fn OGR_ST_SetParamDbl(hST: OGRStyleToolH, eParam: libc::c_int, dfValue: f64);
}
extern "C" {
    pub fn OGR_ST_GetStyleString(hST: OGRStyleToolH) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_ST_GetRGBFromString(
        hST: OGRStyleToolH,
        pszColor: *const libc::c_char,
        pnRed: *mut libc::c_int,
        pnGreen: *mut libc::c_int,
        pnBlue: *mut libc::c_int,
        pnAlpha: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OGR_STBL_Create() -> OGRStyleTableH;
}
extern "C" {
    pub fn OGR_STBL_Destroy(hSTBL: OGRStyleTableH);
}
extern "C" {
    pub fn OGR_STBL_AddStyle(
        hStyleTable: OGRStyleTableH,
        pszName: *const libc::c_char,
        pszStyleString: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OGR_STBL_SaveStyleTable(
        hStyleTable: OGRStyleTableH,
        pszFilename: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OGR_STBL_LoadStyleTable(
        hStyleTable: OGRStyleTableH,
        pszFilename: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OGR_STBL_Find(
        hStyleTable: OGRStyleTableH,
        pszName: *const libc::c_char,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_STBL_ResetStyleStringReading(hStyleTable: OGRStyleTableH);
}
extern "C" {
    pub fn OGR_STBL_GetNextStyle(hStyleTable: OGRStyleTableH) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_STBL_GetLastStyleName(hStyleTable: OGRStyleTableH) -> *const libc::c_char;
}
pub mod GDALDataType {
    #[doc = " Pixel data types"]
    pub type Type = libc::c_uint;
    #[doc = " Unknown or unspecified type"]
    pub const GDT_Unknown: Type = 0;
    #[doc = " Eight bit unsigned integer"]
    pub const GDT_Byte: Type = 1;
    #[doc = " Sixteen bit unsigned integer"]
    pub const GDT_UInt16: Type = 2;
    #[doc = " Sixteen bit signed integer"]
    pub const GDT_Int16: Type = 3;
    #[doc = " Thirty two bit unsigned integer"]
    pub const GDT_UInt32: Type = 4;
    #[doc = " Thirty two bit signed integer"]
    pub const GDT_Int32: Type = 5;
    #[doc = " 64 bit unsigned integer (GDAL >= 3.5)"]
    pub const GDT_UInt64: Type = 12;
    #[doc = " 64 bit signed integer  (GDAL >= 3.5)"]
    pub const GDT_Int64: Type = 13;
    #[doc = " Thirty two bit floating point"]
    pub const GDT_Float32: Type = 6;
    #[doc = " Sixty four bit floating point"]
    pub const GDT_Float64: Type = 7;
    #[doc = " Complex Int16"]
    pub const GDT_CInt16: Type = 8;
    #[doc = " Complex Int32"]
    pub const GDT_CInt32: Type = 9;
    #[doc = " Complex Float32"]
    pub const GDT_CFloat32: Type = 10;
    #[doc = " Complex Float64"]
    pub const GDT_CFloat64: Type = 11;
    #[doc = " Complex Float64"]
    pub const GDT_TypeCount: Type = 14;
}
extern "C" {
    pub fn GDALGetDataTypeSize(arg1: GDALDataType::Type) -> libc::c_int;
}
extern "C" {
    pub fn GDALGetDataTypeSizeBits(eDataType: GDALDataType::Type) -> libc::c_int;
}
extern "C" {
    pub fn GDALGetDataTypeSizeBytes(arg1: GDALDataType::Type) -> libc::c_int;
}
extern "C" {
    pub fn GDALDataTypeIsComplex(arg1: GDALDataType::Type) -> libc::c_int;
}
extern "C" {
    pub fn GDALDataTypeIsInteger(arg1: GDALDataType::Type) -> libc::c_int;
}
extern "C" {
    pub fn GDALDataTypeIsFloating(arg1: GDALDataType::Type) -> libc::c_int;
}
extern "C" {
    pub fn GDALDataTypeIsSigned(arg1: GDALDataType::Type) -> libc::c_int;
}
extern "C" {
    pub fn GDALGetDataTypeName(arg1: GDALDataType::Type) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALGetDataTypeByName(arg1: *const libc::c_char) -> GDALDataType::Type;
}
extern "C" {
    pub fn GDALDataTypeUnion(
        arg1: GDALDataType::Type,
        arg2: GDALDataType::Type,
    ) -> GDALDataType::Type;
}
extern "C" {
    pub fn GDALDataTypeUnionWithValue(
        eDT: GDALDataType::Type,
        dValue: f64,
        bComplex: libc::c_int,
    ) -> GDALDataType::Type;
}
extern "C" {
    pub fn GDALFindDataType(
        nBits: libc::c_int,
        bSigned: libc::c_int,
        bFloating: libc::c_int,
        bComplex: libc::c_int,
    ) -> GDALDataType::Type;
}
extern "C" {
    pub fn GDALFindDataTypeForValue(dValue: f64, bComplex: libc::c_int) -> GDALDataType::Type;
}
extern "C" {
    pub fn GDALAdjustValueToDataType(
        eDT: GDALDataType::Type,
        dfValue: f64,
        pbClamped: *mut libc::c_int,
        pbRounded: *mut libc::c_int,
    ) -> f64;
}
extern "C" {
    pub fn GDALGetNonComplexDataType(arg1: GDALDataType::Type) -> GDALDataType::Type;
}
extern "C" {
    pub fn GDALDataTypeIsConversionLossy(
        eTypeFrom: GDALDataType::Type,
        eTypeTo: GDALDataType::Type,
    ) -> libc::c_int;
}
pub mod GDALAsyncStatusType {
    #[doc = " status of the asynchronous stream"]
    pub type Type = libc::c_uint;
    pub const GARIO_PENDING: Type = 0;
    pub const GARIO_UPDATE: Type = 1;
    pub const GARIO_ERROR: Type = 2;
    pub const GARIO_COMPLETE: Type = 3;
    pub const GARIO_TypeCount: Type = 4;
}
extern "C" {
    pub fn GDALGetAsyncStatusTypeName(arg1: GDALAsyncStatusType::Type) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALGetAsyncStatusTypeByName(arg1: *const libc::c_char) -> GDALAsyncStatusType::Type;
}
pub mod GDALAccess {
    #[doc = " Flag indicating read/write, or read-only access to data."]
    pub type Type = libc::c_uint;
    #[doc = " Read only (no update) access"]
    pub const GA_ReadOnly: Type = 0;
    #[doc = " Read/write access."]
    pub const GA_Update: Type = 1;
}
pub mod GDALRWFlag {
    #[doc = " Read/Write flag for RasterIO() method"]
    pub type Type = libc::c_uint;
    #[doc = " Read data"]
    pub const GF_Read: Type = 0;
    #[doc = " Write data"]
    pub const GF_Write: Type = 1;
}
pub mod GDALRIOResampleAlg {
    #[doc = " RasterIO() resampling method.\n @since GDAL 2.0"]
    pub type Type = libc::c_uint;
    #[doc = " Nearest neighbour"]
    pub const GRIORA_NearestNeighbour: Type = 0;
    #[doc = " Bilinear (2x2 kernel)"]
    pub const GRIORA_Bilinear: Type = 1;
    #[doc = " Cubic Convolution Approximation (4x4 kernel)"]
    pub const GRIORA_Cubic: Type = 2;
    #[doc = " Cubic B-Spline Approximation (4x4 kernel)"]
    pub const GRIORA_CubicSpline: Type = 3;
    #[doc = " Lanczos windowed sinc interpolation (6x6 kernel)"]
    pub const GRIORA_Lanczos: Type = 4;
    #[doc = " Average"]
    pub const GRIORA_Average: Type = 5;
    #[doc = " Mode (selects the value which appears most often of all the sampled points)"]
    pub const GRIORA_Mode: Type = 6;
    #[doc = " Gauss blurring"]
    pub const GRIORA_Gauss: Type = 7;
    #[doc = " @cond Doxygen_Suppress"]
    pub const GRIORA_RESERVED_START: Type = 8;
    #[doc = " @cond Doxygen_Suppress"]
    pub const GRIORA_RESERVED_END: Type = 13;
    #[doc = " @endcond */\n/** RMS: Root Mean Square / Quadratic Mean.\n For complex numbers, applies on the real and imaginary part independently."]
    pub const GRIORA_RMS: Type = 14;
    #[doc = " @cond Doxygen_Suppress"]
    pub const GRIORA_LAST: Type = 14;
}
#[doc = " Structure to pass extra arguments to RasterIO() method,\n must be initialized with INIT_RASTERIO_EXTRA_ARG\n @since GDAL 2.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALRasterIOExtraArg {
    #[doc = " Version of structure (to allow future extensions of the structure)"]
    pub nVersion: libc::c_int,
    #[doc = " Resampling algorithm"]
    pub eResampleAlg: GDALRIOResampleAlg::Type,
    #[doc = " Progress callback"]
    pub pfnProgress: GDALProgressFunc,
    #[doc = " Progress callback user data"]
    pub pProgressData: *mut libc::c_void,
    #[doc = " Indicate if dfXOff, dfYOff, dfXSize and dfYSize are set.\nMostly reserved from the VRT driver to communicate a more precise\nsource window. Must be such that dfXOff - nXOff < 1.0 and\ndfYOff - nYOff < 1.0 and nXSize - dfXSize < 1.0 and nYSize - dfYSize < 1.0"]
    pub bFloatingPointWindowValidity: libc::c_int,
    #[doc = " Pixel offset to the top left corner. Only valid if bFloatingPointWindowValidity = TRUE"]
    pub dfXOff: f64,
    #[doc = " Line offset to the top left corner. Only valid if bFloatingPointWindowValidity = TRUE"]
    pub dfYOff: f64,
    #[doc = " Width in pixels of the area of interest. Only valid if bFloatingPointWindowValidity = TRUE"]
    pub dfXSize: f64,
    #[doc = " Height in pixels of the area of interest. Only valid if bFloatingPointWindowValidity = TRUE"]
    pub dfYSize: f64,
}
#[test]
fn bindgen_test_layout_GDALRasterIOExtraArg() {
    const UNINIT: ::std::mem::MaybeUninit<GDALRasterIOExtraArg> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GDALRasterIOExtraArg>(),
        64usize,
        concat!("Size of: ", stringify!(GDALRasterIOExtraArg))
    );
    assert_eq!(
        ::std::mem::align_of::<GDALRasterIOExtraArg>(),
        8usize,
        concat!("Alignment of ", stringify!(GDALRasterIOExtraArg))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRasterIOExtraArg),
            "::",
            stringify!(nVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eResampleAlg) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRasterIOExtraArg),
            "::",
            stringify!(eResampleAlg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pfnProgress) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRasterIOExtraArg),
            "::",
            stringify!(pfnProgress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pProgressData) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRasterIOExtraArg),
            "::",
            stringify!(pProgressData)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).bFloatingPointWindowValidity) as usize - ptr as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRasterIOExtraArg),
            "::",
            stringify!(bFloatingPointWindowValidity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dfXOff) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRasterIOExtraArg),
            "::",
            stringify!(dfXOff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dfYOff) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRasterIOExtraArg),
            "::",
            stringify!(dfYOff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dfXSize) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRasterIOExtraArg),
            "::",
            stringify!(dfXSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dfYSize) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRasterIOExtraArg),
            "::",
            stringify!(dfYSize)
        )
    );
}
pub mod GDALColorInterp {
    #[doc = " Types of color interpretation for raster bands."]
    pub type Type = libc::c_uint;
    #[doc = " Undefined"]
    pub const GCI_Undefined: Type = 0;
    #[doc = " Greyscale"]
    pub const GCI_GrayIndex: Type = 1;
    #[doc = " Paletted (see associated color table)"]
    pub const GCI_PaletteIndex: Type = 2;
    #[doc = " Red band of RGBA image"]
    pub const GCI_RedBand: Type = 3;
    #[doc = " Green band of RGBA image"]
    pub const GCI_GreenBand: Type = 4;
    #[doc = " Blue band of RGBA image"]
    pub const GCI_BlueBand: Type = 5;
    #[doc = " Alpha (0=transparent, 255=opaque)"]
    pub const GCI_AlphaBand: Type = 6;
    #[doc = " Hue band of HLS image"]
    pub const GCI_HueBand: Type = 7;
    #[doc = " Saturation band of HLS image"]
    pub const GCI_SaturationBand: Type = 8;
    #[doc = " Lightness band of HLS image"]
    pub const GCI_LightnessBand: Type = 9;
    #[doc = " Cyan band of CMYK image"]
    pub const GCI_CyanBand: Type = 10;
    #[doc = " Magenta band of CMYK image"]
    pub const GCI_MagentaBand: Type = 11;
    #[doc = " Yellow band of CMYK image"]
    pub const GCI_YellowBand: Type = 12;
    #[doc = " Black band of CMYK image"]
    pub const GCI_BlackBand: Type = 13;
    #[doc = " Y Luminance"]
    pub const GCI_YCbCr_YBand: Type = 14;
    #[doc = " Cb Chroma"]
    pub const GCI_YCbCr_CbBand: Type = 15;
    #[doc = " Cr Chroma"]
    pub const GCI_YCbCr_CrBand: Type = 16;
    #[doc = " Max current value (equals to GCI_YCbCr_CrBand currently)"]
    pub const GCI_Max: Type = 16;
}
extern "C" {
    pub fn GDALGetColorInterpretationName(arg1: GDALColorInterp::Type) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALGetColorInterpretationByName(pszName: *const libc::c_char) -> GDALColorInterp::Type;
}
pub mod GDALPaletteInterp {
    #[doc = " Types of color interpretations for a GDALColorTable."]
    pub type Type = libc::c_uint;
    #[doc = " Grayscale (in GDALColorEntry.c1)"]
    pub const GPI_Gray: Type = 0;
    #[doc = " Red, Green, Blue and Alpha in (in c1, c2, c3 and c4)"]
    pub const GPI_RGB: Type = 1;
    #[doc = " Cyan, Magenta, Yellow and Black (in c1, c2, c3 and c4)"]
    pub const GPI_CMYK: Type = 2;
    #[doc = " Hue, Lightness and Saturation (in c1, c2, and c3)"]
    pub const GPI_HLS: Type = 3;
}
extern "C" {
    pub fn GDALGetPaletteInterpretationName(arg1: GDALPaletteInterp::Type) -> *const libc::c_char;
}
#[doc = " Opaque type used for the C bindings of the C++ GDALMajorObject class"]
pub type GDALMajorObjectH = *mut libc::c_void;
#[doc = " Opaque type used for the C bindings of the C++ GDALDataset class"]
pub type GDALDatasetH = *mut libc::c_void;
#[doc = " Opaque type used for the C bindings of the C++ GDALRasterBand class"]
pub type GDALRasterBandH = *mut libc::c_void;
#[doc = " Opaque type used for the C bindings of the C++ GDALDriver class"]
pub type GDALDriverH = *mut libc::c_void;
#[doc = " Opaque type used for the C bindings of the C++ GDALColorTable class"]
pub type GDALColorTableH = *mut libc::c_void;
#[doc = " Opaque type used for the C bindings of the C++ GDALRasterAttributeTable class"]
pub type GDALRasterAttributeTableH = *mut libc::c_void;
#[doc = " Opaque type used for the C bindings of the C++ GDALAsyncReader class"]
pub type GDALAsyncReaderH = *mut libc::c_void;
#[doc = " Opaque type used for the C bindings of the C++ GDALRelationship class\n  @since GDAL 3.6"]
pub type GDALRelationshipH = *mut libc::c_void;
#[doc = " Type to express pixel, line or band spacing. Signed 64 bit integer."]
pub type GSpacing = GIntBig;
pub mod GDALExtendedDataTypeClass {
    #[doc = " Enumeration giving the class of a GDALExtendedDataType.\n @since GDAL 3.1"]
    pub type Type = libc::c_uint;
    #[doc = " Numeric value. Based on GDALDataType enumeration"]
    pub const GEDTC_NUMERIC: Type = 0;
    #[doc = " String value."]
    pub const GEDTC_STRING: Type = 1;
    #[doc = " Compound data type."]
    pub const GEDTC_COMPOUND: Type = 2;
}
pub mod GDALExtendedDataTypeSubType {
    #[doc = " Enumeration giving the subtype of a GDALExtendedDataType.\n @since GDAL 3.4"]
    pub type Type = libc::c_uint;
    #[doc = " None."]
    pub const GEDTST_NONE: Type = 0;
    #[doc = " JSon. Only applies to GEDTC_STRING"]
    pub const GEDTST_JSON: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALExtendedDataTypeHS {
    _unused: [u8; 0],
}
#[doc = " Opaque type for C++ GDALExtendedDataType"]
pub type GDALExtendedDataTypeH = *mut GDALExtendedDataTypeHS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALEDTComponentHS {
    _unused: [u8; 0],
}
#[doc = " Opaque type for C++ GDALEDTComponent"]
pub type GDALEDTComponentH = *mut GDALEDTComponentHS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALGroupHS {
    _unused: [u8; 0],
}
#[doc = " Opaque type for C++ GDALGroup"]
pub type GDALGroupH = *mut GDALGroupHS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALMDArrayHS {
    _unused: [u8; 0],
}
#[doc = " Opaque type for C++ GDALMDArray"]
pub type GDALMDArrayH = *mut GDALMDArrayHS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALAttributeHS {
    _unused: [u8; 0],
}
#[doc = " Opaque type for C++ GDALAttribute"]
pub type GDALAttributeH = *mut GDALAttributeHS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALDimensionHS {
    _unused: [u8; 0],
}
#[doc = " Opaque type for C++ GDALDimension"]
pub type GDALDimensionH = *mut GDALDimensionHS;
extern "C" {
    pub fn GDALAllRegister();
}
extern "C" {
    pub fn GDALCreate(
        hDriver: GDALDriverH,
        arg1: *const libc::c_char,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: libc::c_int,
        arg5: GDALDataType::Type,
        arg6: CSLConstList,
    ) -> GDALDatasetH;
}
extern "C" {
    pub fn GDALCreateCopy(
        arg1: GDALDriverH,
        arg2: *const libc::c_char,
        arg3: GDALDatasetH,
        arg4: libc::c_int,
        arg5: CSLConstList,
        arg6: GDALProgressFunc,
        arg7: *mut libc::c_void,
    ) -> GDALDatasetH;
}
extern "C" {
    pub fn GDALIdentifyDriver(
        pszFilename: *const libc::c_char,
        papszFileList: CSLConstList,
    ) -> GDALDriverH;
}
extern "C" {
    pub fn GDALIdentifyDriverEx(
        pszFilename: *const libc::c_char,
        nIdentifyFlags: libc::c_uint,
        papszAllowedDrivers: *const *const libc::c_char,
        papszFileList: *const *const libc::c_char,
    ) -> GDALDriverH;
}
extern "C" {
    pub fn GDALOpen(pszFilename: *const libc::c_char, eAccess: GDALAccess::Type) -> GDALDatasetH;
}
extern "C" {
    pub fn GDALOpenShared(arg1: *const libc::c_char, arg2: GDALAccess::Type) -> GDALDatasetH;
}
extern "C" {
    pub fn GDALOpenEx(
        pszFilename: *const libc::c_char,
        nOpenFlags: libc::c_uint,
        papszAllowedDrivers: *const *const libc::c_char,
        papszOpenOptions: *const *const libc::c_char,
        papszSiblingFiles: *const *const libc::c_char,
    ) -> GDALDatasetH;
}
extern "C" {
    pub fn GDALDumpOpenDatasets(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn GDALGetDriverByName(arg1: *const libc::c_char) -> GDALDriverH;
}
extern "C" {
    pub fn GDALGetDriverCount() -> libc::c_int;
}
extern "C" {
    pub fn GDALGetDriver(arg1: libc::c_int) -> GDALDriverH;
}
extern "C" {
    pub fn GDALCreateDriver() -> GDALDriverH;
}
extern "C" {
    pub fn GDALDestroyDriver(arg1: GDALDriverH);
}
extern "C" {
    pub fn GDALRegisterDriver(arg1: GDALDriverH) -> libc::c_int;
}
extern "C" {
    pub fn GDALDeregisterDriver(arg1: GDALDriverH);
}
extern "C" {
    pub fn GDALDestroyDriverManager();
}
extern "C" {
    pub fn GDALDestroy();
}
extern "C" {
    pub fn GDALDeleteDataset(arg1: GDALDriverH, arg2: *const libc::c_char) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRenameDataset(
        arg1: GDALDriverH,
        pszNewName: *const libc::c_char,
        pszOldName: *const libc::c_char,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALCopyDatasetFiles(
        arg1: GDALDriverH,
        pszNewName: *const libc::c_char,
        pszOldName: *const libc::c_char,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALValidateCreationOptions(
        arg1: GDALDriverH,
        papszCreationOptions: CSLConstList,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALGetDriverShortName(arg1: GDALDriverH) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALGetDriverLongName(arg1: GDALDriverH) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALGetDriverHelpTopic(arg1: GDALDriverH) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALGetDriverCreationOptionList(arg1: GDALDriverH) -> *const libc::c_char;
}
#[doc = " Ground Control Point"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDAL_GCP {
    #[doc = " Unique identifier, often numeric"]
    pub pszId: *mut libc::c_char,
    #[doc = " Informational message or \"\""]
    pub pszInfo: *mut libc::c_char,
    #[doc = " Pixel (x) location of GCP on raster"]
    pub dfGCPPixel: f64,
    #[doc = " Line (y) location of GCP on raster"]
    pub dfGCPLine: f64,
    #[doc = " X position of GCP in georeferenced space"]
    pub dfGCPX: f64,
    #[doc = " Y position of GCP in georeferenced space"]
    pub dfGCPY: f64,
    #[doc = " Elevation of GCP, or zero if not known"]
    pub dfGCPZ: f64,
}
#[test]
fn bindgen_test_layout_GDAL_GCP() {
    const UNINIT: ::std::mem::MaybeUninit<GDAL_GCP> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GDAL_GCP>(),
        56usize,
        concat!("Size of: ", stringify!(GDAL_GCP))
    );
    assert_eq!(
        ::std::mem::align_of::<GDAL_GCP>(),
        8usize,
        concat!("Alignment of ", stringify!(GDAL_GCP))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pszId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GDAL_GCP),
            "::",
            stringify!(pszId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pszInfo) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GDAL_GCP),
            "::",
            stringify!(pszInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dfGCPPixel) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GDAL_GCP),
            "::",
            stringify!(dfGCPPixel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dfGCPLine) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GDAL_GCP),
            "::",
            stringify!(dfGCPLine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dfGCPX) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GDAL_GCP),
            "::",
            stringify!(dfGCPX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dfGCPY) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(GDAL_GCP),
            "::",
            stringify!(dfGCPY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dfGCPZ) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(GDAL_GCP),
            "::",
            stringify!(dfGCPZ)
        )
    );
}
extern "C" {
    pub fn GDALInitGCPs(arg1: libc::c_int, arg2: *mut GDAL_GCP);
}
extern "C" {
    pub fn GDALDeinitGCPs(arg1: libc::c_int, arg2: *mut GDAL_GCP);
}
extern "C" {
    pub fn GDALDuplicateGCPs(arg1: libc::c_int, arg2: *const GDAL_GCP) -> *mut GDAL_GCP;
}
extern "C" {
    pub fn GDALGCPsToGeoTransform(
        nGCPCount: libc::c_int,
        pasGCPs: *const GDAL_GCP,
        padfGeoTransform: *mut f64,
        bApproxOK: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALInvGeoTransform(
        padfGeoTransformIn: *mut f64,
        padfInvGeoTransformOut: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALApplyGeoTransform(
        arg1: *mut f64,
        arg2: f64,
        arg3: f64,
        arg4: *mut f64,
        arg5: *mut f64,
    );
}
extern "C" {
    pub fn GDALComposeGeoTransforms(
        padfGeoTransform1: *const f64,
        padfGeoTransform2: *const f64,
        padfGeoTransformOut: *mut f64,
    );
}
extern "C" {
    pub fn GDALGetMetadataDomainList(hObject: GDALMajorObjectH) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn GDALGetMetadata(
        arg1: GDALMajorObjectH,
        arg2: *const libc::c_char,
    ) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn GDALSetMetadata(
        arg1: GDALMajorObjectH,
        arg2: CSLConstList,
        arg3: *const libc::c_char,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetMetadataItem(
        arg1: GDALMajorObjectH,
        arg2: *const libc::c_char,
        arg3: *const libc::c_char,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALSetMetadataItem(
        arg1: GDALMajorObjectH,
        arg2: *const libc::c_char,
        arg3: *const libc::c_char,
        arg4: *const libc::c_char,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetDescription(arg1: GDALMajorObjectH) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALSetDescription(arg1: GDALMajorObjectH, arg2: *const libc::c_char);
}
extern "C" {
    pub fn GDALGetDatasetDriver(arg1: GDALDatasetH) -> GDALDriverH;
}
extern "C" {
    pub fn GDALGetFileList(arg1: GDALDatasetH) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn GDALClose(arg1: GDALDatasetH);
}
extern "C" {
    pub fn GDALGetRasterXSize(arg1: GDALDatasetH) -> libc::c_int;
}
extern "C" {
    pub fn GDALGetRasterYSize(arg1: GDALDatasetH) -> libc::c_int;
}
extern "C" {
    pub fn GDALGetRasterCount(arg1: GDALDatasetH) -> libc::c_int;
}
extern "C" {
    pub fn GDALGetRasterBand(arg1: GDALDatasetH, arg2: libc::c_int) -> GDALRasterBandH;
}
extern "C" {
    pub fn GDALAddBand(
        hDS: GDALDatasetH,
        eType: GDALDataType::Type,
        papszOptions: CSLConstList,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALBeginAsyncReader(
        hDS: GDALDatasetH,
        nXOff: libc::c_int,
        nYOff: libc::c_int,
        nXSize: libc::c_int,
        nYSize: libc::c_int,
        pBuf: *mut libc::c_void,
        nBufXSize: libc::c_int,
        nBufYSize: libc::c_int,
        eBufType: GDALDataType::Type,
        nBandCount: libc::c_int,
        panBandMap: *mut libc::c_int,
        nPixelSpace: libc::c_int,
        nLineSpace: libc::c_int,
        nBandSpace: libc::c_int,
        papszOptions: CSLConstList,
    ) -> GDALAsyncReaderH;
}
extern "C" {
    pub fn GDALEndAsyncReader(hDS: GDALDatasetH, hAsynchReaderH: GDALAsyncReaderH);
}
extern "C" {
    pub fn GDALDatasetRasterIO(
        hDS: GDALDatasetH,
        eRWFlag: GDALRWFlag::Type,
        nDSXOff: libc::c_int,
        nDSYOff: libc::c_int,
        nDSXSize: libc::c_int,
        nDSYSize: libc::c_int,
        pBuffer: *mut libc::c_void,
        nBXSize: libc::c_int,
        nBYSize: libc::c_int,
        eBDataType: GDALDataType::Type,
        nBandCount: libc::c_int,
        panBandCount: *mut libc::c_int,
        nPixelSpace: libc::c_int,
        nLineSpace: libc::c_int,
        nBandSpace: libc::c_int,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALDatasetRasterIOEx(
        hDS: GDALDatasetH,
        eRWFlag: GDALRWFlag::Type,
        nDSXOff: libc::c_int,
        nDSYOff: libc::c_int,
        nDSXSize: libc::c_int,
        nDSYSize: libc::c_int,
        pBuffer: *mut libc::c_void,
        nBXSize: libc::c_int,
        nBYSize: libc::c_int,
        eBDataType: GDALDataType::Type,
        nBandCount: libc::c_int,
        panBandCount: *mut libc::c_int,
        nPixelSpace: GSpacing,
        nLineSpace: GSpacing,
        nBandSpace: GSpacing,
        psExtraArg: *mut GDALRasterIOExtraArg,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALDatasetAdviseRead(
        hDS: GDALDatasetH,
        nDSXOff: libc::c_int,
        nDSYOff: libc::c_int,
        nDSXSize: libc::c_int,
        nDSYSize: libc::c_int,
        nBXSize: libc::c_int,
        nBYSize: libc::c_int,
        eBDataType: GDALDataType::Type,
        nBandCount: libc::c_int,
        panBandCount: *mut libc::c_int,
        papszOptions: CSLConstList,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetProjectionRef(arg1: GDALDatasetH) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALGetSpatialRef(arg1: GDALDatasetH) -> OGRSpatialReferenceH;
}
extern "C" {
    pub fn GDALSetProjection(arg1: GDALDatasetH, arg2: *const libc::c_char) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALSetSpatialRef(arg1: GDALDatasetH, arg2: OGRSpatialReferenceH) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetGeoTransform(arg1: GDALDatasetH, arg2: *mut f64) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALSetGeoTransform(arg1: GDALDatasetH, arg2: *mut f64) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetGCPCount(arg1: GDALDatasetH) -> libc::c_int;
}
extern "C" {
    pub fn GDALGetGCPProjection(arg1: GDALDatasetH) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALGetGCPSpatialRef(arg1: GDALDatasetH) -> OGRSpatialReferenceH;
}
extern "C" {
    pub fn GDALGetGCPs(arg1: GDALDatasetH) -> *const GDAL_GCP;
}
extern "C" {
    pub fn GDALSetGCPs(
        arg1: GDALDatasetH,
        arg2: libc::c_int,
        arg3: *const GDAL_GCP,
        arg4: *const libc::c_char,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALSetGCPs2(
        arg1: GDALDatasetH,
        arg2: libc::c_int,
        arg3: *const GDAL_GCP,
        arg4: OGRSpatialReferenceH,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetInternalHandle(
        arg1: GDALDatasetH,
        arg2: *const libc::c_char,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn GDALReferenceDataset(arg1: GDALDatasetH) -> libc::c_int;
}
extern "C" {
    pub fn GDALDereferenceDataset(arg1: GDALDatasetH) -> libc::c_int;
}
extern "C" {
    pub fn GDALReleaseDataset(arg1: GDALDatasetH) -> libc::c_int;
}
extern "C" {
    pub fn GDALBuildOverviews(
        arg1: GDALDatasetH,
        arg2: *const libc::c_char,
        arg3: libc::c_int,
        arg4: *const libc::c_int,
        arg5: libc::c_int,
        arg6: *const libc::c_int,
        arg7: GDALProgressFunc,
        arg8: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALBuildOverviewsEx(
        arg1: GDALDatasetH,
        arg2: *const libc::c_char,
        arg3: libc::c_int,
        arg4: *const libc::c_int,
        arg5: libc::c_int,
        arg6: *const libc::c_int,
        arg7: GDALProgressFunc,
        arg8: *mut libc::c_void,
        papszOptions: CSLConstList,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetOpenDatasets(hDS: *mut *mut GDALDatasetH, pnCount: *mut libc::c_int);
}
extern "C" {
    pub fn GDALGetAccess(hDS: GDALDatasetH) -> libc::c_int;
}
extern "C" {
    pub fn GDALFlushCache(hDS: GDALDatasetH);
}
extern "C" {
    pub fn GDALCreateDatasetMaskBand(hDS: GDALDatasetH, nFlags: libc::c_int) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALDatasetCopyWholeRaster(
        hSrcDS: GDALDatasetH,
        hDstDS: GDALDatasetH,
        papszOptions: CSLConstList,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRasterBandCopyWholeRaster(
        hSrcBand: GDALRasterBandH,
        hDstBand: GDALRasterBandH,
        constpapszOptions: *const *const libc::c_char,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRegenerateOverviews(
        hSrcBand: GDALRasterBandH,
        nOverviewCount: libc::c_int,
        pahOverviewBands: *mut GDALRasterBandH,
        pszResampling: *const libc::c_char,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRegenerateOverviewsEx(
        hSrcBand: GDALRasterBandH,
        nOverviewCount: libc::c_int,
        pahOverviewBands: *mut GDALRasterBandH,
        pszResampling: *const libc::c_char,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
        papszOptions: CSLConstList,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALDatasetGetLayerCount(arg1: GDALDatasetH) -> libc::c_int;
}
extern "C" {
    pub fn GDALDatasetGetLayer(arg1: GDALDatasetH, arg2: libc::c_int) -> OGRLayerH;
}
extern "C" {
    pub fn GDALDatasetGetLayerByName(arg1: GDALDatasetH, arg2: *const libc::c_char) -> OGRLayerH;
}
extern "C" {
    pub fn GDALDatasetIsLayerPrivate(arg1: GDALDatasetH, arg2: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn GDALDatasetDeleteLayer(arg1: GDALDatasetH, arg2: libc::c_int) -> OGRErr::Type;
}
extern "C" {
    pub fn GDALDatasetCreateLayer(
        arg1: GDALDatasetH,
        arg2: *const libc::c_char,
        arg3: OGRSpatialReferenceH,
        arg4: OGRwkbGeometryType::Type,
        arg5: CSLConstList,
    ) -> OGRLayerH;
}
extern "C" {
    pub fn GDALDatasetCopyLayer(
        arg1: GDALDatasetH,
        arg2: OGRLayerH,
        arg3: *const libc::c_char,
        arg4: CSLConstList,
    ) -> OGRLayerH;
}
extern "C" {
    pub fn GDALDatasetResetReading(arg1: GDALDatasetH);
}
extern "C" {
    pub fn GDALDatasetGetNextFeature(
        hDS: GDALDatasetH,
        phBelongingLayer: *mut OGRLayerH,
        pdfProgressPct: *mut f64,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
    ) -> OGRFeatureH;
}
extern "C" {
    pub fn GDALDatasetTestCapability(arg1: GDALDatasetH, arg2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn GDALDatasetExecuteSQL(
        arg1: GDALDatasetH,
        arg2: *const libc::c_char,
        arg3: OGRGeometryH,
        arg4: *const libc::c_char,
    ) -> OGRLayerH;
}
extern "C" {
    pub fn GDALDatasetAbortSQL(arg1: GDALDatasetH) -> OGRErr::Type;
}
extern "C" {
    pub fn GDALDatasetReleaseResultSet(arg1: GDALDatasetH, arg2: OGRLayerH);
}
extern "C" {
    pub fn GDALDatasetGetStyleTable(arg1: GDALDatasetH) -> OGRStyleTableH;
}
extern "C" {
    pub fn GDALDatasetSetStyleTableDirectly(arg1: GDALDatasetH, arg2: OGRStyleTableH);
}
extern "C" {
    pub fn GDALDatasetSetStyleTable(arg1: GDALDatasetH, arg2: OGRStyleTableH);
}
extern "C" {
    pub fn GDALDatasetStartTransaction(hDS: GDALDatasetH, bForce: libc::c_int) -> OGRErr::Type;
}
extern "C" {
    pub fn GDALDatasetCommitTransaction(hDS: GDALDatasetH) -> OGRErr::Type;
}
extern "C" {
    pub fn GDALDatasetRollbackTransaction(hDS: GDALDatasetH) -> OGRErr::Type;
}
extern "C" {
    pub fn GDALDatasetClearStatistics(hDS: GDALDatasetH);
}
extern "C" {
    pub fn GDALDatasetGetFieldDomainNames(
        arg1: GDALDatasetH,
        arg2: CSLConstList,
    ) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn GDALDatasetGetFieldDomain(
        hDS: GDALDatasetH,
        pszName: *const libc::c_char,
    ) -> OGRFieldDomainH;
}
extern "C" {
    pub fn GDALDatasetAddFieldDomain(
        hDS: GDALDatasetH,
        hFieldDomain: OGRFieldDomainH,
        ppszFailureReason: *mut *mut libc::c_char,
    ) -> bool;
}
extern "C" {
    pub fn GDALDatasetDeleteFieldDomain(
        hDS: GDALDatasetH,
        pszName: *const libc::c_char,
        ppszFailureReason: *mut *mut libc::c_char,
    ) -> bool;
}
extern "C" {
    pub fn GDALDatasetUpdateFieldDomain(
        hDS: GDALDatasetH,
        hFieldDomain: OGRFieldDomainH,
        ppszFailureReason: *mut *mut libc::c_char,
    ) -> bool;
}
extern "C" {
    pub fn GDALDatasetGetRelationshipNames(
        arg1: GDALDatasetH,
        arg2: CSLConstList,
    ) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn GDALDatasetGetRelationship(
        hDS: GDALDatasetH,
        pszName: *const libc::c_char,
    ) -> GDALRelationshipH;
}
extern "C" {
    pub fn GDALDatasetAddRelationship(
        hDS: GDALDatasetH,
        hRelationship: GDALRelationshipH,
        ppszFailureReason: *mut *mut libc::c_char,
    ) -> bool;
}
extern "C" {
    pub fn GDALDatasetDeleteRelationship(
        hDS: GDALDatasetH,
        pszName: *const libc::c_char,
        ppszFailureReason: *mut *mut libc::c_char,
    ) -> bool;
}
extern "C" {
    pub fn GDALDatasetUpdateRelationship(
        hDS: GDALDatasetH,
        hRelationship: GDALRelationshipH,
        ppszFailureReason: *mut *mut libc::c_char,
    ) -> bool;
}
#[doc = " Type of functions to pass to GDALAddDerivedBandPixelFunc.\n @since GDAL 2.2"]
pub type GDALDerivedPixelFunc = ::std::option::Option<
    unsafe extern "C" fn(
        papoSources: *mut *mut libc::c_void,
        nSources: libc::c_int,
        pData: *mut libc::c_void,
        nBufXSize: libc::c_int,
        nBufYSize: libc::c_int,
        eSrcType: GDALDataType::Type,
        eBufType: GDALDataType::Type,
        nPixelSpace: libc::c_int,
        nLineSpace: libc::c_int,
    ) -> CPLErr::Type,
>;
#[doc = " Type of functions to pass to GDALAddDerivedBandPixelFuncWithArgs.\n @since GDAL 3.4"]
pub type GDALDerivedPixelFuncWithArgs = ::std::option::Option<
    unsafe extern "C" fn(
        papoSources: *mut *mut libc::c_void,
        nSources: libc::c_int,
        pData: *mut libc::c_void,
        nBufXSize: libc::c_int,
        nBufYSize: libc::c_int,
        eSrcType: GDALDataType::Type,
        eBufType: GDALDataType::Type,
        nPixelSpace: libc::c_int,
        nLineSpace: libc::c_int,
        papszFunctionArgs: CSLConstList,
    ) -> CPLErr::Type,
>;
extern "C" {
    pub fn GDALGetRasterDataType(arg1: GDALRasterBandH) -> GDALDataType::Type;
}
extern "C" {
    pub fn GDALGetBlockSize(
        arg1: GDALRasterBandH,
        pnXSize: *mut libc::c_int,
        pnYSize: *mut libc::c_int,
    );
}
extern "C" {
    pub fn GDALGetActualBlockSize(
        arg1: GDALRasterBandH,
        nXBlockOff: libc::c_int,
        nYBlockOff: libc::c_int,
        pnXValid: *mut libc::c_int,
        pnYValid: *mut libc::c_int,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRasterAdviseRead(
        hRB: GDALRasterBandH,
        nDSXOff: libc::c_int,
        nDSYOff: libc::c_int,
        nDSXSize: libc::c_int,
        nDSYSize: libc::c_int,
        nBXSize: libc::c_int,
        nBYSize: libc::c_int,
        eBDataType: GDALDataType::Type,
        papszOptions: CSLConstList,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRasterIO(
        hRBand: GDALRasterBandH,
        eRWFlag: GDALRWFlag::Type,
        nDSXOff: libc::c_int,
        nDSYOff: libc::c_int,
        nDSXSize: libc::c_int,
        nDSYSize: libc::c_int,
        pBuffer: *mut libc::c_void,
        nBXSize: libc::c_int,
        nBYSize: libc::c_int,
        eBDataType: GDALDataType::Type,
        nPixelSpace: libc::c_int,
        nLineSpace: libc::c_int,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRasterIOEx(
        hRBand: GDALRasterBandH,
        eRWFlag: GDALRWFlag::Type,
        nDSXOff: libc::c_int,
        nDSYOff: libc::c_int,
        nDSXSize: libc::c_int,
        nDSYSize: libc::c_int,
        pBuffer: *mut libc::c_void,
        nBXSize: libc::c_int,
        nBYSize: libc::c_int,
        eBDataType: GDALDataType::Type,
        nPixelSpace: GSpacing,
        nLineSpace: GSpacing,
        psExtraArg: *mut GDALRasterIOExtraArg,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALReadBlock(
        arg1: GDALRasterBandH,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALWriteBlock(
        arg1: GDALRasterBandH,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetRasterBandXSize(arg1: GDALRasterBandH) -> libc::c_int;
}
extern "C" {
    pub fn GDALGetRasterBandYSize(arg1: GDALRasterBandH) -> libc::c_int;
}
extern "C" {
    pub fn GDALGetRasterAccess(arg1: GDALRasterBandH) -> GDALAccess::Type;
}
extern "C" {
    pub fn GDALGetBandNumber(arg1: GDALRasterBandH) -> libc::c_int;
}
extern "C" {
    pub fn GDALGetBandDataset(arg1: GDALRasterBandH) -> GDALDatasetH;
}
extern "C" {
    pub fn GDALGetRasterColorInterpretation(arg1: GDALRasterBandH) -> GDALColorInterp::Type;
}
extern "C" {
    pub fn GDALSetRasterColorInterpretation(
        arg1: GDALRasterBandH,
        arg2: GDALColorInterp::Type,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetRasterColorTable(arg1: GDALRasterBandH) -> GDALColorTableH;
}
extern "C" {
    pub fn GDALSetRasterColorTable(arg1: GDALRasterBandH, arg2: GDALColorTableH) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALHasArbitraryOverviews(arg1: GDALRasterBandH) -> libc::c_int;
}
extern "C" {
    pub fn GDALGetOverviewCount(arg1: GDALRasterBandH) -> libc::c_int;
}
extern "C" {
    pub fn GDALGetOverview(arg1: GDALRasterBandH, arg2: libc::c_int) -> GDALRasterBandH;
}
extern "C" {
    pub fn GDALGetRasterNoDataValue(arg1: GDALRasterBandH, arg2: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn GDALGetRasterNoDataValueAsInt64(arg1: GDALRasterBandH, arg2: *mut libc::c_int) -> i64;
}
extern "C" {
    pub fn GDALGetRasterNoDataValueAsUInt64(arg1: GDALRasterBandH, arg2: *mut libc::c_int) -> u64;
}
extern "C" {
    pub fn GDALSetRasterNoDataValue(arg1: GDALRasterBandH, arg2: f64) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALSetRasterNoDataValueAsInt64(arg1: GDALRasterBandH, arg2: i64) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALSetRasterNoDataValueAsUInt64(arg1: GDALRasterBandH, arg2: u64) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALDeleteRasterNoDataValue(arg1: GDALRasterBandH) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetRasterCategoryNames(arg1: GDALRasterBandH) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn GDALSetRasterCategoryNames(arg1: GDALRasterBandH, arg2: CSLConstList) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetRasterMinimum(arg1: GDALRasterBandH, pbSuccess: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn GDALGetRasterMaximum(arg1: GDALRasterBandH, pbSuccess: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn GDALGetRasterStatistics(
        arg1: GDALRasterBandH,
        bApproxOK: libc::c_int,
        bForce: libc::c_int,
        pdfMin: *mut f64,
        pdfMax: *mut f64,
        pdfMean: *mut f64,
        pdfStdDev: *mut f64,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALComputeRasterStatistics(
        arg1: GDALRasterBandH,
        bApproxOK: libc::c_int,
        pdfMin: *mut f64,
        pdfMax: *mut f64,
        pdfMean: *mut f64,
        pdfStdDev: *mut f64,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALSetRasterStatistics(
        hBand: GDALRasterBandH,
        dfMin: f64,
        dfMax: f64,
        dfMean: f64,
        dfStdDev: f64,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRasterBandAsMDArray(arg1: GDALRasterBandH) -> GDALMDArrayH;
}
extern "C" {
    pub fn GDALGetRasterUnitType(arg1: GDALRasterBandH) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALSetRasterUnitType(
        hBand: GDALRasterBandH,
        pszNewValue: *const libc::c_char,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetRasterOffset(arg1: GDALRasterBandH, pbSuccess: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn GDALSetRasterOffset(hBand: GDALRasterBandH, dfNewOffset: f64) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetRasterScale(arg1: GDALRasterBandH, pbSuccess: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn GDALSetRasterScale(hBand: GDALRasterBandH, dfNewOffset: f64) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALComputeRasterMinMax(
        hBand: GDALRasterBandH,
        bApproxOK: libc::c_int,
        adfMinMax: *mut f64,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALFlushRasterCache(hBand: GDALRasterBandH) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetRasterHistogram(
        hBand: GDALRasterBandH,
        dfMin: f64,
        dfMax: f64,
        nBuckets: libc::c_int,
        panHistogram: *mut libc::c_int,
        bIncludeOutOfRange: libc::c_int,
        bApproxOK: libc::c_int,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetRasterHistogramEx(
        hBand: GDALRasterBandH,
        dfMin: f64,
        dfMax: f64,
        nBuckets: libc::c_int,
        panHistogram: *mut GUIntBig,
        bIncludeOutOfRange: libc::c_int,
        bApproxOK: libc::c_int,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetDefaultHistogram(
        hBand: GDALRasterBandH,
        pdfMin: *mut f64,
        pdfMax: *mut f64,
        pnBuckets: *mut libc::c_int,
        ppanHistogram: *mut *mut libc::c_int,
        bForce: libc::c_int,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetDefaultHistogramEx(
        hBand: GDALRasterBandH,
        pdfMin: *mut f64,
        pdfMax: *mut f64,
        pnBuckets: *mut libc::c_int,
        ppanHistogram: *mut *mut GUIntBig,
        bForce: libc::c_int,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALSetDefaultHistogram(
        hBand: GDALRasterBandH,
        dfMin: f64,
        dfMax: f64,
        nBuckets: libc::c_int,
        panHistogram: *mut libc::c_int,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALSetDefaultHistogramEx(
        hBand: GDALRasterBandH,
        dfMin: f64,
        dfMax: f64,
        nBuckets: libc::c_int,
        panHistogram: *mut GUIntBig,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetRandomRasterSample(
        arg1: GDALRasterBandH,
        arg2: libc::c_int,
        arg3: *mut f32,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALGetRasterSampleOverview(arg1: GDALRasterBandH, arg2: libc::c_int)
        -> GDALRasterBandH;
}
extern "C" {
    pub fn GDALGetRasterSampleOverviewEx(arg1: GDALRasterBandH, arg2: GUIntBig) -> GDALRasterBandH;
}
extern "C" {
    pub fn GDALFillRaster(
        hBand: GDALRasterBandH,
        dfRealValue: f64,
        dfImaginaryValue: f64,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALComputeBandStats(
        hBand: GDALRasterBandH,
        nSampleStep: libc::c_int,
        pdfMean: *mut f64,
        pdfStdDev: *mut f64,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALOverviewMagnitudeCorrection(
        hBaseBand: GDALRasterBandH,
        nOverviewCount: libc::c_int,
        pahOverviews: *mut GDALRasterBandH,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetDefaultRAT(hBand: GDALRasterBandH) -> GDALRasterAttributeTableH;
}
extern "C" {
    pub fn GDALSetDefaultRAT(
        arg1: GDALRasterBandH,
        arg2: GDALRasterAttributeTableH,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALAddDerivedBandPixelFunc(
        pszName: *const libc::c_char,
        pfnPixelFunc: GDALDerivedPixelFunc,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALAddDerivedBandPixelFuncWithArgs(
        pszName: *const libc::c_char,
        pfnPixelFunc: GDALDerivedPixelFuncWithArgs,
        pszMetadata: *const libc::c_char,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetMaskBand(hBand: GDALRasterBandH) -> GDALRasterBandH;
}
extern "C" {
    pub fn GDALGetMaskFlags(hBand: GDALRasterBandH) -> libc::c_int;
}
extern "C" {
    pub fn GDALCreateMaskBand(hBand: GDALRasterBandH, nFlags: libc::c_int) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALIsMaskBand(hBand: GDALRasterBandH) -> bool;
}
extern "C" {
    pub fn GDALGetDataCoverageStatus(
        hBand: GDALRasterBandH,
        nXOff: libc::c_int,
        nYOff: libc::c_int,
        nXSize: libc::c_int,
        nYSize: libc::c_int,
        nMaskFlagStop: libc::c_int,
        pdfDataPct: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALARGetNextUpdatedRegion(
        hARIO: GDALAsyncReaderH,
        dfTimeout: f64,
        pnXBufOff: *mut libc::c_int,
        pnYBufOff: *mut libc::c_int,
        pnXBufSize: *mut libc::c_int,
        pnYBufSize: *mut libc::c_int,
    ) -> GDALAsyncStatusType::Type;
}
extern "C" {
    pub fn GDALARLockBuffer(hARIO: GDALAsyncReaderH, dfTimeout: f64) -> libc::c_int;
}
extern "C" {
    pub fn GDALARUnlockBuffer(hARIO: GDALAsyncReaderH);
}
extern "C" {
    pub fn GDALGeneralCmdLineProcessor(
        nArgc: libc::c_int,
        ppapszArgv: *mut *mut *mut libc::c_char,
        nOptions: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALSwapWords(
        pData: *mut libc::c_void,
        nWordSize: libc::c_int,
        nWordCount: libc::c_int,
        nWordSkip: libc::c_int,
    );
}
extern "C" {
    pub fn GDALSwapWordsEx(
        pData: *mut libc::c_void,
        nWordSize: libc::c_int,
        nWordCount: usize,
        nWordSkip: libc::c_int,
    );
}
extern "C" {
    pub fn GDALCopyWords(
        pSrcData: *const libc::c_void,
        eSrcType: GDALDataType::Type,
        nSrcPixelOffset: libc::c_int,
        pDstData: *mut libc::c_void,
        eDstType: GDALDataType::Type,
        nDstPixelOffset: libc::c_int,
        nWordCount: libc::c_int,
    );
}
extern "C" {
    pub fn GDALCopyWords64(
        pSrcData: *const libc::c_void,
        eSrcType: GDALDataType::Type,
        nSrcPixelOffset: libc::c_int,
        pDstData: *mut libc::c_void,
        eDstType: GDALDataType::Type,
        nDstPixelOffset: libc::c_int,
        nWordCount: GPtrDiff_t,
    );
}
extern "C" {
    pub fn GDALCopyBits(
        pabySrcData: *const GByte,
        nSrcOffset: libc::c_int,
        nSrcStep: libc::c_int,
        pabyDstData: *mut GByte,
        nDstOffset: libc::c_int,
        nDstStep: libc::c_int,
        nBitCount: libc::c_int,
        nStepCount: libc::c_int,
    );
}
extern "C" {
    pub fn GDALDeinterleave(
        pSourceBuffer: *const libc::c_void,
        eSourceDT: GDALDataType::Type,
        nComponents: libc::c_int,
        ppDestBuffer: *mut *mut libc::c_void,
        eDestDT: GDALDataType::Type,
        nIters: usize,
    );
}
extern "C" {
    pub fn GDALLoadWorldFile(arg1: *const libc::c_char, arg2: *mut f64) -> libc::c_int;
}
extern "C" {
    pub fn GDALReadWorldFile(
        arg1: *const libc::c_char,
        arg2: *const libc::c_char,
        arg3: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALWriteWorldFile(
        arg1: *const libc::c_char,
        arg2: *const libc::c_char,
        arg3: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALLoadTabFile(
        arg1: *const libc::c_char,
        arg2: *mut f64,
        arg3: *mut *mut libc::c_char,
        arg4: *mut libc::c_int,
        arg5: *mut *mut GDAL_GCP,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALReadTabFile(
        arg1: *const libc::c_char,
        arg2: *mut f64,
        arg3: *mut *mut libc::c_char,
        arg4: *mut libc::c_int,
        arg5: *mut *mut GDAL_GCP,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALLoadOziMapFile(
        arg1: *const libc::c_char,
        arg2: *mut f64,
        arg3: *mut *mut libc::c_char,
        arg4: *mut libc::c_int,
        arg5: *mut *mut GDAL_GCP,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALReadOziMapFile(
        arg1: *const libc::c_char,
        arg2: *mut f64,
        arg3: *mut *mut libc::c_char,
        arg4: *mut libc::c_int,
        arg5: *mut *mut GDAL_GCP,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALDecToDMS(
        arg1: f64,
        arg2: *const libc::c_char,
        arg3: libc::c_int,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALPackedDMSToDec(arg1: f64) -> f64;
}
extern "C" {
    pub fn GDALDecToPackedDMS(arg1: f64) -> f64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALRPCInfoV1 {
    #[doc = "< Line offset"]
    pub dfLINE_OFF: f64,
    #[doc = "< Sample/Pixel offset"]
    pub dfSAMP_OFF: f64,
    #[doc = "< Latitude offset"]
    pub dfLAT_OFF: f64,
    #[doc = "< Longitude offset"]
    pub dfLONG_OFF: f64,
    #[doc = "< Height offset"]
    pub dfHEIGHT_OFF: f64,
    #[doc = "< Line scale"]
    pub dfLINE_SCALE: f64,
    #[doc = "< Sample/Pixel scale"]
    pub dfSAMP_SCALE: f64,
    #[doc = "< Latitude scale"]
    pub dfLAT_SCALE: f64,
    #[doc = "< Longitude scale"]
    pub dfLONG_SCALE: f64,
    #[doc = "< Height scale"]
    pub dfHEIGHT_SCALE: f64,
    #[doc = "< Line Numerator Coefficients"]
    pub adfLINE_NUM_COEFF: [f64; 20usize],
    #[doc = "< Line Denominator Coefficients"]
    pub adfLINE_DEN_COEFF: [f64; 20usize],
    #[doc = "< Sample/Pixel Numerator Coefficients"]
    pub adfSAMP_NUM_COEFF: [f64; 20usize],
    #[doc = "< Sample/Pixel Denominator Coefficients"]
    pub adfSAMP_DEN_COEFF: [f64; 20usize],
    #[doc = "< Minimum longitude"]
    pub dfMIN_LONG: f64,
    #[doc = "< Minimum latitude"]
    pub dfMIN_LAT: f64,
    #[doc = "< Maximum longitude"]
    pub dfMAX_LONG: f64,
    #[doc = "< Maximum latitude"]
    pub dfMAX_LAT: f64,
}
#[test]
fn bindgen_test_layout_GDALRPCInfoV1() {
    const UNINIT: ::std::mem::MaybeUninit<GDALRPCInfoV1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GDALRPCInfoV1>(),
        752usize,
        concat!("Size of: ", stringify!(GDALRPCInfoV1))
    );
    assert_eq!(
        ::std::mem::align_of::<GDALRPCInfoV1>(),
        8usize,
        concat!("Alignment of ", stringify!(GDALRPCInfoV1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dfLINE_OFF) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfoV1),
            "::",
            stringify!(dfLINE_OFF)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dfSAMP_OFF) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfoV1),
            "::",
            stringify!(dfSAMP_OFF)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dfLAT_OFF) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfoV1),
            "::",
            stringify!(dfLAT_OFF)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dfLONG_OFF) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfoV1),
            "::",
            stringify!(dfLONG_OFF)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dfHEIGHT_OFF) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfoV1),
            "::",
            stringify!(dfHEIGHT_OFF)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dfLINE_SCALE) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfoV1),
            "::",
            stringify!(dfLINE_SCALE)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dfSAMP_SCALE) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfoV1),
            "::",
            stringify!(dfSAMP_SCALE)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dfLAT_SCALE) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfoV1),
            "::",
            stringify!(dfLAT_SCALE)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dfLONG_SCALE) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfoV1),
            "::",
            stringify!(dfLONG_SCALE)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dfHEIGHT_SCALE) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfoV1),
            "::",
            stringify!(dfHEIGHT_SCALE)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).adfLINE_NUM_COEFF) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfoV1),
            "::",
            stringify!(adfLINE_NUM_COEFF)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).adfLINE_DEN_COEFF) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfoV1),
            "::",
            stringify!(adfLINE_DEN_COEFF)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).adfSAMP_NUM_COEFF) as usize - ptr as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfoV1),
            "::",
            stringify!(adfSAMP_NUM_COEFF)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).adfSAMP_DEN_COEFF) as usize - ptr as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfoV1),
            "::",
            stringify!(adfSAMP_DEN_COEFF)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dfMIN_LONG) as usize - ptr as usize },
        720usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfoV1),
            "::",
            stringify!(dfMIN_LONG)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dfMIN_LAT) as usize - ptr as usize },
        728usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfoV1),
            "::",
            stringify!(dfMIN_LAT)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dfMAX_LONG) as usize - ptr as usize },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfoV1),
            "::",
            stringify!(dfMAX_LONG)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dfMAX_LAT) as usize - ptr as usize },
        744usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfoV1),
            "::",
            stringify!(dfMAX_LAT)
        )
    );
}
#[doc = " Structure to store Rational Polynomial Coefficients / Rigorous Projection\n Model. See http://geotiff.maptools.org/rpc_prop.html"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALRPCInfoV2 {
    #[doc = "< Line offset"]
    pub dfLINE_OFF: f64,
    #[doc = "< Sample/Pixel offset"]
    pub dfSAMP_OFF: f64,
    #[doc = "< Latitude offset"]
    pub dfLAT_OFF: f64,
    #[doc = "< Longitude offset"]
    pub dfLONG_OFF: f64,
    #[doc = "< Height offset"]
    pub dfHEIGHT_OFF: f64,
    #[doc = "< Line scale"]
    pub dfLINE_SCALE: f64,
    #[doc = "< Sample/Pixel scale"]
    pub dfSAMP_SCALE: f64,
    #[doc = "< Latitude scale"]
    pub dfLAT_SCALE: f64,
    #[doc = "< Longitude scale"]
    pub dfLONG_SCALE: f64,
    #[doc = "< Height scale"]
    pub dfHEIGHT_SCALE: f64,
    #[doc = "< Line Numerator Coefficients"]
    pub adfLINE_NUM_COEFF: [f64; 20usize],
    #[doc = "< Line Denominator Coefficients"]
    pub adfLINE_DEN_COEFF: [f64; 20usize],
    #[doc = "< Sample/Pixel Numerator Coefficients"]
    pub adfSAMP_NUM_COEFF: [f64; 20usize],
    #[doc = "< Sample/Pixel Denominator Coefficients"]
    pub adfSAMP_DEN_COEFF: [f64; 20usize],
    #[doc = "< Minimum longitude"]
    pub dfMIN_LONG: f64,
    #[doc = "< Minimum latitude"]
    pub dfMIN_LAT: f64,
    #[doc = "< Maximum longitude"]
    pub dfMAX_LONG: f64,
    #[doc = "< Maximum latitude"]
    pub dfMAX_LAT: f64,
    #[doc = "< Bias error"]
    pub dfERR_BIAS: f64,
    #[doc = "< Random error"]
    pub dfERR_RAND: f64,
}
#[test]
fn bindgen_test_layout_GDALRPCInfoV2() {
    const UNINIT: ::std::mem::MaybeUninit<GDALRPCInfoV2> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GDALRPCInfoV2>(),
        768usize,
        concat!("Size of: ", stringify!(GDALRPCInfoV2))
    );
    assert_eq!(
        ::std::mem::align_of::<GDALRPCInfoV2>(),
        8usize,
        concat!("Alignment of ", stringify!(GDALRPCInfoV2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dfLINE_OFF) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfoV2),
            "::",
            stringify!(dfLINE_OFF)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dfSAMP_OFF) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfoV2),
            "::",
            stringify!(dfSAMP_OFF)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dfLAT_OFF) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfoV2),
            "::",
            stringify!(dfLAT_OFF)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dfLONG_OFF) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfoV2),
            "::",
            stringify!(dfLONG_OFF)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dfHEIGHT_OFF) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfoV2),
            "::",
            stringify!(dfHEIGHT_OFF)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dfLINE_SCALE) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfoV2),
            "::",
            stringify!(dfLINE_SCALE)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dfSAMP_SCALE) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfoV2),
            "::",
            stringify!(dfSAMP_SCALE)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dfLAT_SCALE) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfoV2),
            "::",
            stringify!(dfLAT_SCALE)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dfLONG_SCALE) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfoV2),
            "::",
            stringify!(dfLONG_SCALE)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dfHEIGHT_SCALE) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfoV2),
            "::",
            stringify!(dfHEIGHT_SCALE)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).adfLINE_NUM_COEFF) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfoV2),
            "::",
            stringify!(adfLINE_NUM_COEFF)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).adfLINE_DEN_COEFF) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfoV2),
            "::",
            stringify!(adfLINE_DEN_COEFF)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).adfSAMP_NUM_COEFF) as usize - ptr as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfoV2),
            "::",
            stringify!(adfSAMP_NUM_COEFF)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).adfSAMP_DEN_COEFF) as usize - ptr as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfoV2),
            "::",
            stringify!(adfSAMP_DEN_COEFF)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dfMIN_LONG) as usize - ptr as usize },
        720usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfoV2),
            "::",
            stringify!(dfMIN_LONG)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dfMIN_LAT) as usize - ptr as usize },
        728usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfoV2),
            "::",
            stringify!(dfMIN_LAT)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dfMAX_LONG) as usize - ptr as usize },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfoV2),
            "::",
            stringify!(dfMAX_LONG)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dfMAX_LAT) as usize - ptr as usize },
        744usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfoV2),
            "::",
            stringify!(dfMAX_LAT)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dfERR_BIAS) as usize - ptr as usize },
        752usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfoV2),
            "::",
            stringify!(dfERR_BIAS)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dfERR_RAND) as usize - ptr as usize },
        760usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfoV2),
            "::",
            stringify!(dfERR_RAND)
        )
    );
}
extern "C" {
    #[doc = " @cond Doxygen_Suppress"]
    pub fn GDALExtractRPCInfoV1(arg1: CSLConstList, arg2: *mut GDALRPCInfoV1) -> libc::c_int;
}
extern "C" {
    #[doc = " @endcond"]
    pub fn GDALExtractRPCInfoV2(arg1: CSLConstList, arg2: *mut GDALRPCInfoV2) -> libc::c_int;
}
#[doc = " Color tuple"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALColorEntry {
    #[doc = " gray, red, cyan or hue"]
    pub c1: libc::c_short,
    #[doc = " green, magenta, or lightness"]
    pub c2: libc::c_short,
    #[doc = " blue, yellow, or saturation"]
    pub c3: libc::c_short,
    #[doc = " alpha or blackband"]
    pub c4: libc::c_short,
}
#[test]
fn bindgen_test_layout_GDALColorEntry() {
    const UNINIT: ::std::mem::MaybeUninit<GDALColorEntry> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GDALColorEntry>(),
        8usize,
        concat!("Size of: ", stringify!(GDALColorEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<GDALColorEntry>(),
        2usize,
        concat!("Alignment of ", stringify!(GDALColorEntry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).c1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALColorEntry),
            "::",
            stringify!(c1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).c2) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALColorEntry),
            "::",
            stringify!(c2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).c3) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALColorEntry),
            "::",
            stringify!(c3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).c4) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALColorEntry),
            "::",
            stringify!(c4)
        )
    );
}
extern "C" {
    pub fn GDALCreateColorTable(arg1: GDALPaletteInterp::Type) -> GDALColorTableH;
}
extern "C" {
    pub fn GDALDestroyColorTable(arg1: GDALColorTableH);
}
extern "C" {
    pub fn GDALCloneColorTable(arg1: GDALColorTableH) -> GDALColorTableH;
}
extern "C" {
    pub fn GDALGetPaletteInterpretation(arg1: GDALColorTableH) -> GDALPaletteInterp::Type;
}
extern "C" {
    pub fn GDALGetColorEntryCount(arg1: GDALColorTableH) -> libc::c_int;
}
extern "C" {
    pub fn GDALGetColorEntry(arg1: GDALColorTableH, arg2: libc::c_int) -> *const GDALColorEntry;
}
extern "C" {
    pub fn GDALGetColorEntryAsRGB(
        arg1: GDALColorTableH,
        arg2: libc::c_int,
        arg3: *mut GDALColorEntry,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALSetColorEntry(arg1: GDALColorTableH, arg2: libc::c_int, arg3: *const GDALColorEntry);
}
extern "C" {
    pub fn GDALCreateColorRamp(
        hTable: GDALColorTableH,
        nStartIndex: libc::c_int,
        psStartColor: *const GDALColorEntry,
        nEndIndex: libc::c_int,
        psEndColor: *const GDALColorEntry,
    );
}
pub mod GDALRATFieldType {
    #[doc = " Field type of raster attribute table"]
    pub type Type = libc::c_uint;
    #[doc = " Integer field"]
    pub const GFT_Integer: Type = 0;
    #[doc = " Floating point (double) field"]
    pub const GFT_Real: Type = 1;
    #[doc = " String field"]
    pub const GFT_String: Type = 2;
}
pub mod GDALRATFieldUsage {
    #[doc = " Field usage of raster attribute table"]
    pub type Type = libc::c_uint;
    #[doc = " General purpose field."]
    pub const GFU_Generic: Type = 0;
    #[doc = " Histogram pixel count"]
    pub const GFU_PixelCount: Type = 1;
    #[doc = " Class name"]
    pub const GFU_Name: Type = 2;
    #[doc = " Class range minimum"]
    pub const GFU_Min: Type = 3;
    #[doc = " Class range maximum"]
    pub const GFU_Max: Type = 4;
    #[doc = " Class value (min=max)"]
    pub const GFU_MinMax: Type = 5;
    #[doc = " Red class color (0-255)"]
    pub const GFU_Red: Type = 6;
    #[doc = " Green class color (0-255)"]
    pub const GFU_Green: Type = 7;
    #[doc = " Blue class color (0-255)"]
    pub const GFU_Blue: Type = 8;
    #[doc = " Alpha (0=transparent,255=opaque)"]
    pub const GFU_Alpha: Type = 9;
    #[doc = " Color Range Red Minimum"]
    pub const GFU_RedMin: Type = 10;
    #[doc = " Color Range Green Minimum"]
    pub const GFU_GreenMin: Type = 11;
    #[doc = " Color Range Blue Minimum"]
    pub const GFU_BlueMin: Type = 12;
    #[doc = " Color Range Alpha Minimum"]
    pub const GFU_AlphaMin: Type = 13;
    #[doc = " Color Range Red Maximum"]
    pub const GFU_RedMax: Type = 14;
    #[doc = " Color Range Green Maximum"]
    pub const GFU_GreenMax: Type = 15;
    #[doc = " Color Range Blue Maximum"]
    pub const GFU_BlueMax: Type = 16;
    #[doc = " Color Range Alpha Maximum"]
    pub const GFU_AlphaMax: Type = 17;
    #[doc = " Maximum GFU value (equals to GFU_AlphaMax+1 currently)"]
    pub const GFU_MaxCount: Type = 18;
}
pub mod GDALRATTableType {
    #[doc = " RAT table type (thematic or athematic)\n @since GDAL 2.4"]
    pub type Type = libc::c_uint;
    #[doc = " Thematic table type"]
    pub const GRTT_THEMATIC: Type = 0;
    #[doc = " Athematic table type"]
    pub const GRTT_ATHEMATIC: Type = 1;
}
extern "C" {
    pub fn GDALCreateRasterAttributeTable() -> GDALRasterAttributeTableH;
}
extern "C" {
    pub fn GDALDestroyRasterAttributeTable(arg1: GDALRasterAttributeTableH);
}
extern "C" {
    pub fn GDALRATGetColumnCount(arg1: GDALRasterAttributeTableH) -> libc::c_int;
}
extern "C" {
    pub fn GDALRATGetNameOfCol(
        arg1: GDALRasterAttributeTableH,
        arg2: libc::c_int,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALRATGetUsageOfCol(
        arg1: GDALRasterAttributeTableH,
        arg2: libc::c_int,
    ) -> GDALRATFieldUsage::Type;
}
extern "C" {
    pub fn GDALRATGetTypeOfCol(
        arg1: GDALRasterAttributeTableH,
        arg2: libc::c_int,
    ) -> GDALRATFieldType::Type;
}
extern "C" {
    pub fn GDALRATGetColOfUsage(
        arg1: GDALRasterAttributeTableH,
        arg2: GDALRATFieldUsage::Type,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALRATGetRowCount(arg1: GDALRasterAttributeTableH) -> libc::c_int;
}
extern "C" {
    pub fn GDALRATGetValueAsString(
        arg1: GDALRasterAttributeTableH,
        arg2: libc::c_int,
        arg3: libc::c_int,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALRATGetValueAsInt(
        arg1: GDALRasterAttributeTableH,
        arg2: libc::c_int,
        arg3: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALRATGetValueAsDouble(
        arg1: GDALRasterAttributeTableH,
        arg2: libc::c_int,
        arg3: libc::c_int,
    ) -> f64;
}
extern "C" {
    pub fn GDALRATSetValueAsString(
        arg1: GDALRasterAttributeTableH,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: *const libc::c_char,
    );
}
extern "C" {
    pub fn GDALRATSetValueAsInt(
        arg1: GDALRasterAttributeTableH,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: libc::c_int,
    );
}
extern "C" {
    pub fn GDALRATSetValueAsDouble(
        arg1: GDALRasterAttributeTableH,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: f64,
    );
}
extern "C" {
    pub fn GDALRATChangesAreWrittenToFile(hRAT: GDALRasterAttributeTableH) -> libc::c_int;
}
extern "C" {
    pub fn GDALRATValuesIOAsDouble(
        hRAT: GDALRasterAttributeTableH,
        eRWFlag: GDALRWFlag::Type,
        iField: libc::c_int,
        iStartRow: libc::c_int,
        iLength: libc::c_int,
        pdfData: *mut f64,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRATValuesIOAsInteger(
        hRAT: GDALRasterAttributeTableH,
        eRWFlag: GDALRWFlag::Type,
        iField: libc::c_int,
        iStartRow: libc::c_int,
        iLength: libc::c_int,
        pnData: *mut libc::c_int,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRATValuesIOAsString(
        hRAT: GDALRasterAttributeTableH,
        eRWFlag: GDALRWFlag::Type,
        iField: libc::c_int,
        iStartRow: libc::c_int,
        iLength: libc::c_int,
        papszStrList: CSLConstList,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRATSetRowCount(arg1: GDALRasterAttributeTableH, arg2: libc::c_int);
}
extern "C" {
    pub fn GDALRATCreateColumn(
        arg1: GDALRasterAttributeTableH,
        arg2: *const libc::c_char,
        arg3: GDALRATFieldType::Type,
        arg4: GDALRATFieldUsage::Type,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRATSetLinearBinning(
        arg1: GDALRasterAttributeTableH,
        arg2: f64,
        arg3: f64,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRATGetLinearBinning(
        arg1: GDALRasterAttributeTableH,
        arg2: *mut f64,
        arg3: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALRATSetTableType(
        hRAT: GDALRasterAttributeTableH,
        eInTableType: GDALRATTableType::Type,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRATGetTableType(hRAT: GDALRasterAttributeTableH) -> GDALRATTableType::Type;
}
extern "C" {
    pub fn GDALRATInitializeFromColorTable(
        arg1: GDALRasterAttributeTableH,
        arg2: GDALColorTableH,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRATTranslateToColorTable(
        arg1: GDALRasterAttributeTableH,
        nEntryCount: libc::c_int,
    ) -> GDALColorTableH;
}
extern "C" {
    pub fn GDALRATDumpReadable(arg1: GDALRasterAttributeTableH, arg2: *mut FILE);
}
extern "C" {
    pub fn GDALRATClone(arg1: GDALRasterAttributeTableH) -> GDALRasterAttributeTableH;
}
extern "C" {
    pub fn GDALRATSerializeJSON(arg1: GDALRasterAttributeTableH) -> *mut libc::c_void;
}
extern "C" {
    pub fn GDALRATGetRowOfValue(arg1: GDALRasterAttributeTableH, arg2: f64) -> libc::c_int;
}
extern "C" {
    pub fn GDALRATRemoveStatistics(arg1: GDALRasterAttributeTableH);
}
pub mod GDALRelationshipCardinality {
    #[doc = " Cardinality of relationship.\n\n @since GDAL 3.6"]
    pub type Type = libc::c_uint;
    #[doc = " One-to-one"]
    pub const GRC_ONE_TO_ONE: Type = 0;
    #[doc = " One-to-many"]
    pub const GRC_ONE_TO_MANY: Type = 1;
    #[doc = " Many-to-one"]
    pub const GRC_MANY_TO_ONE: Type = 2;
    #[doc = " Many-to-many"]
    pub const GRC_MANY_TO_MANY: Type = 3;
}
pub mod GDALRelationshipType {
    #[doc = " Type of relationship.\n\n @since GDAL 3.6"]
    pub type Type = libc::c_uint;
    #[doc = " Composite relationship"]
    pub const GRT_COMPOSITE: Type = 0;
    #[doc = " Association relationship"]
    pub const GRT_ASSOCIATION: Type = 1;
    #[doc = " Aggregation relationship"]
    pub const GRT_AGGREGATION: Type = 2;
}
extern "C" {
    pub fn GDALRelationshipCreate(
        arg1: *const libc::c_char,
        arg2: *const libc::c_char,
        arg3: *const libc::c_char,
        arg4: GDALRelationshipCardinality::Type,
    ) -> GDALRelationshipH;
}
extern "C" {
    pub fn GDALDestroyRelationship(arg1: GDALRelationshipH);
}
extern "C" {
    pub fn GDALRelationshipGetName(arg1: GDALRelationshipH) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALRelationshipGetCardinality(
        arg1: GDALRelationshipH,
    ) -> GDALRelationshipCardinality::Type;
}
extern "C" {
    pub fn GDALRelationshipGetLeftTableName(arg1: GDALRelationshipH) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALRelationshipGetRightTableName(arg1: GDALRelationshipH) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALRelationshipGetMappingTableName(arg1: GDALRelationshipH) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALRelationshipSetMappingTableName(arg1: GDALRelationshipH, arg2: *const libc::c_char);
}
extern "C" {
    pub fn GDALRelationshipGetLeftTableFields(arg1: GDALRelationshipH) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn GDALRelationshipGetRightTableFields(arg1: GDALRelationshipH) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn GDALRelationshipSetLeftTableFields(arg1: GDALRelationshipH, arg2: CSLConstList);
}
extern "C" {
    pub fn GDALRelationshipSetRightTableFields(arg1: GDALRelationshipH, arg2: CSLConstList);
}
extern "C" {
    pub fn GDALRelationshipGetLeftMappingTableFields(
        arg1: GDALRelationshipH,
    ) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn GDALRelationshipGetRightMappingTableFields(
        arg1: GDALRelationshipH,
    ) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn GDALRelationshipSetLeftMappingTableFields(arg1: GDALRelationshipH, arg2: CSLConstList);
}
extern "C" {
    pub fn GDALRelationshipSetRightMappingTableFields(arg1: GDALRelationshipH, arg2: CSLConstList);
}
extern "C" {
    pub fn GDALRelationshipGetType(arg1: GDALRelationshipH) -> GDALRelationshipType::Type;
}
extern "C" {
    pub fn GDALRelationshipSetType(arg1: GDALRelationshipH, arg2: GDALRelationshipType::Type);
}
extern "C" {
    pub fn GDALRelationshipGetForwardPathLabel(arg1: GDALRelationshipH) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALRelationshipSetForwardPathLabel(arg1: GDALRelationshipH, arg2: *const libc::c_char);
}
extern "C" {
    pub fn GDALRelationshipGetBackwardPathLabel(arg1: GDALRelationshipH) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALRelationshipSetBackwardPathLabel(arg1: GDALRelationshipH, arg2: *const libc::c_char);
}
extern "C" {
    pub fn GDALRelationshipGetRelatedTableType(arg1: GDALRelationshipH) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALRelationshipSetRelatedTableType(arg1: GDALRelationshipH, arg2: *const libc::c_char);
}
extern "C" {
    pub fn GDALSetCacheMax(nBytes: libc::c_int);
}
extern "C" {
    pub fn GDALGetCacheMax() -> libc::c_int;
}
extern "C" {
    pub fn GDALGetCacheUsed() -> libc::c_int;
}
extern "C" {
    pub fn GDALSetCacheMax64(nBytes: GIntBig);
}
extern "C" {
    pub fn GDALGetCacheMax64() -> GIntBig;
}
extern "C" {
    pub fn GDALGetCacheUsed64() -> GIntBig;
}
extern "C" {
    pub fn GDALFlushCacheBlock() -> libc::c_int;
}
extern "C" {
    pub fn GDALDatasetGetVirtualMem(
        hDS: GDALDatasetH,
        eRWFlag: GDALRWFlag::Type,
        nXOff: libc::c_int,
        nYOff: libc::c_int,
        nXSize: libc::c_int,
        nYSize: libc::c_int,
        nBufXSize: libc::c_int,
        nBufYSize: libc::c_int,
        eBufType: GDALDataType::Type,
        nBandCount: libc::c_int,
        panBandMap: *mut libc::c_int,
        nPixelSpace: libc::c_int,
        nLineSpace: GIntBig,
        nBandSpace: GIntBig,
        nCacheSize: usize,
        nPageSizeHint: usize,
        bSingleThreadUsage: libc::c_int,
        papszOptions: CSLConstList,
    ) -> *mut CPLVirtualMem;
}
extern "C" {
    pub fn GDALRasterBandGetVirtualMem(
        hBand: GDALRasterBandH,
        eRWFlag: GDALRWFlag::Type,
        nXOff: libc::c_int,
        nYOff: libc::c_int,
        nXSize: libc::c_int,
        nYSize: libc::c_int,
        nBufXSize: libc::c_int,
        nBufYSize: libc::c_int,
        eBufType: GDALDataType::Type,
        nPixelSpace: libc::c_int,
        nLineSpace: GIntBig,
        nCacheSize: usize,
        nPageSizeHint: usize,
        bSingleThreadUsage: libc::c_int,
        papszOptions: CSLConstList,
    ) -> *mut CPLVirtualMem;
}
extern "C" {
    pub fn GDALGetVirtualMemAuto(
        hBand: GDALRasterBandH,
        eRWFlag: GDALRWFlag::Type,
        pnPixelSpace: *mut libc::c_int,
        pnLineSpace: *mut GIntBig,
        papszOptions: CSLConstList,
    ) -> *mut CPLVirtualMem;
}
pub mod GDALTileOrganization {
    #[doc = " Enumeration to describe the tile organization"]
    pub type Type = libc::c_uint;
    #[doc = " Tile Interleaved by Pixel: tile (0,0) with internal band interleaved by pixel organization, tile (1, 0), ..."]
    pub const GTO_TIP: Type = 0;
    #[doc = " Band Interleaved by Tile : tile (0,0) of first band, tile (0,0) of second band, ... tile (1,0) of first band, tile (1,0) of second band, ..."]
    pub const GTO_BIT: Type = 1;
    #[doc = " Band SeQuential : all the tiles of first band, all the tiles of following band..."]
    pub const GTO_BSQ: Type = 2;
}
extern "C" {
    pub fn GDALDatasetGetTiledVirtualMem(
        hDS: GDALDatasetH,
        eRWFlag: GDALRWFlag::Type,
        nXOff: libc::c_int,
        nYOff: libc::c_int,
        nXSize: libc::c_int,
        nYSize: libc::c_int,
        nTileXSize: libc::c_int,
        nTileYSize: libc::c_int,
        eBufType: GDALDataType::Type,
        nBandCount: libc::c_int,
        panBandMap: *mut libc::c_int,
        eTileOrganization: GDALTileOrganization::Type,
        nCacheSize: usize,
        bSingleThreadUsage: libc::c_int,
        papszOptions: CSLConstList,
    ) -> *mut CPLVirtualMem;
}
extern "C" {
    pub fn GDALRasterBandGetTiledVirtualMem(
        hBand: GDALRasterBandH,
        eRWFlag: GDALRWFlag::Type,
        nXOff: libc::c_int,
        nYOff: libc::c_int,
        nXSize: libc::c_int,
        nYSize: libc::c_int,
        nTileXSize: libc::c_int,
        nTileYSize: libc::c_int,
        eBufType: GDALDataType::Type,
        nCacheSize: usize,
        bSingleThreadUsage: libc::c_int,
        papszOptions: CSLConstList,
    ) -> *mut CPLVirtualMem;
}
extern "C" {
    pub fn GDALCreatePansharpenedVRT(
        pszXML: *const libc::c_char,
        hPanchroBand: GDALRasterBandH,
        nInputSpectralBands: libc::c_int,
        pahInputSpectralBands: *mut GDALRasterBandH,
    ) -> GDALDatasetH;
}
extern "C" {
    pub fn GDALGetJPEG2000Structure(
        pszFilename: *const libc::c_char,
        papszOptions: CSLConstList,
    ) -> *mut CPLXMLNode;
}
extern "C" {
    pub fn GDALCreateMultiDimensional(
        hDriver: GDALDriverH,
        pszName: *const libc::c_char,
        papszRootGroupOptions: CSLConstList,
        papszOptions: CSLConstList,
    ) -> GDALDatasetH;
}
extern "C" {
    pub fn GDALExtendedDataTypeCreate(eType: GDALDataType::Type) -> GDALExtendedDataTypeH;
}
extern "C" {
    pub fn GDALExtendedDataTypeCreateString(nMaxStringLength: usize) -> GDALExtendedDataTypeH;
}
extern "C" {
    pub fn GDALExtendedDataTypeCreateStringEx(
        nMaxStringLength: usize,
        eSubType: GDALExtendedDataTypeSubType::Type,
    ) -> GDALExtendedDataTypeH;
}
extern "C" {
    pub fn GDALExtendedDataTypeCreateCompound(
        pszName: *const libc::c_char,
        nTotalSize: usize,
        nComponents: usize,
        comps: *const GDALEDTComponentH,
    ) -> GDALExtendedDataTypeH;
}
extern "C" {
    pub fn GDALExtendedDataTypeRelease(hEDT: GDALExtendedDataTypeH);
}
extern "C" {
    pub fn GDALExtendedDataTypeGetName(hEDT: GDALExtendedDataTypeH) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALExtendedDataTypeGetClass(
        hEDT: GDALExtendedDataTypeH,
    ) -> GDALExtendedDataTypeClass::Type;
}
extern "C" {
    pub fn GDALExtendedDataTypeGetNumericDataType(
        hEDT: GDALExtendedDataTypeH,
    ) -> GDALDataType::Type;
}
extern "C" {
    pub fn GDALExtendedDataTypeGetSize(hEDT: GDALExtendedDataTypeH) -> usize;
}
extern "C" {
    pub fn GDALExtendedDataTypeGetMaxStringLength(hEDT: GDALExtendedDataTypeH) -> usize;
}
extern "C" {
    pub fn GDALExtendedDataTypeGetComponents(
        hEDT: GDALExtendedDataTypeH,
        pnCount: *mut usize,
    ) -> *mut GDALEDTComponentH;
}
extern "C" {
    pub fn GDALExtendedDataTypeFreeComponents(components: *mut GDALEDTComponentH, nCount: usize);
}
extern "C" {
    pub fn GDALExtendedDataTypeCanConvertTo(
        hSourceEDT: GDALExtendedDataTypeH,
        hTargetEDT: GDALExtendedDataTypeH,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALExtendedDataTypeEquals(
        hFirstEDT: GDALExtendedDataTypeH,
        hSecondEDT: GDALExtendedDataTypeH,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALExtendedDataTypeGetSubType(
        hEDT: GDALExtendedDataTypeH,
    ) -> GDALExtendedDataTypeSubType::Type;
}
extern "C" {
    pub fn GDALEDTComponentCreate(
        pszName: *const libc::c_char,
        nOffset: usize,
        hType: GDALExtendedDataTypeH,
    ) -> GDALEDTComponentH;
}
extern "C" {
    pub fn GDALEDTComponentRelease(hComp: GDALEDTComponentH);
}
extern "C" {
    pub fn GDALEDTComponentGetName(hComp: GDALEDTComponentH) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALEDTComponentGetOffset(hComp: GDALEDTComponentH) -> usize;
}
extern "C" {
    pub fn GDALEDTComponentGetType(hComp: GDALEDTComponentH) -> GDALExtendedDataTypeH;
}
extern "C" {
    pub fn GDALDatasetGetRootGroup(hDS: GDALDatasetH) -> GDALGroupH;
}
extern "C" {
    pub fn GDALGroupRelease(hGroup: GDALGroupH);
}
extern "C" {
    pub fn GDALGroupGetName(hGroup: GDALGroupH) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALGroupGetFullName(hGroup: GDALGroupH) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALGroupGetMDArrayNames(
        hGroup: GDALGroupH,
        papszOptions: CSLConstList,
    ) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn GDALGroupOpenMDArray(
        hGroup: GDALGroupH,
        pszMDArrayName: *const libc::c_char,
        papszOptions: CSLConstList,
    ) -> GDALMDArrayH;
}
extern "C" {
    pub fn GDALGroupOpenMDArrayFromFullname(
        hGroup: GDALGroupH,
        pszMDArrayName: *const libc::c_char,
        papszOptions: CSLConstList,
    ) -> GDALMDArrayH;
}
extern "C" {
    pub fn GDALGroupResolveMDArray(
        hGroup: GDALGroupH,
        pszName: *const libc::c_char,
        pszStartingPoint: *const libc::c_char,
        papszOptions: CSLConstList,
    ) -> GDALMDArrayH;
}
extern "C" {
    pub fn GDALGroupGetGroupNames(
        hGroup: GDALGroupH,
        papszOptions: CSLConstList,
    ) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn GDALGroupOpenGroup(
        hGroup: GDALGroupH,
        pszSubGroupName: *const libc::c_char,
        papszOptions: CSLConstList,
    ) -> GDALGroupH;
}
extern "C" {
    pub fn GDALGroupOpenGroupFromFullname(
        hGroup: GDALGroupH,
        pszMDArrayName: *const libc::c_char,
        papszOptions: CSLConstList,
    ) -> GDALGroupH;
}
extern "C" {
    pub fn GDALGroupGetVectorLayerNames(
        hGroup: GDALGroupH,
        papszOptions: CSLConstList,
    ) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn GDALGroupOpenVectorLayer(
        hGroup: GDALGroupH,
        pszVectorLayerName: *const libc::c_char,
        papszOptions: CSLConstList,
    ) -> OGRLayerH;
}
extern "C" {
    pub fn GDALGroupGetDimensions(
        hGroup: GDALGroupH,
        pnCount: *mut usize,
        papszOptions: CSLConstList,
    ) -> *mut GDALDimensionH;
}
extern "C" {
    pub fn GDALGroupGetAttribute(
        hGroup: GDALGroupH,
        pszName: *const libc::c_char,
    ) -> GDALAttributeH;
}
extern "C" {
    pub fn GDALGroupGetAttributes(
        hGroup: GDALGroupH,
        pnCount: *mut usize,
        papszOptions: CSLConstList,
    ) -> *mut GDALAttributeH;
}
extern "C" {
    pub fn GDALGroupGetStructuralInfo(hGroup: GDALGroupH) -> CSLConstList;
}
extern "C" {
    pub fn GDALGroupCreateGroup(
        hGroup: GDALGroupH,
        pszSubGroupName: *const libc::c_char,
        papszOptions: CSLConstList,
    ) -> GDALGroupH;
}
extern "C" {
    pub fn GDALGroupCreateDimension(
        hGroup: GDALGroupH,
        pszName: *const libc::c_char,
        pszType: *const libc::c_char,
        pszDirection: *const libc::c_char,
        nSize: GUInt64,
        papszOptions: CSLConstList,
    ) -> GDALDimensionH;
}
extern "C" {
    pub fn GDALGroupCreateMDArray(
        hGroup: GDALGroupH,
        pszName: *const libc::c_char,
        nDimensions: usize,
        pahDimensions: *mut GDALDimensionH,
        hEDT: GDALExtendedDataTypeH,
        papszOptions: CSLConstList,
    ) -> GDALMDArrayH;
}
extern "C" {
    pub fn GDALGroupCreateAttribute(
        hGroup: GDALGroupH,
        pszName: *const libc::c_char,
        nDimensions: usize,
        panDimensions: *const GUInt64,
        hEDT: GDALExtendedDataTypeH,
        papszOptions: CSLConstList,
    ) -> GDALAttributeH;
}
extern "C" {
    pub fn GDALMDArrayRelease(hMDArray: GDALMDArrayH);
}
extern "C" {
    pub fn GDALMDArrayGetName(hArray: GDALMDArrayH) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALMDArrayGetFullName(hArray: GDALMDArrayH) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALMDArrayGetTotalElementsCount(hArray: GDALMDArrayH) -> GUInt64;
}
extern "C" {
    pub fn GDALMDArrayGetDimensionCount(hArray: GDALMDArrayH) -> usize;
}
extern "C" {
    pub fn GDALMDArrayGetDimensions(
        hArray: GDALMDArrayH,
        pnCount: *mut usize,
    ) -> *mut GDALDimensionH;
}
extern "C" {
    pub fn GDALMDArrayGetDataType(hArray: GDALMDArrayH) -> GDALExtendedDataTypeH;
}
extern "C" {
    pub fn GDALMDArrayRead(
        hArray: GDALMDArrayH,
        arrayStartIdx: *const GUInt64,
        count: *const usize,
        arrayStep: *const GInt64,
        bufferStride: *const GPtrDiff_t,
        bufferDatatype: GDALExtendedDataTypeH,
        pDstBuffer: *mut libc::c_void,
        pDstBufferAllocStart: *const libc::c_void,
        nDstBufferllocSize: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALMDArrayWrite(
        hArray: GDALMDArrayH,
        arrayStartIdx: *const GUInt64,
        count: *const usize,
        arrayStep: *const GInt64,
        bufferStride: *const GPtrDiff_t,
        bufferDatatype: GDALExtendedDataTypeH,
        pSrcBuffer: *const libc::c_void,
        psrcBufferAllocStart: *const libc::c_void,
        nSrcBufferllocSize: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALMDArrayAdviseRead(
        hArray: GDALMDArrayH,
        arrayStartIdx: *const GUInt64,
        count: *const usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALMDArrayAdviseReadEx(
        hArray: GDALMDArrayH,
        arrayStartIdx: *const GUInt64,
        count: *const usize,
        papszOptions: CSLConstList,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALMDArrayGetAttribute(
        hArray: GDALMDArrayH,
        pszName: *const libc::c_char,
    ) -> GDALAttributeH;
}
extern "C" {
    pub fn GDALMDArrayGetAttributes(
        hArray: GDALMDArrayH,
        pnCount: *mut usize,
        papszOptions: CSLConstList,
    ) -> *mut GDALAttributeH;
}
extern "C" {
    pub fn GDALMDArrayCreateAttribute(
        hArray: GDALMDArrayH,
        pszName: *const libc::c_char,
        nDimensions: usize,
        panDimensions: *const GUInt64,
        hEDT: GDALExtendedDataTypeH,
        papszOptions: CSLConstList,
    ) -> GDALAttributeH;
}
extern "C" {
    pub fn GDALMDArrayGetRawNoDataValue(hArray: GDALMDArrayH) -> *const libc::c_void;
}
extern "C" {
    pub fn GDALMDArrayGetNoDataValueAsDouble(
        hArray: GDALMDArrayH,
        pbHasNoDataValue: *mut libc::c_int,
    ) -> f64;
}
extern "C" {
    pub fn GDALMDArrayGetNoDataValueAsInt64(
        hArray: GDALMDArrayH,
        pbHasNoDataValue: *mut libc::c_int,
    ) -> i64;
}
extern "C" {
    pub fn GDALMDArrayGetNoDataValueAsUInt64(
        hArray: GDALMDArrayH,
        pbHasNoDataValue: *mut libc::c_int,
    ) -> u64;
}
extern "C" {
    pub fn GDALMDArraySetRawNoDataValue(
        hArray: GDALMDArrayH,
        arg1: *const libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALMDArraySetNoDataValueAsDouble(
        hArray: GDALMDArrayH,
        dfNoDataValue: f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALMDArraySetNoDataValueAsInt64(hArray: GDALMDArrayH, nNoDataValue: i64)
        -> libc::c_int;
}
extern "C" {
    pub fn GDALMDArraySetNoDataValueAsUInt64(
        hArray: GDALMDArrayH,
        nNoDataValue: u64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALMDArraySetScale(hArray: GDALMDArrayH, dfScale: f64) -> libc::c_int;
}
extern "C" {
    pub fn GDALMDArraySetScaleEx(
        hArray: GDALMDArrayH,
        dfScale: f64,
        eStorageType: GDALDataType::Type,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALMDArrayGetScale(hArray: GDALMDArrayH, pbHasValue: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn GDALMDArrayGetScaleEx(
        hArray: GDALMDArrayH,
        pbHasValue: *mut libc::c_int,
        peStorageType: *mut GDALDataType::Type,
    ) -> f64;
}
extern "C" {
    pub fn GDALMDArraySetOffset(hArray: GDALMDArrayH, dfOffset: f64) -> libc::c_int;
}
extern "C" {
    pub fn GDALMDArraySetOffsetEx(
        hArray: GDALMDArrayH,
        dfOffset: f64,
        eStorageType: GDALDataType::Type,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALMDArrayGetOffset(hArray: GDALMDArrayH, pbHasValue: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn GDALMDArrayGetOffsetEx(
        hArray: GDALMDArrayH,
        pbHasValue: *mut libc::c_int,
        peStorageType: *mut GDALDataType::Type,
    ) -> f64;
}
extern "C" {
    pub fn GDALMDArrayGetBlockSize(hArray: GDALMDArrayH, pnCount: *mut usize) -> *mut GUInt64;
}
extern "C" {
    pub fn GDALMDArraySetUnit(hArray: GDALMDArrayH, arg1: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn GDALMDArrayGetUnit(hArray: GDALMDArrayH) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALMDArraySetSpatialRef(arg1: GDALMDArrayH, arg2: OGRSpatialReferenceH) -> libc::c_int;
}
extern "C" {
    pub fn GDALMDArrayGetSpatialRef(hArray: GDALMDArrayH) -> OGRSpatialReferenceH;
}
extern "C" {
    pub fn GDALMDArrayGetProcessingChunkSize(
        hArray: GDALMDArrayH,
        pnCount: *mut usize,
        nMaxChunkMemory: usize,
    ) -> *mut usize;
}
extern "C" {
    pub fn GDALMDArrayGetStructuralInfo(hArray: GDALMDArrayH) -> CSLConstList;
}
extern "C" {
    pub fn GDALMDArrayGetView(
        hArray: GDALMDArrayH,
        pszViewExpr: *const libc::c_char,
    ) -> GDALMDArrayH;
}
extern "C" {
    pub fn GDALMDArrayTranspose(
        hArray: GDALMDArrayH,
        nNewAxisCount: usize,
        panMapNewAxisToOldAxis: *const libc::c_int,
    ) -> GDALMDArrayH;
}
extern "C" {
    pub fn GDALMDArrayGetUnscaled(hArray: GDALMDArrayH) -> GDALMDArrayH;
}
extern "C" {
    pub fn GDALMDArrayGetMask(hArray: GDALMDArrayH, papszOptions: CSLConstList) -> GDALMDArrayH;
}
extern "C" {
    pub fn GDALMDArrayAsClassicDataset(
        hArray: GDALMDArrayH,
        iXDim: usize,
        iYDim: usize,
    ) -> GDALDatasetH;
}
extern "C" {
    pub fn GDALMDArrayGetStatistics(
        hArray: GDALMDArrayH,
        arg1: GDALDatasetH,
        bApproxOK: libc::c_int,
        bForce: libc::c_int,
        pdfMin: *mut f64,
        pdfMax: *mut f64,
        pdfMean: *mut f64,
        pdfStdDev: *mut f64,
        pnValidCount: *mut GUInt64,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALMDArrayComputeStatistics(
        hArray: GDALMDArrayH,
        arg1: GDALDatasetH,
        bApproxOK: libc::c_int,
        pdfMin: *mut f64,
        pdfMax: *mut f64,
        pdfMean: *mut f64,
        pdfStdDev: *mut f64,
        pnValidCount: *mut GUInt64,
        arg2: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALMDArrayGetResampled(
        hArray: GDALMDArrayH,
        nNewDimCount: usize,
        pahNewDims: *const GDALDimensionH,
        resampleAlg: GDALRIOResampleAlg::Type,
        hTargetSRS: OGRSpatialReferenceH,
        papszOptions: CSLConstList,
    ) -> GDALMDArrayH;
}
extern "C" {
    pub fn GDALMDArrayGetCoordinateVariables(
        hArray: GDALMDArrayH,
        pnCount: *mut usize,
    ) -> *mut GDALMDArrayH;
}
extern "C" {
    pub fn GDALReleaseArrays(arrays: *mut GDALMDArrayH, nCount: usize);
}
extern "C" {
    pub fn GDALMDArrayCache(hArray: GDALMDArrayH, papszOptions: CSLConstList) -> libc::c_int;
}
extern "C" {
    pub fn GDALAttributeRelease(hAttr: GDALAttributeH);
}
extern "C" {
    pub fn GDALReleaseAttributes(attributes: *mut GDALAttributeH, nCount: usize);
}
extern "C" {
    pub fn GDALAttributeGetName(hAttr: GDALAttributeH) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALAttributeGetFullName(hAttr: GDALAttributeH) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALAttributeGetTotalElementsCount(hAttr: GDALAttributeH) -> GUInt64;
}
extern "C" {
    pub fn GDALAttributeGetDimensionCount(hAttr: GDALAttributeH) -> usize;
}
extern "C" {
    pub fn GDALAttributeGetDimensionsSize(
        hAttr: GDALAttributeH,
        pnCount: *mut usize,
    ) -> *mut GUInt64;
}
extern "C" {
    pub fn GDALAttributeGetDataType(hAttr: GDALAttributeH) -> GDALExtendedDataTypeH;
}
extern "C" {
    pub fn GDALAttributeReadAsRaw(hAttr: GDALAttributeH, pnSize: *mut usize) -> *mut GByte;
}
extern "C" {
    pub fn GDALAttributeFreeRawResult(hAttr: GDALAttributeH, raw: *mut GByte, nSize: usize);
}
extern "C" {
    pub fn GDALAttributeReadAsString(hAttr: GDALAttributeH) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALAttributeReadAsInt(hAttr: GDALAttributeH) -> libc::c_int;
}
extern "C" {
    pub fn GDALAttributeReadAsDouble(hAttr: GDALAttributeH) -> f64;
}
extern "C" {
    pub fn GDALAttributeReadAsStringArray(hAttr: GDALAttributeH) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn GDALAttributeReadAsIntArray(
        hAttr: GDALAttributeH,
        pnCount: *mut usize,
    ) -> *mut libc::c_int;
}
extern "C" {
    pub fn GDALAttributeReadAsDoubleArray(hAttr: GDALAttributeH, pnCount: *mut usize) -> *mut f64;
}
extern "C" {
    pub fn GDALAttributeWriteRaw(
        hAttr: GDALAttributeH,
        arg1: *const libc::c_void,
        arg2: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALAttributeWriteString(
        hAttr: GDALAttributeH,
        arg1: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALAttributeWriteStringArray(hAttr: GDALAttributeH, arg1: CSLConstList) -> libc::c_int;
}
extern "C" {
    pub fn GDALAttributeWriteInt(hAttr: GDALAttributeH, arg1: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn GDALAttributeWriteDouble(hAttr: GDALAttributeH, arg1: f64) -> libc::c_int;
}
extern "C" {
    pub fn GDALAttributeWriteDoubleArray(
        hAttr: GDALAttributeH,
        arg1: *const f64,
        arg2: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALDimensionRelease(hDim: GDALDimensionH);
}
extern "C" {
    pub fn GDALReleaseDimensions(dims: *mut GDALDimensionH, nCount: usize);
}
extern "C" {
    pub fn GDALDimensionGetName(hDim: GDALDimensionH) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALDimensionGetFullName(hDim: GDALDimensionH) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALDimensionGetType(hDim: GDALDimensionH) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALDimensionGetDirection(hDim: GDALDimensionH) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALDimensionGetSize(hDim: GDALDimensionH) -> GUInt64;
}
extern "C" {
    pub fn GDALDimensionGetIndexingVariable(hDim: GDALDimensionH) -> GDALMDArrayH;
}
extern "C" {
    pub fn GDALDimensionSetIndexingVariable(
        hDim: GDALDimensionH,
        hArray: GDALMDArrayH,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALComputeMedianCutPCT(
        hRed: GDALRasterBandH,
        hGreen: GDALRasterBandH,
        hBlue: GDALRasterBandH,
        pfnIncludePixel: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: libc::c_int,
                arg2: libc::c_int,
                arg3: *mut libc::c_void,
            ) -> libc::c_int,
        >,
        nColors: libc::c_int,
        hColorTable: GDALColorTableH,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALDitherRGB2PCT(
        hRed: GDALRasterBandH,
        hGreen: GDALRasterBandH,
        hBlue: GDALRasterBandH,
        hTarget: GDALRasterBandH,
        hColorTable: GDALColorTableH,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALChecksumImage(
        hBand: GDALRasterBandH,
        nXOff: libc::c_int,
        nYOff: libc::c_int,
        nXSize: libc::c_int,
        nYSize: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALComputeProximity(
        hSrcBand: GDALRasterBandH,
        hProximityBand: GDALRasterBandH,
        papszOptions: *mut *mut libc::c_char,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALFillNodata(
        hTargetBand: GDALRasterBandH,
        hMaskBand: GDALRasterBandH,
        dfMaxSearchDist: f64,
        bDeprecatedOption: libc::c_int,
        nSmoothingIterations: libc::c_int,
        papszOptions: *mut *mut libc::c_char,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALPolygonize(
        hSrcBand: GDALRasterBandH,
        hMaskBand: GDALRasterBandH,
        hOutLayer: OGRLayerH,
        iPixValField: libc::c_int,
        papszOptions: *mut *mut libc::c_char,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALFPolygonize(
        hSrcBand: GDALRasterBandH,
        hMaskBand: GDALRasterBandH,
        hOutLayer: OGRLayerH,
        iPixValField: libc::c_int,
        papszOptions: *mut *mut libc::c_char,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALSieveFilter(
        hSrcBand: GDALRasterBandH,
        hMaskBand: GDALRasterBandH,
        hDstBand: GDALRasterBandH,
        nSizeThreshold: libc::c_int,
        nConnectedness: libc::c_int,
        papszOptions: *mut *mut libc::c_char,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut libc::c_void,
    ) -> CPLErr::Type;
}
pub type GDALTransformerFunc = ::std::option::Option<
    unsafe extern "C" fn(
        pTransformerArg: *mut libc::c_void,
        bDstToSrc: libc::c_int,
        nPointCount: libc::c_int,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
        panSuccess: *mut libc::c_int,
    ) -> libc::c_int,
>;
extern "C" {
    #[doc = " @cond Doxygen_Suppress"]
    pub fn GDALDestroyTransformer(pTransformerArg: *mut libc::c_void);
}
extern "C" {
    pub fn GDALUseTransformer(
        pTransformerArg: *mut libc::c_void,
        bDstToSrc: libc::c_int,
        nPointCount: libc::c_int,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
        panSuccess: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALCreateSimilarTransformer(
        psTransformerArg: *mut libc::c_void,
        dfSrcRatioX: f64,
        dfSrcRatioY: f64,
    ) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " @endcond"]
    pub fn GDALCreateGenImgProjTransformer(
        hSrcDS: GDALDatasetH,
        pszSrcWKT: *const libc::c_char,
        hDstDS: GDALDatasetH,
        pszDstWKT: *const libc::c_char,
        bGCPUseOK: libc::c_int,
        dfGCPErrorThreshold: f64,
        nOrder: libc::c_int,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn GDALCreateGenImgProjTransformer2(
        hSrcDS: GDALDatasetH,
        hDstDS: GDALDatasetH,
        papszOptions: *mut *mut libc::c_char,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn GDALCreateGenImgProjTransformer3(
        pszSrcWKT: *const libc::c_char,
        padfSrcGeoTransform: *const f64,
        pszDstWKT: *const libc::c_char,
        padfDstGeoTransform: *const f64,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn GDALCreateGenImgProjTransformer4(
        hSrcSRS: OGRSpatialReferenceH,
        padfSrcGeoTransform: *const f64,
        hDstSRS: OGRSpatialReferenceH,
        padfDstGeoTransform: *const f64,
        papszOptions: *const *const libc::c_char,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn GDALSetGenImgProjTransformerDstGeoTransform(arg1: *mut libc::c_void, arg2: *const f64);
}
extern "C" {
    pub fn GDALDestroyGenImgProjTransformer(arg1: *mut libc::c_void);
}
extern "C" {
    pub fn GDALGenImgProjTransform(
        pTransformArg: *mut libc::c_void,
        bDstToSrc: libc::c_int,
        nPointCount: libc::c_int,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
        panSuccess: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALSetTransformerDstGeoTransform(arg1: *mut libc::c_void, arg2: *const f64);
}
extern "C" {
    pub fn GDALGetTransformerDstGeoTransform(arg1: *mut libc::c_void, arg2: *mut f64);
}
extern "C" {
    pub fn GDALCreateReprojectionTransformer(
        pszSrcWKT: *const libc::c_char,
        pszDstWKT: *const libc::c_char,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn GDALCreateReprojectionTransformerEx(
        hSrcSRS: OGRSpatialReferenceH,
        hDstSRS: OGRSpatialReferenceH,
        papszOptions: *const *const libc::c_char,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn GDALDestroyReprojectionTransformer(arg1: *mut libc::c_void);
}
extern "C" {
    pub fn GDALReprojectionTransform(
        pTransformArg: *mut libc::c_void,
        bDstToSrc: libc::c_int,
        nPointCount: libc::c_int,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
        panSuccess: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALCreateGCPTransformer(
        nGCPCount: libc::c_int,
        pasGCPList: *const GDAL_GCP,
        nReqOrder: libc::c_int,
        bReversed: libc::c_int,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn GDALCreateGCPRefineTransformer(
        nGCPCount: libc::c_int,
        pasGCPList: *const GDAL_GCP,
        nReqOrder: libc::c_int,
        bReversed: libc::c_int,
        tolerance: f64,
        minimumGcps: libc::c_int,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn GDALDestroyGCPTransformer(pTransformArg: *mut libc::c_void);
}
extern "C" {
    pub fn GDALGCPTransform(
        pTransformArg: *mut libc::c_void,
        bDstToSrc: libc::c_int,
        nPointCount: libc::c_int,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
        panSuccess: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALCreateTPSTransformer(
        nGCPCount: libc::c_int,
        pasGCPList: *const GDAL_GCP,
        bReversed: libc::c_int,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn GDALDestroyTPSTransformer(pTransformArg: *mut libc::c_void);
}
extern "C" {
    pub fn GDALTPSTransform(
        pTransformArg: *mut libc::c_void,
        bDstToSrc: libc::c_int,
        nPointCount: libc::c_int,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
        panSuccess: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALCreateRPCTransformerV1(
        psRPC: *mut GDALRPCInfoV1,
        bReversed: libc::c_int,
        dfPixErrThreshold: f64,
        papszOptions: *mut *mut libc::c_char,
    ) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " @endcond"]
    pub fn GDALCreateRPCTransformerV2(
        psRPC: *const GDALRPCInfoV2,
        bReversed: libc::c_int,
        dfPixErrThreshold: f64,
        papszOptions: *mut *mut libc::c_char,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn GDALDestroyRPCTransformer(pTransformArg: *mut libc::c_void);
}
extern "C" {
    pub fn GDALRPCTransform(
        pTransformArg: *mut libc::c_void,
        bDstToSrc: libc::c_int,
        nPointCount: libc::c_int,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
        panSuccess: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALCreateGeoLocTransformer(
        hBaseDS: GDALDatasetH,
        papszGeolocationInfo: *mut *mut libc::c_char,
        bReversed: libc::c_int,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn GDALDestroyGeoLocTransformer(pTransformArg: *mut libc::c_void);
}
extern "C" {
    pub fn GDALGeoLocTransform(
        pTransformArg: *mut libc::c_void,
        bDstToSrc: libc::c_int,
        nPointCount: libc::c_int,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
        panSuccess: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALCreateApproxTransformer(
        pfnRawTransformer: GDALTransformerFunc,
        pRawTransformerArg: *mut libc::c_void,
        dfMaxError: f64,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn GDALApproxTransformerOwnsSubtransformer(
        pCBData: *mut libc::c_void,
        bOwnFlag: libc::c_int,
    );
}
extern "C" {
    pub fn GDALDestroyApproxTransformer(pApproxArg: *mut libc::c_void);
}
extern "C" {
    pub fn GDALApproxTransform(
        pTransformArg: *mut libc::c_void,
        bDstToSrc: libc::c_int,
        nPointCount: libc::c_int,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
        panSuccess: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALSimpleImageWarp(
        hSrcDS: GDALDatasetH,
        hDstDS: GDALDatasetH,
        nBandCount: libc::c_int,
        panBandList: *mut libc::c_int,
        pfnTransform: GDALTransformerFunc,
        pTransformArg: *mut libc::c_void,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut libc::c_void,
        papszWarpOptions: *mut *mut libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALSuggestedWarpOutput(
        hSrcDS: GDALDatasetH,
        pfnTransformer: GDALTransformerFunc,
        pTransformArg: *mut libc::c_void,
        padfGeoTransformOut: *mut f64,
        pnPixels: *mut libc::c_int,
        pnLines: *mut libc::c_int,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALSuggestedWarpOutput2(
        hSrcDS: GDALDatasetH,
        pfnTransformer: GDALTransformerFunc,
        pTransformArg: *mut libc::c_void,
        padfGeoTransformOut: *mut f64,
        pnPixels: *mut libc::c_int,
        pnLines: *mut libc::c_int,
        padfExtents: *mut f64,
        nOptions: libc::c_int,
    ) -> CPLErr::Type;
}
extern "C" {
    #[doc = " @cond Doxygen_Suppress"]
    pub fn GDALSerializeTransformer(
        pfnFunc: GDALTransformerFunc,
        pTransformArg: *mut libc::c_void,
    ) -> *mut CPLXMLNode;
}
extern "C" {
    pub fn GDALDeserializeTransformer(
        psTree: *mut CPLXMLNode,
        ppfnFunc: *mut GDALTransformerFunc,
        ppTransformArg: *mut *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    #[doc = " @endcond"]
    pub fn GDALTransformGeolocations(
        hXBand: GDALRasterBandH,
        hYBand: GDALRasterBandH,
        hZBand: GDALRasterBandH,
        pfnTransformer: GDALTransformerFunc,
        pTransformArg: *mut libc::c_void,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut libc::c_void,
        papszOptions: *mut *mut libc::c_char,
    ) -> CPLErr::Type;
}
#[doc = " Contour writer callback type"]
pub type GDALContourWriter = ::std::option::Option<
    unsafe extern "C" fn(
        dfLevel: f64,
        nPoints: libc::c_int,
        padfX: *mut f64,
        padfY: *mut f64,
        arg1: *mut libc::c_void,
    ) -> CPLErr::Type,
>;
#[doc = " Contour generator opaque type"]
pub type GDALContourGeneratorH = *mut libc::c_void;
extern "C" {
    pub fn GDAL_CG_Create(
        nWidth: libc::c_int,
        nHeight: libc::c_int,
        bNoDataSet: libc::c_int,
        dfNoDataValue: f64,
        dfContourInterval: f64,
        dfContourBase: f64,
        pfnWriter: GDALContourWriter,
        pCBData: *mut libc::c_void,
    ) -> GDALContourGeneratorH;
}
extern "C" {
    pub fn GDAL_CG_FeedLine(hCG: GDALContourGeneratorH, padfScanline: *mut f64) -> CPLErr::Type;
}
extern "C" {
    pub fn GDAL_CG_Destroy(hCG: GDALContourGeneratorH);
}
extern "C" {
    pub fn OGRContourWriter(
        arg1: f64,
        arg2: libc::c_int,
        arg3: *mut f64,
        arg4: *mut f64,
        pInfo: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    #[doc = " @endcond"]
    pub fn GDALContourGenerate(
        hBand: GDALRasterBandH,
        dfContourInterval: f64,
        dfContourBase: f64,
        nFixedLevelCount: libc::c_int,
        padfFixedLevels: *mut f64,
        bUseNoData: libc::c_int,
        dfNoDataValue: f64,
        hLayer: *mut libc::c_void,
        iIDField: libc::c_int,
        iElevField: libc::c_int,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALContourGenerateEx(
        hBand: GDALRasterBandH,
        hLayer: *mut libc::c_void,
        options: CSLConstList,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut libc::c_void,
    ) -> CPLErr::Type;
}
pub mod GDALViewshedMode {
    #[doc = " Viewshed Modes"]
    pub type Type = libc::c_uint;
    pub const GVM_Diagonal: Type = 1;
    pub const GVM_Edge: Type = 2;
    pub const GVM_Max: Type = 3;
    pub const GVM_Min: Type = 4;
}
pub mod GDALViewshedOutputType {
    #[doc = " Viewshed output types"]
    pub type Type = libc::c_uint;
    pub const GVOT_NORMAL: Type = 1;
    pub const GVOT_MIN_TARGET_HEIGHT_FROM_DEM: Type = 2;
    pub const GVOT_MIN_TARGET_HEIGHT_FROM_GROUND: Type = 3;
}
extern "C" {
    pub fn GDALViewshedGenerate(
        hBand: GDALRasterBandH,
        pszDriverName: *const libc::c_char,
        pszTargetRasterName: *const libc::c_char,
        papszCreationOptions: CSLConstList,
        dfObserverX: f64,
        dfObserverY: f64,
        dfObserverHeight: f64,
        dfTargetHeight: f64,
        dfVisibleVal: f64,
        dfInvisibleVal: f64,
        dfOutOfRangeVal: f64,
        dfNoDataVal: f64,
        dfCurvCoeff: f64,
        eMode: GDALViewshedMode::Type,
        dfMaxDistance: f64,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut libc::c_void,
        heightMode: GDALViewshedOutputType::Type,
        papszExtraOptions: CSLConstList,
    ) -> GDALDatasetH;
}
extern "C" {
    pub fn GDALRasterizeGeometries(
        hDS: GDALDatasetH,
        nBandCount: libc::c_int,
        panBandList: *const libc::c_int,
        nGeomCount: libc::c_int,
        pahGeometries: *const OGRGeometryH,
        pfnTransformer: GDALTransformerFunc,
        pTransformArg: *mut libc::c_void,
        padfGeomBurnValues: *const f64,
        papszOptions: CSLConstList,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRasterizeGeometriesInt64(
        hDS: GDALDatasetH,
        nBandCount: libc::c_int,
        panBandList: *const libc::c_int,
        nGeomCount: libc::c_int,
        pahGeometries: *const OGRGeometryH,
        pfnTransformer: GDALTransformerFunc,
        pTransformArg: *mut libc::c_void,
        panGeomBurnValues: *const i64,
        papszOptions: CSLConstList,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRasterizeLayers(
        hDS: GDALDatasetH,
        nBandCount: libc::c_int,
        panBandList: *mut libc::c_int,
        nLayerCount: libc::c_int,
        pahLayers: *mut OGRLayerH,
        pfnTransformer: GDALTransformerFunc,
        pTransformArg: *mut libc::c_void,
        padfLayerBurnValues: *mut f64,
        papszOptions: *mut *mut libc::c_char,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRasterizeLayersBuf(
        pData: *mut libc::c_void,
        nBufXSize: libc::c_int,
        nBufYSize: libc::c_int,
        eBufType: GDALDataType::Type,
        nPixelSpace: libc::c_int,
        nLineSpace: libc::c_int,
        nLayerCount: libc::c_int,
        pahLayers: *mut OGRLayerH,
        pszDstProjection: *const libc::c_char,
        padfDstGeoTransform: *mut f64,
        pfnTransformer: GDALTransformerFunc,
        pTransformArg: *mut libc::c_void,
        dfBurnValue: f64,
        papszOptions: *mut *mut libc::c_char,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut libc::c_void,
    ) -> CPLErr::Type;
}
pub mod GDALGridAlgorithm {
    #[doc = " Gridding Algorithms"]
    pub type Type = libc::c_uint;
    #[doc = " Inverse distance to a power"]
    pub const GGA_InverseDistanceToAPower: Type = 1;
    #[doc = " Moving Average"]
    pub const GGA_MovingAverage: Type = 2;
    #[doc = " Nearest Neighbor"]
    pub const GGA_NearestNeighbor: Type = 3;
    #[doc = " Minimum Value (Data Metric)"]
    pub const GGA_MetricMinimum: Type = 4;
    #[doc = " Maximum Value (Data Metric)"]
    pub const GGA_MetricMaximum: Type = 5;
    #[doc = " Data Range (Data Metric)"]
    pub const GGA_MetricRange: Type = 6;
    #[doc = " Number of Points (Data Metric)"]
    pub const GGA_MetricCount: Type = 7;
    #[doc = " Average Distance (Data Metric)"]
    pub const GGA_MetricAverageDistance: Type = 8;
    #[doc = " Average Distance Between Data Points (Data Metric)"]
    pub const GGA_MetricAverageDistancePts: Type = 9;
    #[doc = " Linear interpolation (from Delaunay triangulation. Since GDAL 2.1"]
    pub const GGA_Linear: Type = 10;
    #[doc = " Inverse distance to a power with nearest neighbor search for max points"]
    pub const GGA_InverseDistanceToAPowerNearestNeighbor: Type = 11;
}
extern "C" {
    pub fn GDALGridCreate(
        arg1: GDALGridAlgorithm::Type,
        arg2: *const libc::c_void,
        arg3: GUInt32,
        arg4: *const f64,
        arg5: *const f64,
        arg6: *const f64,
        arg7: f64,
        arg8: f64,
        arg9: f64,
        arg10: f64,
        arg11: GUInt32,
        arg12: GUInt32,
        arg13: GDALDataType::Type,
        arg14: *mut libc::c_void,
        arg15: GDALProgressFunc,
        arg16: *mut libc::c_void,
    ) -> CPLErr::Type;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALGridContext {
    _unused: [u8; 0],
}
extern "C" {
    pub fn GDALGridContextCreate(
        eAlgorithm: GDALGridAlgorithm::Type,
        poOptions: *const libc::c_void,
        nPoints: GUInt32,
        padfX: *const f64,
        padfY: *const f64,
        padfZ: *const f64,
        bCallerWillKeepPointArraysAlive: libc::c_int,
    ) -> *mut GDALGridContext;
}
extern "C" {
    pub fn GDALGridContextFree(psContext: *mut GDALGridContext);
}
extern "C" {
    pub fn GDALGridContextProcess(
        psContext: *mut GDALGridContext,
        dfXMin: f64,
        dfXMax: f64,
        dfYMin: f64,
        dfYMax: f64,
        nXSize: GUInt32,
        nYSize: GUInt32,
        eType: GDALDataType::Type,
        pData: *mut libc::c_void,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALComputeMatchingPoints(
        hFirstImage: GDALDatasetH,
        hSecondImage: GDALDatasetH,
        papszOptions: *mut *mut libc::c_char,
        pnGCPCount: *mut libc::c_int,
    ) -> *mut GDAL_GCP;
}
#[doc = " Triangle fact"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALTriFacet {
    #[doc = "< index to the padfX/padfY arrays"]
    pub anVertexIdx: [libc::c_int; 3usize],
    #[doc = "< index to GDALDelaunayTriangulation.pasFacets, or -1"]
    pub anNeighborIdx: [libc::c_int; 3usize],
}
#[test]
fn bindgen_test_layout_GDALTriFacet() {
    const UNINIT: ::std::mem::MaybeUninit<GDALTriFacet> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GDALTriFacet>(),
        24usize,
        concat!("Size of: ", stringify!(GDALTriFacet))
    );
    assert_eq!(
        ::std::mem::align_of::<GDALTriFacet>(),
        4usize,
        concat!("Alignment of ", stringify!(GDALTriFacet))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).anVertexIdx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALTriFacet),
            "::",
            stringify!(anVertexIdx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).anNeighborIdx) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALTriFacet),
            "::",
            stringify!(anNeighborIdx)
        )
    );
}
#[doc = " Triangle barycentric coefficients.\n\n Conversion from cartesian (x,y) to barycentric (l1,l2,l3) with :\n  l1 = dfMul1X * (x - dfCxtX) + dfMul1Y * (y - dfCstY)\n  l2 = dfMul2X * (x - dfCxtX) + dfMul2Y * (y - dfCstY)\n  l3 = 1 - l1 - l2"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALTriBarycentricCoefficients {
    #[doc = "< dfMul1X"]
    pub dfMul1X: f64,
    #[doc = "< dfMul1Y"]
    pub dfMul1Y: f64,
    #[doc = "< dfMul2X"]
    pub dfMul2X: f64,
    #[doc = "< dfMul2Y"]
    pub dfMul2Y: f64,
    #[doc = "< dfCstX"]
    pub dfCstX: f64,
    #[doc = "< dfCstY"]
    pub dfCstY: f64,
}
#[test]
fn bindgen_test_layout_GDALTriBarycentricCoefficients() {
    const UNINIT: ::std::mem::MaybeUninit<GDALTriBarycentricCoefficients> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GDALTriBarycentricCoefficients>(),
        48usize,
        concat!("Size of: ", stringify!(GDALTriBarycentricCoefficients))
    );
    assert_eq!(
        ::std::mem::align_of::<GDALTriBarycentricCoefficients>(),
        8usize,
        concat!("Alignment of ", stringify!(GDALTriBarycentricCoefficients))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dfMul1X) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALTriBarycentricCoefficients),
            "::",
            stringify!(dfMul1X)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dfMul1Y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALTriBarycentricCoefficients),
            "::",
            stringify!(dfMul1Y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dfMul2X) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALTriBarycentricCoefficients),
            "::",
            stringify!(dfMul2X)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dfMul2Y) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALTriBarycentricCoefficients),
            "::",
            stringify!(dfMul2Y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dfCstX) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALTriBarycentricCoefficients),
            "::",
            stringify!(dfCstX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dfCstY) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALTriBarycentricCoefficients),
            "::",
            stringify!(dfCstY)
        )
    );
}
#[doc = " Triangulation structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALTriangulation {
    #[doc = "< number of facets"]
    pub nFacets: libc::c_int,
    #[doc = "< array of nFacets facets"]
    pub pasFacets: *mut GDALTriFacet,
    #[doc = "< arra of nFacets barycentric coefficients"]
    pub pasFacetCoefficients: *mut GDALTriBarycentricCoefficients,
}
#[test]
fn bindgen_test_layout_GDALTriangulation() {
    const UNINIT: ::std::mem::MaybeUninit<GDALTriangulation> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GDALTriangulation>(),
        24usize,
        concat!("Size of: ", stringify!(GDALTriangulation))
    );
    assert_eq!(
        ::std::mem::align_of::<GDALTriangulation>(),
        8usize,
        concat!("Alignment of ", stringify!(GDALTriangulation))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nFacets) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALTriangulation),
            "::",
            stringify!(nFacets)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pasFacets) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALTriangulation),
            "::",
            stringify!(pasFacets)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pasFacetCoefficients) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALTriangulation),
            "::",
            stringify!(pasFacetCoefficients)
        )
    );
}
extern "C" {
    pub fn GDALHasTriangulation() -> libc::c_int;
}
extern "C" {
    pub fn GDALTriangulationCreateDelaunay(
        nPoints: libc::c_int,
        padfX: *const f64,
        padfY: *const f64,
    ) -> *mut GDALTriangulation;
}
extern "C" {
    pub fn GDALTriangulationComputeBarycentricCoefficients(
        psDT: *mut GDALTriangulation,
        padfX: *const f64,
        padfY: *const f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALTriangulationComputeBarycentricCoordinates(
        psDT: *const GDALTriangulation,
        nFacetIdx: libc::c_int,
        dfX: f64,
        dfY: f64,
        pdfL1: *mut f64,
        pdfL2: *mut f64,
        pdfL3: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALTriangulationFindFacetBruteForce(
        psDT: *const GDALTriangulation,
        dfX: f64,
        dfY: f64,
        panOutputFacetIdx: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALTriangulationFindFacetDirected(
        psDT: *const GDALTriangulation,
        nFacetIdx: libc::c_int,
        dfX: f64,
        dfY: f64,
        panOutputFacetIdx: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALTriangulationFree(psDT: *mut GDALTriangulation);
}
extern "C" {
    #[doc = " @endcond"]
    pub fn GDALOpenVerticalShiftGrid(
        pszProj4Geoidgrids: *const libc::c_char,
        pbError: *mut libc::c_int,
    ) -> GDALDatasetH;
}
extern "C" {
    #[doc = " @endcond"]
    pub fn GDALApplyVerticalShiftGrid(
        hSrcDataset: GDALDatasetH,
        hGridDataset: GDALDatasetH,
        bInverse: libc::c_int,
        dfSrcUnitToMeter: f64,
        dfDstUnitToMeter: f64,
        papszOptions: *const *const libc::c_char,
    ) -> GDALDatasetH;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALInfoOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALInfoOptionsForBinary {
    _unused: [u8; 0],
}
extern "C" {
    pub fn GDALInfoOptionsNew(
        papszArgv: *mut *mut libc::c_char,
        psOptionsForBinary: *mut GDALInfoOptionsForBinary,
    ) -> *mut GDALInfoOptions;
}
extern "C" {
    pub fn GDALInfoOptionsFree(psOptions: *mut GDALInfoOptions);
}
extern "C" {
    pub fn GDALInfo(hDataset: GDALDatasetH, psOptions: *const GDALInfoOptions)
        -> *mut libc::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALTranslateOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALTranslateOptionsForBinary {
    _unused: [u8; 0],
}
extern "C" {
    pub fn GDALTranslateOptionsNew(
        papszArgv: *mut *mut libc::c_char,
        psOptionsForBinary: *mut GDALTranslateOptionsForBinary,
    ) -> *mut GDALTranslateOptions;
}
extern "C" {
    pub fn GDALTranslateOptionsFree(psOptions: *mut GDALTranslateOptions);
}
extern "C" {
    pub fn GDALTranslateOptionsSetProgress(
        psOptions: *mut GDALTranslateOptions,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
    );
}
extern "C" {
    pub fn GDALTranslate(
        pszDestFilename: *const libc::c_char,
        hSrcDataset: GDALDatasetH,
        psOptions: *const GDALTranslateOptions,
        pbUsageError: *mut libc::c_int,
    ) -> GDALDatasetH;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALWarpAppOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALWarpAppOptionsForBinary {
    _unused: [u8; 0],
}
extern "C" {
    pub fn GDALWarpAppOptionsNew(
        papszArgv: *mut *mut libc::c_char,
        psOptionsForBinary: *mut GDALWarpAppOptionsForBinary,
    ) -> *mut GDALWarpAppOptions;
}
extern "C" {
    pub fn GDALWarpAppOptionsFree(psOptions: *mut GDALWarpAppOptions);
}
extern "C" {
    pub fn GDALWarpAppOptionsSetProgress(
        psOptions: *mut GDALWarpAppOptions,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
    );
}
extern "C" {
    pub fn GDALWarpAppOptionsSetQuiet(psOptions: *mut GDALWarpAppOptions, bQuiet: libc::c_int);
}
extern "C" {
    pub fn GDALWarpAppOptionsSetWarpOption(
        psOptions: *mut GDALWarpAppOptions,
        pszKey: *const libc::c_char,
        pszValue: *const libc::c_char,
    );
}
extern "C" {
    pub fn GDALWarp(
        pszDest: *const libc::c_char,
        hDstDS: GDALDatasetH,
        nSrcCount: libc::c_int,
        pahSrcDS: *mut GDALDatasetH,
        psOptions: *const GDALWarpAppOptions,
        pbUsageError: *mut libc::c_int,
    ) -> GDALDatasetH;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALVectorTranslateOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALVectorTranslateOptionsForBinary {
    _unused: [u8; 0],
}
extern "C" {
    pub fn GDALVectorTranslateOptionsNew(
        papszArgv: *mut *mut libc::c_char,
        psOptionsForBinary: *mut GDALVectorTranslateOptionsForBinary,
    ) -> *mut GDALVectorTranslateOptions;
}
extern "C" {
    pub fn GDALVectorTranslateOptionsFree(psOptions: *mut GDALVectorTranslateOptions);
}
extern "C" {
    pub fn GDALVectorTranslateOptionsSetProgress(
        psOptions: *mut GDALVectorTranslateOptions,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
    );
}
extern "C" {
    pub fn GDALVectorTranslate(
        pszDest: *const libc::c_char,
        hDstDS: GDALDatasetH,
        nSrcCount: libc::c_int,
        pahSrcDS: *mut GDALDatasetH,
        psOptions: *const GDALVectorTranslateOptions,
        pbUsageError: *mut libc::c_int,
    ) -> GDALDatasetH;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALDEMProcessingOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALDEMProcessingOptionsForBinary {
    _unused: [u8; 0],
}
extern "C" {
    pub fn GDALDEMProcessingOptionsNew(
        papszArgv: *mut *mut libc::c_char,
        psOptionsForBinary: *mut GDALDEMProcessingOptionsForBinary,
    ) -> *mut GDALDEMProcessingOptions;
}
extern "C" {
    pub fn GDALDEMProcessingOptionsFree(psOptions: *mut GDALDEMProcessingOptions);
}
extern "C" {
    pub fn GDALDEMProcessingOptionsSetProgress(
        psOptions: *mut GDALDEMProcessingOptions,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
    );
}
extern "C" {
    pub fn GDALDEMProcessing(
        pszDestFilename: *const libc::c_char,
        hSrcDataset: GDALDatasetH,
        pszProcessing: *const libc::c_char,
        pszColorFilename: *const libc::c_char,
        psOptions: *const GDALDEMProcessingOptions,
        pbUsageError: *mut libc::c_int,
    ) -> GDALDatasetH;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALNearblackOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALNearblackOptionsForBinary {
    _unused: [u8; 0],
}
extern "C" {
    pub fn GDALNearblackOptionsNew(
        papszArgv: *mut *mut libc::c_char,
        psOptionsForBinary: *mut GDALNearblackOptionsForBinary,
    ) -> *mut GDALNearblackOptions;
}
extern "C" {
    pub fn GDALNearblackOptionsFree(psOptions: *mut GDALNearblackOptions);
}
extern "C" {
    pub fn GDALNearblackOptionsSetProgress(
        psOptions: *mut GDALNearblackOptions,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
    );
}
extern "C" {
    pub fn GDALNearblack(
        pszDest: *const libc::c_char,
        hDstDS: GDALDatasetH,
        hSrcDS: GDALDatasetH,
        psOptions: *const GDALNearblackOptions,
        pbUsageError: *mut libc::c_int,
    ) -> GDALDatasetH;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALGridOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALGridOptionsForBinary {
    _unused: [u8; 0],
}
extern "C" {
    pub fn GDALGridOptionsNew(
        papszArgv: *mut *mut libc::c_char,
        psOptionsForBinary: *mut GDALGridOptionsForBinary,
    ) -> *mut GDALGridOptions;
}
extern "C" {
    pub fn GDALGridOptionsFree(psOptions: *mut GDALGridOptions);
}
extern "C" {
    pub fn GDALGridOptionsSetProgress(
        psOptions: *mut GDALGridOptions,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
    );
}
extern "C" {
    pub fn GDALGrid(
        pszDest: *const libc::c_char,
        hSrcDS: GDALDatasetH,
        psOptions: *const GDALGridOptions,
        pbUsageError: *mut libc::c_int,
    ) -> GDALDatasetH;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALRasterizeOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALRasterizeOptionsForBinary {
    _unused: [u8; 0],
}
extern "C" {
    pub fn GDALRasterizeOptionsNew(
        papszArgv: *mut *mut libc::c_char,
        psOptionsForBinary: *mut GDALRasterizeOptionsForBinary,
    ) -> *mut GDALRasterizeOptions;
}
extern "C" {
    pub fn GDALRasterizeOptionsFree(psOptions: *mut GDALRasterizeOptions);
}
extern "C" {
    pub fn GDALRasterizeOptionsSetProgress(
        psOptions: *mut GDALRasterizeOptions,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
    );
}
extern "C" {
    pub fn GDALRasterize(
        pszDest: *const libc::c_char,
        hDstDS: GDALDatasetH,
        hSrcDS: GDALDatasetH,
        psOptions: *const GDALRasterizeOptions,
        pbUsageError: *mut libc::c_int,
    ) -> GDALDatasetH;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALBuildVRTOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALBuildVRTOptionsForBinary {
    _unused: [u8; 0],
}
extern "C" {
    pub fn GDALBuildVRTOptionsNew(
        papszArgv: *mut *mut libc::c_char,
        psOptionsForBinary: *mut GDALBuildVRTOptionsForBinary,
    ) -> *mut GDALBuildVRTOptions;
}
extern "C" {
    pub fn GDALBuildVRTOptionsFree(psOptions: *mut GDALBuildVRTOptions);
}
extern "C" {
    pub fn GDALBuildVRTOptionsSetProgress(
        psOptions: *mut GDALBuildVRTOptions,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
    );
}
extern "C" {
    pub fn GDALBuildVRT(
        pszDest: *const libc::c_char,
        nSrcCount: libc::c_int,
        pahSrcDS: *mut GDALDatasetH,
        papszSrcDSNames: *const *const libc::c_char,
        psOptions: *const GDALBuildVRTOptions,
        pbUsageError: *mut libc::c_int,
    ) -> GDALDatasetH;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALMultiDimInfoOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALMultiDimInfoOptionsForBinary {
    _unused: [u8; 0],
}
extern "C" {
    pub fn GDALMultiDimInfoOptionsNew(
        papszArgv: *mut *mut libc::c_char,
        psOptionsForBinary: *mut GDALMultiDimInfoOptionsForBinary,
    ) -> *mut GDALMultiDimInfoOptions;
}
extern "C" {
    pub fn GDALMultiDimInfoOptionsFree(psOptions: *mut GDALMultiDimInfoOptions);
}
extern "C" {
    pub fn GDALMultiDimInfo(
        hDataset: GDALDatasetH,
        psOptions: *const GDALMultiDimInfoOptions,
    ) -> *mut libc::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALMultiDimTranslateOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALMultiDimTranslateOptionsForBinary {
    _unused: [u8; 0],
}
extern "C" {
    pub fn GDALMultiDimTranslateOptionsNew(
        papszArgv: *mut *mut libc::c_char,
        psOptionsForBinary: *mut GDALMultiDimTranslateOptionsForBinary,
    ) -> *mut GDALMultiDimTranslateOptions;
}
extern "C" {
    pub fn GDALMultiDimTranslateOptionsFree(psOptions: *mut GDALMultiDimTranslateOptions);
}
extern "C" {
    pub fn GDALMultiDimTranslateOptionsSetProgress(
        psOptions: *mut GDALMultiDimTranslateOptions,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
    );
}
extern "C" {
    pub fn GDALMultiDimTranslate(
        pszDest: *const libc::c_char,
        hDstDataset: GDALDatasetH,
        nSrcCount: libc::c_int,
        pahSrcDS: *mut GDALDatasetH,
        psOptions: *const GDALMultiDimTranslateOptions,
        pbUsageError: *mut libc::c_int,
    ) -> GDALDatasetH;
}
pub mod OGRAxisOrientation {
    #[doc = " Axis orientations (corresponds to CS_AxisOrientationEnum)."]
    pub type Type = libc::c_uint;
    #[doc = "< Other"]
    pub const OAO_Other: Type = 0;
    #[doc = "< North"]
    pub const OAO_North: Type = 1;
    #[doc = "< South"]
    pub const OAO_South: Type = 2;
    #[doc = "< East"]
    pub const OAO_East: Type = 3;
    #[doc = "< West"]
    pub const OAO_West: Type = 4;
    #[doc = "< Up (to space)"]
    pub const OAO_Up: Type = 5;
    #[doc = "< Down (to Earth center)"]
    pub const OAO_Down: Type = 6;
}
extern "C" {
    pub fn OSRAxisEnumToName(eOrientation: OGRAxisOrientation::Type) -> *const libc::c_char;
}
extern "C" {
    pub fn OSRSetPROJSearchPaths(papszPaths: *const *const libc::c_char);
}
extern "C" {
    pub fn OSRGetPROJSearchPaths() -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn OSRSetPROJAuxDbPaths(papszPaths: *const *const libc::c_char);
}
extern "C" {
    pub fn OSRGetPROJAuxDbPaths() -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn OSRSetPROJEnableNetwork(enabled: libc::c_int);
}
extern "C" {
    pub fn OSRGetPROJEnableNetwork() -> libc::c_int;
}
extern "C" {
    pub fn OSRGetPROJVersion(
        pnMajor: *mut libc::c_int,
        pnMinor: *mut libc::c_int,
        pnPatch: *mut libc::c_int,
    );
}
extern "C" {
    pub fn OSRNewSpatialReference(arg1: *const libc::c_char) -> OGRSpatialReferenceH;
}
extern "C" {
    pub fn OSRCloneGeogCS(arg1: OGRSpatialReferenceH) -> OGRSpatialReferenceH;
}
extern "C" {
    pub fn OSRClone(arg1: OGRSpatialReferenceH) -> OGRSpatialReferenceH;
}
extern "C" {
    pub fn OSRDestroySpatialReference(arg1: OGRSpatialReferenceH);
}
extern "C" {
    pub fn OSRReference(arg1: OGRSpatialReferenceH) -> libc::c_int;
}
extern "C" {
    pub fn OSRDereference(arg1: OGRSpatialReferenceH) -> libc::c_int;
}
extern "C" {
    pub fn OSRRelease(arg1: OGRSpatialReferenceH);
}
extern "C" {
    pub fn OSRValidate(arg1: OGRSpatialReferenceH) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRImportFromEPSG(arg1: OGRSpatialReferenceH, arg2: libc::c_int) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRImportFromEPSGA(arg1: OGRSpatialReferenceH, arg2: libc::c_int) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRImportFromWkt(
        arg1: OGRSpatialReferenceH,
        arg2: *mut *mut libc::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRImportFromProj4(
        arg1: OGRSpatialReferenceH,
        arg2: *const libc::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRImportFromESRI(
        arg1: OGRSpatialReferenceH,
        arg2: *mut *mut libc::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRImportFromPCI(
        hSRS: OGRSpatialReferenceH,
        arg1: *const libc::c_char,
        arg2: *const libc::c_char,
        arg3: *mut f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRImportFromUSGS(
        arg1: OGRSpatialReferenceH,
        arg2: libc::c_long,
        arg3: libc::c_long,
        arg4: *mut f64,
        arg5: libc::c_long,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRImportFromXML(arg1: OGRSpatialReferenceH, arg2: *const libc::c_char) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRImportFromDict(
        arg1: OGRSpatialReferenceH,
        arg2: *const libc::c_char,
        arg3: *const libc::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRImportFromPanorama(
        arg1: OGRSpatialReferenceH,
        arg2: libc::c_long,
        arg3: libc::c_long,
        arg4: libc::c_long,
        arg5: *mut f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRImportFromOzi(
        arg1: OGRSpatialReferenceH,
        arg2: *const *const libc::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRImportFromMICoordSys(
        arg1: OGRSpatialReferenceH,
        arg2: *const libc::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRImportFromERM(
        arg1: OGRSpatialReferenceH,
        arg2: *const libc::c_char,
        arg3: *const libc::c_char,
        arg4: *const libc::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRImportFromUrl(arg1: OGRSpatialReferenceH, arg2: *const libc::c_char) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRExportToWkt(arg1: OGRSpatialReferenceH, arg2: *mut *mut libc::c_char)
        -> OGRErr::Type;
}
extern "C" {
    pub fn OSRExportToWktEx(
        arg1: OGRSpatialReferenceH,
        ppszResult: *mut *mut libc::c_char,
        papszOptions: *const *const libc::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRExportToPrettyWkt(
        arg1: OGRSpatialReferenceH,
        arg2: *mut *mut libc::c_char,
        arg3: libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRExportToPROJJSON(
        hSRS: OGRSpatialReferenceH,
        ppszReturn: *mut *mut libc::c_char,
        papszOptions: *const *const libc::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRExportToProj4(
        arg1: OGRSpatialReferenceH,
        arg2: *mut *mut libc::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRExportToPCI(
        arg1: OGRSpatialReferenceH,
        arg2: *mut *mut libc::c_char,
        arg3: *mut *mut libc::c_char,
        arg4: *mut *mut f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRExportToUSGS(
        arg1: OGRSpatialReferenceH,
        arg2: *mut libc::c_long,
        arg3: *mut libc::c_long,
        arg4: *mut *mut f64,
        arg5: *mut libc::c_long,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRExportToXML(
        arg1: OGRSpatialReferenceH,
        arg2: *mut *mut libc::c_char,
        arg3: *const libc::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRExportToPanorama(
        arg1: OGRSpatialReferenceH,
        arg2: *mut libc::c_long,
        arg3: *mut libc::c_long,
        arg4: *mut libc::c_long,
        arg5: *mut libc::c_long,
        arg6: *mut f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRExportToMICoordSys(
        arg1: OGRSpatialReferenceH,
        arg2: *mut *mut libc::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRExportToERM(
        arg1: OGRSpatialReferenceH,
        arg2: *mut libc::c_char,
        arg3: *mut libc::c_char,
        arg4: *mut libc::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRMorphToESRI(arg1: OGRSpatialReferenceH) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRMorphFromESRI(arg1: OGRSpatialReferenceH) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRStripVertical(arg1: OGRSpatialReferenceH) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRConvertToOtherProjection(
        hSRS: OGRSpatialReferenceH,
        pszTargetProjection: *const libc::c_char,
        papszOptions: *const *const libc::c_char,
    ) -> OGRSpatialReferenceH;
}
extern "C" {
    pub fn OSRGetName(hSRS: OGRSpatialReferenceH) -> *const libc::c_char;
}
extern "C" {
    pub fn OSRSetAttrValue(
        hSRS: OGRSpatialReferenceH,
        pszNodePath: *const libc::c_char,
        pszNewNodeValue: *const libc::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRGetAttrValue(
        hSRS: OGRSpatialReferenceH,
        pszName: *const libc::c_char,
        iChild: libc::c_int,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn OSRSetAngularUnits(
        arg1: OGRSpatialReferenceH,
        arg2: *const libc::c_char,
        arg3: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRGetAngularUnits(arg1: OGRSpatialReferenceH, arg2: *mut *mut libc::c_char) -> f64;
}
extern "C" {
    pub fn OSRSetLinearUnits(
        arg1: OGRSpatialReferenceH,
        arg2: *const libc::c_char,
        arg3: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetTargetLinearUnits(
        arg1: OGRSpatialReferenceH,
        arg2: *const libc::c_char,
        arg3: *const libc::c_char,
        arg4: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetLinearUnitsAndUpdateParameters(
        arg1: OGRSpatialReferenceH,
        arg2: *const libc::c_char,
        arg3: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRGetLinearUnits(arg1: OGRSpatialReferenceH, arg2: *mut *mut libc::c_char) -> f64;
}
extern "C" {
    pub fn OSRGetTargetLinearUnits(
        arg1: OGRSpatialReferenceH,
        arg2: *const libc::c_char,
        arg3: *mut *mut libc::c_char,
    ) -> f64;
}
extern "C" {
    pub fn OSRGetPrimeMeridian(arg1: OGRSpatialReferenceH, arg2: *mut *mut libc::c_char) -> f64;
}
extern "C" {
    pub fn OSRIsGeographic(arg1: OGRSpatialReferenceH) -> libc::c_int;
}
extern "C" {
    pub fn OSRIsDerivedGeographic(arg1: OGRSpatialReferenceH) -> libc::c_int;
}
extern "C" {
    pub fn OSRIsLocal(arg1: OGRSpatialReferenceH) -> libc::c_int;
}
extern "C" {
    pub fn OSRIsProjected(arg1: OGRSpatialReferenceH) -> libc::c_int;
}
extern "C" {
    pub fn OSRIsCompound(arg1: OGRSpatialReferenceH) -> libc::c_int;
}
extern "C" {
    pub fn OSRIsGeocentric(arg1: OGRSpatialReferenceH) -> libc::c_int;
}
extern "C" {
    pub fn OSRIsVertical(arg1: OGRSpatialReferenceH) -> libc::c_int;
}
extern "C" {
    pub fn OSRIsDynamic(arg1: OGRSpatialReferenceH) -> libc::c_int;
}
extern "C" {
    pub fn OSRIsSameGeogCS(arg1: OGRSpatialReferenceH, arg2: OGRSpatialReferenceH) -> libc::c_int;
}
extern "C" {
    pub fn OSRIsSameVertCS(arg1: OGRSpatialReferenceH, arg2: OGRSpatialReferenceH) -> libc::c_int;
}
extern "C" {
    pub fn OSRIsSame(arg1: OGRSpatialReferenceH, arg2: OGRSpatialReferenceH) -> libc::c_int;
}
extern "C" {
    pub fn OSRIsSameEx(
        arg1: OGRSpatialReferenceH,
        arg2: OGRSpatialReferenceH,
        papszOptions: *const *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OSRSetCoordinateEpoch(hSRS: OGRSpatialReferenceH, dfCoordinateEpoch: f64);
}
extern "C" {
    pub fn OSRGetCoordinateEpoch(hSRS: OGRSpatialReferenceH) -> f64;
}
extern "C" {
    pub fn OSRSetLocalCS(hSRS: OGRSpatialReferenceH, pszName: *const libc::c_char) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetProjCS(hSRS: OGRSpatialReferenceH, pszName: *const libc::c_char) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetGeocCS(hSRS: OGRSpatialReferenceH, pszName: *const libc::c_char) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetWellKnownGeogCS(
        hSRS: OGRSpatialReferenceH,
        pszName: *const libc::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetFromUserInput(
        hSRS: OGRSpatialReferenceH,
        arg1: *const libc::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRCopyGeogCSFrom(
        hSRS: OGRSpatialReferenceH,
        hSrcSRS: OGRSpatialReferenceH,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetTOWGS84(
        hSRS: OGRSpatialReferenceH,
        arg1: f64,
        arg2: f64,
        arg3: f64,
        arg4: f64,
        arg5: f64,
        arg6: f64,
        arg7: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRGetTOWGS84(
        hSRS: OGRSpatialReferenceH,
        arg1: *mut f64,
        arg2: libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRAddGuessedTOWGS84(hSRS: OGRSpatialReferenceH) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetCompoundCS(
        hSRS: OGRSpatialReferenceH,
        pszName: *const libc::c_char,
        hHorizSRS: OGRSpatialReferenceH,
        hVertSRS: OGRSpatialReferenceH,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRPromoteTo3D(hSRS: OGRSpatialReferenceH, pszName: *const libc::c_char)
        -> OGRErr::Type;
}
extern "C" {
    pub fn OSRDemoteTo2D(hSRS: OGRSpatialReferenceH, pszName: *const libc::c_char) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetGeogCS(
        hSRS: OGRSpatialReferenceH,
        pszGeogName: *const libc::c_char,
        pszDatumName: *const libc::c_char,
        pszEllipsoidName: *const libc::c_char,
        dfSemiMajor: f64,
        dfInvFlattening: f64,
        pszPMName: *const libc::c_char,
        dfPMOffset: f64,
        pszUnits: *const libc::c_char,
        dfConvertToRadians: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetVertCS(
        hSRS: OGRSpatialReferenceH,
        pszVertCSName: *const libc::c_char,
        pszVertDatumName: *const libc::c_char,
        nVertDatumType: libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRGetSemiMajor(arg1: OGRSpatialReferenceH, arg2: *mut OGRErr::Type) -> f64;
}
extern "C" {
    pub fn OSRGetSemiMinor(arg1: OGRSpatialReferenceH, arg2: *mut OGRErr::Type) -> f64;
}
extern "C" {
    pub fn OSRGetInvFlattening(arg1: OGRSpatialReferenceH, arg2: *mut OGRErr::Type) -> f64;
}
extern "C" {
    pub fn OSRSetAuthority(
        hSRS: OGRSpatialReferenceH,
        pszTargetKey: *const libc::c_char,
        pszAuthority: *const libc::c_char,
        nCode: libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRGetAuthorityCode(
        hSRS: OGRSpatialReferenceH,
        pszTargetKey: *const libc::c_char,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn OSRGetAuthorityName(
        hSRS: OGRSpatialReferenceH,
        pszTargetKey: *const libc::c_char,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn OSRGetAreaOfUse(
        hSRS: OGRSpatialReferenceH,
        pdfWestLongitudeDeg: *mut f64,
        pdfSouthLatitudeDeg: *mut f64,
        pdfEastLongitudeDeg: *mut f64,
        pdfNorthLatitudeDeg: *mut f64,
        ppszAreaName: *mut *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OSRSetProjection(arg1: OGRSpatialReferenceH, arg2: *const libc::c_char) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetProjParm(
        arg1: OGRSpatialReferenceH,
        arg2: *const libc::c_char,
        arg3: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRGetProjParm(
        hSRS: OGRSpatialReferenceH,
        pszParamName: *const libc::c_char,
        dfDefault: f64,
        arg1: *mut OGRErr::Type,
    ) -> f64;
}
extern "C" {
    pub fn OSRSetNormProjParm(
        arg1: OGRSpatialReferenceH,
        arg2: *const libc::c_char,
        arg3: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRGetNormProjParm(
        hSRS: OGRSpatialReferenceH,
        pszParamName: *const libc::c_char,
        dfDefault: f64,
        arg1: *mut OGRErr::Type,
    ) -> f64;
}
extern "C" {
    pub fn OSRSetUTM(
        hSRS: OGRSpatialReferenceH,
        nZone: libc::c_int,
        bNorth: libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRGetUTMZone(hSRS: OGRSpatialReferenceH, pbNorth: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn OSRSetStatePlane(
        hSRS: OGRSpatialReferenceH,
        nZone: libc::c_int,
        bNAD83: libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetStatePlaneWithUnits(
        hSRS: OGRSpatialReferenceH,
        nZone: libc::c_int,
        bNAD83: libc::c_int,
        pszOverrideUnitName: *const libc::c_char,
        dfOverrideUnit: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRAutoIdentifyEPSG(hSRS: OGRSpatialReferenceH) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRFindMatches(
        hSRS: OGRSpatialReferenceH,
        papszOptions: *mut *mut libc::c_char,
        pnEntries: *mut libc::c_int,
        ppanMatchConfidence: *mut *mut libc::c_int,
    ) -> *mut OGRSpatialReferenceH;
}
extern "C" {
    pub fn OSRFreeSRSArray(pahSRS: *mut OGRSpatialReferenceH);
}
extern "C" {
    pub fn OSREPSGTreatsAsLatLong(hSRS: OGRSpatialReferenceH) -> libc::c_int;
}
extern "C" {
    pub fn OSREPSGTreatsAsNorthingEasting(hSRS: OGRSpatialReferenceH) -> libc::c_int;
}
extern "C" {
    pub fn OSRGetAxis(
        hSRS: OGRSpatialReferenceH,
        pszTargetKey: *const libc::c_char,
        iAxis: libc::c_int,
        peOrientation: *mut OGRAxisOrientation::Type,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn OSRGetAxesCount(hSRS: OGRSpatialReferenceH) -> libc::c_int;
}
extern "C" {
    pub fn OSRSetAxes(
        hSRS: OGRSpatialReferenceH,
        pszTargetKey: *const libc::c_char,
        pszXAxisName: *const libc::c_char,
        eXAxisOrientation: OGRAxisOrientation::Type,
        pszYAxisName: *const libc::c_char,
        eYAxisOrientation: OGRAxisOrientation::Type,
    ) -> OGRErr::Type;
}
pub mod OSRAxisMappingStrategy {
    #[doc = " Data axis to CRS axis mapping strategy."]
    pub type Type = libc::c_uint;
    #[doc = "< Traditional GIS order"]
    pub const OAMS_TRADITIONAL_GIS_ORDER: Type = 0;
    #[doc = "< Compliant with the order mandated by the CRS authority"]
    pub const OAMS_AUTHORITY_COMPLIANT: Type = 1;
    #[doc = "< Custom"]
    pub const OAMS_CUSTOM: Type = 2;
}
extern "C" {
    pub fn OSRGetAxisMappingStrategy(hSRS: OGRSpatialReferenceH) -> OSRAxisMappingStrategy::Type;
}
extern "C" {
    pub fn OSRSetAxisMappingStrategy(
        hSRS: OGRSpatialReferenceH,
        strategy: OSRAxisMappingStrategy::Type,
    );
}
extern "C" {
    pub fn OSRGetDataAxisToSRSAxisMapping(
        hSRS: OGRSpatialReferenceH,
        pnCount: *mut libc::c_int,
    ) -> *const libc::c_int;
}
extern "C" {
    pub fn OSRSetDataAxisToSRSAxisMapping(
        hSRS: OGRSpatialReferenceH,
        nMappingSize: libc::c_int,
        panMapping: *const libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Albers Conic Equal Area"]
    pub fn OSRSetACEA(
        hSRS: OGRSpatialReferenceH,
        dfStdP1: f64,
        dfStdP2: f64,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Azimuthal Equidistant"]
    pub fn OSRSetAE(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Bonne"]
    pub fn OSRSetBonne(
        hSRS: OGRSpatialReferenceH,
        dfStandardParallel: f64,
        dfCentralMeridian: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Cylindrical Equal Area"]
    pub fn OSRSetCEA(
        hSRS: OGRSpatialReferenceH,
        dfStdP1: f64,
        dfCentralMeridian: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Cassini-Soldner"]
    pub fn OSRSetCS(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Equidistant Conic"]
    pub fn OSRSetEC(
        hSRS: OGRSpatialReferenceH,
        dfStdP1: f64,
        dfStdP2: f64,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Eckert I-VI"]
    pub fn OSRSetEckert(
        hSRS: OGRSpatialReferenceH,
        nVariation: libc::c_int,
        dfCentralMeridian: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Eckert IV"]
    pub fn OSRSetEckertIV(
        hSRS: OGRSpatialReferenceH,
        dfCentralMeridian: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Eckert VI"]
    pub fn OSRSetEckertVI(
        hSRS: OGRSpatialReferenceH,
        dfCentralMeridian: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Equirectangular"]
    pub fn OSRSetEquirectangular(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Equirectangular generalized form"]
    pub fn OSRSetEquirectangular2(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfPseudoStdParallel1: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Gall Stereograpic"]
    pub fn OSRSetGS(
        hSRS: OGRSpatialReferenceH,
        dfCentralMeridian: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Goode Homolosine"]
    pub fn OSRSetGH(
        hSRS: OGRSpatialReferenceH,
        dfCentralMeridian: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Interrupted Goode Homolosine"]
    pub fn OSRSetIGH(hSRS: OGRSpatialReferenceH) -> OGRErr::Type;
}
extern "C" {
    #[doc = " GEOS - Geostationary Satellite View"]
    pub fn OSRSetGEOS(
        hSRS: OGRSpatialReferenceH,
        dfCentralMeridian: f64,
        dfSatelliteHeight: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Gauss Schreiber Transverse Mercator"]
    pub fn OSRSetGaussSchreiberTMercator(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfScale: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Gnomonic"]
    pub fn OSRSetGnomonic(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Hotine Oblique Mercator using azimuth angle"]
    pub fn OSRSetHOM(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfAzimuth: f64,
        dfRectToSkew: f64,
        dfScale: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetHOMAC(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfAzimuth: f64,
        dfRectToSkew: f64,
        dfScale: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Hotine Oblique Mercator using two points on centerline"]
    pub fn OSRSetHOM2PNO(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfLat1: f64,
        dfLong1: f64,
        dfLat2: f64,
        dfLong2: f64,
        dfScale: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " International Map of the World Polyconic"]
    pub fn OSRSetIWMPolyconic(
        hSRS: OGRSpatialReferenceH,
        dfLat1: f64,
        dfLat2: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Krovak Oblique Conic Conformal"]
    pub fn OSRSetKrovak(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfAzimuth: f64,
        dfPseudoStdParallelLat: f64,
        dfScale: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Lambert Azimuthal Equal-Area"]
    pub fn OSRSetLAEA(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Lambert Conformal Conic"]
    pub fn OSRSetLCC(
        hSRS: OGRSpatialReferenceH,
        dfStdP1: f64,
        dfStdP2: f64,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Lambert Conformal Conic 1SP"]
    pub fn OSRSetLCC1SP(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfScale: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Lambert Conformal Conic (Belgium)"]
    pub fn OSRSetLCCB(
        hSRS: OGRSpatialReferenceH,
        dfStdP1: f64,
        dfStdP2: f64,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Miller Cylindrical"]
    pub fn OSRSetMC(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Mercator"]
    pub fn OSRSetMercator(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfScale: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Mercator 2SP"]
    pub fn OSRSetMercator2SP(
        hSRS: OGRSpatialReferenceH,
        dfStdP1: f64,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Mollweide"]
    pub fn OSRSetMollweide(
        hSRS: OGRSpatialReferenceH,
        dfCentralMeridian: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " New Zealand Map Grid"]
    pub fn OSRSetNZMG(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Oblique Stereographic"]
    pub fn OSRSetOS(
        hSRS: OGRSpatialReferenceH,
        dfOriginLat: f64,
        dfCMeridian: f64,
        dfScale: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Orthographic"]
    pub fn OSRSetOrthographic(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Polyconic"]
    pub fn OSRSetPolyconic(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Polar Stereographic"]
    pub fn OSRSetPS(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfScale: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Robinson"]
    pub fn OSRSetRobinson(
        hSRS: OGRSpatialReferenceH,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Sinusoidal"]
    pub fn OSRSetSinusoidal(
        hSRS: OGRSpatialReferenceH,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Stereographic"]
    pub fn OSRSetStereographic(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfScale: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Swiss Oblique Cylindrical"]
    pub fn OSRSetSOC(
        hSRS: OGRSpatialReferenceH,
        dfLatitudeOfOrigin: f64,
        dfCentralMeridian: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Transverse Mercator\n\n Special processing available for Transverse Mercator with GDAL &gt;= 1.10 and PROJ &gt;= 4.8 :\n see OGRSpatialReference::exportToProj4()."]
    pub fn OSRSetTM(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfScale: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Transverse Mercator variant"]
    pub fn OSRSetTMVariant(
        hSRS: OGRSpatialReferenceH,
        pszVariantName: *const libc::c_char,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfScale: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Tunesia Mining Grid"]
    pub fn OSRSetTMG(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Transverse Mercator (South Oriented)"]
    pub fn OSRSetTMSO(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfScale: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " TPED (Two Point Equi Distant)"]
    pub fn OSRSetTPED(
        hSRS: OGRSpatialReferenceH,
        dfLat1: f64,
        dfLong1: f64,
        dfLat2: f64,
        dfLong2: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " VanDerGrinten"]
    pub fn OSRSetVDG(
        hSRS: OGRSpatialReferenceH,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Wagner I -- VII"]
    pub fn OSRSetWagner(
        hSRS: OGRSpatialReferenceH,
        nVariation: libc::c_int,
        dfCenterLat: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Quadrilateralized Spherical Cube"]
    pub fn OSRSetQSC(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Spherical, Cross-track, Height"]
    pub fn OSRSetSCH(
        hSRS: OGRSpatialReferenceH,
        dfPegLat: f64,
        dfPegLong: f64,
        dfPegHeading: f64,
        dfPegHgt: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    #[doc = " Vertical Perspective / Near-sided Perspective"]
    pub fn OSRSetVerticalPerspective(
        hSRS: OGRSpatialReferenceH,
        dfTopoOriginLat: f64,
        dfTopoOriginLon: f64,
        dfTopoOriginHeight: f64,
        dfViewPointHeight: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRCalcInvFlattening(dfSemiMajor: f64, dfSemiMinor: f64) -> f64;
}
extern "C" {
    pub fn OSRCalcSemiMinorFromInvFlattening(dfSemiMajor: f64, dfInvFlattening: f64) -> f64;
}
extern "C" {
    pub fn OSRCleanup();
}
pub mod OSRCRSType {
    #[doc = " \\brief Type of Coordinate Reference System (CRS)."]
    pub type Type = libc::c_uint;
    #[doc = " Geographic 2D CRS"]
    pub const OSR_CRS_TYPE_GEOGRAPHIC_2D: Type = 0;
    #[doc = " Geographic 3D CRS"]
    pub const OSR_CRS_TYPE_GEOGRAPHIC_3D: Type = 1;
    #[doc = " Geocentric CRS"]
    pub const OSR_CRS_TYPE_GEOCENTRIC: Type = 2;
    #[doc = " Projected CRS"]
    pub const OSR_CRS_TYPE_PROJECTED: Type = 3;
    #[doc = " Vertical CRS"]
    pub const OSR_CRS_TYPE_VERTICAL: Type = 4;
    #[doc = " Compound CRS"]
    pub const OSR_CRS_TYPE_COMPOUND: Type = 5;
    #[doc = " Other"]
    pub const OSR_CRS_TYPE_OTHER: Type = 6;
}
#[doc = " \\brief Structure given overall description of a CRS.\n\n This structure may grow over time, and should not be directly allocated by\n client code."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSRCRSInfo {
    #[doc = " Authority name."]
    pub pszAuthName: *mut libc::c_char,
    #[doc = " Object code."]
    pub pszCode: *mut libc::c_char,
    #[doc = " Object name."]
    pub pszName: *mut libc::c_char,
    #[doc = " Object type."]
    pub eType: OSRCRSType::Type,
    #[doc = " Whether the object is deprecated"]
    pub bDeprecated: libc::c_int,
    #[doc = " Whereas the west_lon_degree, south_lat_degree, east_lon_degree and\n north_lat_degree fields are valid."]
    pub bBboxValid: libc::c_int,
    #[doc = " Western-most longitude of the area of use, in degrees."]
    pub dfWestLongitudeDeg: f64,
    #[doc = " Southern-most latitude of the area of use, in degrees."]
    pub dfSouthLatitudeDeg: f64,
    #[doc = " Eastern-most longitude of the area of use, in degrees."]
    pub dfEastLongitudeDeg: f64,
    #[doc = " Northern-most latitude of the area of use, in degrees."]
    pub dfNorthLatitudeDeg: f64,
    #[doc = " Name of the area of use."]
    pub pszAreaName: *mut libc::c_char,
    #[doc = " Name of the projection method for a projected CRS. Might be NULL even\nfor projected CRS in some cases."]
    pub pszProjectionMethod: *mut libc::c_char,
}
#[test]
fn bindgen_test_layout_OSRCRSInfo() {
    const UNINIT: ::std::mem::MaybeUninit<OSRCRSInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OSRCRSInfo>(),
        88usize,
        concat!("Size of: ", stringify!(OSRCRSInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<OSRCRSInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(OSRCRSInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pszAuthName) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSRCRSInfo),
            "::",
            stringify!(pszAuthName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pszCode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OSRCRSInfo),
            "::",
            stringify!(pszCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pszName) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OSRCRSInfo),
            "::",
            stringify!(pszName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eType) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(OSRCRSInfo),
            "::",
            stringify!(eType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bDeprecated) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(OSRCRSInfo),
            "::",
            stringify!(bDeprecated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bBboxValid) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(OSRCRSInfo),
            "::",
            stringify!(bBboxValid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dfWestLongitudeDeg) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(OSRCRSInfo),
            "::",
            stringify!(dfWestLongitudeDeg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dfSouthLatitudeDeg) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(OSRCRSInfo),
            "::",
            stringify!(dfSouthLatitudeDeg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dfEastLongitudeDeg) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(OSRCRSInfo),
            "::",
            stringify!(dfEastLongitudeDeg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dfNorthLatitudeDeg) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(OSRCRSInfo),
            "::",
            stringify!(dfNorthLatitudeDeg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pszAreaName) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(OSRCRSInfo),
            "::",
            stringify!(pszAreaName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pszProjectionMethod) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(OSRCRSInfo),
            "::",
            stringify!(pszProjectionMethod)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSRCRSListParameters {
    _unused: [u8; 0],
}
extern "C" {
    pub fn OSRGetCRSInfoListFromDatabase(
        pszAuthName: *const libc::c_char,
        params: *const OSRCRSListParameters,
        pnOutResultCount: *mut libc::c_int,
    ) -> *mut *mut OSRCRSInfo;
}
extern "C" {
    pub fn OSRDestroyCRSInfoList(list: *mut *mut OSRCRSInfo);
}
extern "C" {
    pub fn OCTNewCoordinateTransformation(
        hSourceSRS: OGRSpatialReferenceH,
        hTargetSRS: OGRSpatialReferenceH,
    ) -> OGRCoordinateTransformationH;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OGRCoordinateTransformationOptions {
    _unused: [u8; 0],
}
#[doc = " Coordinate transformation options."]
pub type OGRCoordinateTransformationOptionsH = *mut OGRCoordinateTransformationOptions;
extern "C" {
    pub fn OCTNewCoordinateTransformationOptions() -> OGRCoordinateTransformationOptionsH;
}
extern "C" {
    pub fn OCTCoordinateTransformationOptionsSetOperation(
        hOptions: OGRCoordinateTransformationOptionsH,
        pszCO: *const libc::c_char,
        bReverseCO: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OCTCoordinateTransformationOptionsSetAreaOfInterest(
        hOptions: OGRCoordinateTransformationOptionsH,
        dfWestLongitudeDeg: f64,
        dfSouthLatitudeDeg: f64,
        dfEastLongitudeDeg: f64,
        dfNorthLatitudeDeg: f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OCTCoordinateTransformationOptionsSetDesiredAccuracy(
        hOptions: OGRCoordinateTransformationOptionsH,
        dfAccuracy: f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OCTCoordinateTransformationOptionsSetBallparkAllowed(
        hOptions: OGRCoordinateTransformationOptionsH,
        bAllowBallpark: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OCTDestroyCoordinateTransformationOptions(arg1: OGRCoordinateTransformationOptionsH);
}
extern "C" {
    pub fn OCTNewCoordinateTransformationEx(
        hSourceSRS: OGRSpatialReferenceH,
        hTargetSRS: OGRSpatialReferenceH,
        hOptions: OGRCoordinateTransformationOptionsH,
    ) -> OGRCoordinateTransformationH;
}
extern "C" {
    pub fn OCTClone(hTransform: OGRCoordinateTransformationH) -> OGRCoordinateTransformationH;
}
extern "C" {
    pub fn OCTGetSourceCS(hTransform: OGRCoordinateTransformationH) -> OGRSpatialReferenceH;
}
extern "C" {
    pub fn OCTGetTargetCS(hTransform: OGRCoordinateTransformationH) -> OGRSpatialReferenceH;
}
extern "C" {
    pub fn OCTGetInverse(hTransform: OGRCoordinateTransformationH) -> OGRCoordinateTransformationH;
}
extern "C" {
    pub fn OCTDestroyCoordinateTransformation(arg1: OGRCoordinateTransformationH);
}
extern "C" {
    pub fn OCTTransform(
        hCT: OGRCoordinateTransformationH,
        nCount: libc::c_int,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OCTTransformEx(
        hCT: OGRCoordinateTransformationH,
        nCount: libc::c_int,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
        pabSuccess: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OCTTransform4D(
        hCT: OGRCoordinateTransformationH,
        nCount: libc::c_int,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
        t: *mut f64,
        pabSuccess: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OCTTransform4DWithErrorCodes(
        hCT: OGRCoordinateTransformationH,
        nCount: libc::c_int,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
        t: *mut f64,
        panErrorCodes: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OCTTransformBounds(
        hCT: OGRCoordinateTransformationH,
        xmin: f64,
        ymin: f64,
        xmax: f64,
        ymax: f64,
        out_xmin: *mut f64,
        out_ymin: *mut f64,
        out_xmax: *mut f64,
        out_ymax: *mut f64,
        densify_pts: libc::c_int,
    ) -> libc::c_int;
}
pub type CPLThreadFunc = ::std::option::Option<unsafe extern "C" fn(arg1: *mut libc::c_void)>;
extern "C" {
    pub fn CPLLockFile(pszPath: *const libc::c_char, dfWaitInSeconds: f64) -> *mut libc::c_void;
}
extern "C" {
    pub fn CPLUnlockFile(hLock: *mut libc::c_void);
}
extern "C" {
    pub fn CPLCreateMutex() -> *mut libc::c_void;
}
extern "C" {
    pub fn CPLCreateMutexEx(nOptions: libc::c_int) -> *mut libc::c_void;
}
extern "C" {
    pub fn CPLCreateOrAcquireMutex(
        arg1: *mut *mut libc::c_void,
        dfWaitInSeconds: f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CPLCreateOrAcquireMutexEx(
        arg1: *mut *mut libc::c_void,
        dfWaitInSeconds: f64,
        nOptions: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CPLAcquireMutex(hMutex: *mut libc::c_void, dfWaitInSeconds: f64) -> libc::c_int;
}
extern "C" {
    pub fn CPLReleaseMutex(hMutex: *mut libc::c_void);
}
extern "C" {
    pub fn CPLDestroyMutex(hMutex: *mut libc::c_void);
}
extern "C" {
    pub fn CPLCleanupMasterMutex();
}
extern "C" {
    pub fn CPLCreateCond() -> *mut libc::c_void;
}
extern "C" {
    pub fn CPLCondWait(hCond: *mut libc::c_void, hMutex: *mut libc::c_void);
}
pub mod CPLCondTimedWaitReason {
    pub type Type = libc::c_uint;
    pub const COND_TIMED_WAIT_COND: Type = 0;
    pub const COND_TIMED_WAIT_TIME_OUT: Type = 1;
    pub const COND_TIMED_WAIT_OTHER: Type = 2;
}
extern "C" {
    pub fn CPLCondTimedWait(
        hCond: *mut libc::c_void,
        hMutex: *mut libc::c_void,
        dfWaitInSeconds: f64,
    ) -> CPLCondTimedWaitReason::Type;
}
extern "C" {
    pub fn CPLCondSignal(hCond: *mut libc::c_void);
}
extern "C" {
    pub fn CPLCondBroadcast(hCond: *mut libc::c_void);
}
extern "C" {
    pub fn CPLDestroyCond(hCond: *mut libc::c_void);
}
extern "C" {
    #[doc = " Contrary to what its name suggests, CPLGetPID() actually returns the thread id"]
    pub fn CPLGetPID() -> GIntBig;
}
extern "C" {
    pub fn CPLGetCurrentProcessID() -> libc::c_int;
}
extern "C" {
    pub fn CPLCreateThread(pfnMain: CPLThreadFunc, pArg: *mut libc::c_void) -> libc::c_int;
}
extern "C" {
    pub fn CPLCreateJoinableThread(
        pfnMain: CPLThreadFunc,
        pArg: *mut libc::c_void,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn CPLJoinThread(hJoinableThread: *mut libc::c_void);
}
extern "C" {
    pub fn CPLSleep(dfWaitInSeconds: f64);
}
extern "C" {
    pub fn CPLGetThreadingModel() -> *const libc::c_char;
}
extern "C" {
    pub fn CPLGetNumCPUs() -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CPLLock {
    _unused: [u8; 0],
}
pub type CPLLock = _CPLLock;
pub mod CPLLockType {
    pub type Type = libc::c_uint;
    pub const LOCK_RECURSIVE_MUTEX: Type = 0;
    pub const LOCK_ADAPTIVE_MUTEX: Type = 1;
    pub const LOCK_SPIN: Type = 2;
}
extern "C" {
    pub fn CPLCreateLock(eType: CPLLockType::Type) -> *mut CPLLock;
}
extern "C" {
    pub fn CPLCreateOrAcquireLock(arg1: *mut *mut CPLLock, eType: CPLLockType::Type)
        -> libc::c_int;
}
extern "C" {
    pub fn CPLAcquireLock(arg1: *mut CPLLock) -> libc::c_int;
}
extern "C" {
    pub fn CPLReleaseLock(arg1: *mut CPLLock);
}
extern "C" {
    pub fn CPLDestroyLock(arg1: *mut CPLLock);
}
extern "C" {
    pub fn CPLLockSetDebugPerf(arg1: *mut CPLLock, bEnableIn: libc::c_int);
}
extern "C" {
    pub fn CPLGetTLS(nIndex: libc::c_int) -> *mut libc::c_void;
}
extern "C" {
    pub fn CPLGetTLSEx(
        nIndex: libc::c_int,
        pbMemoryErrorOccurred: *mut libc::c_int,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn CPLSetTLS(nIndex: libc::c_int, pData: *mut libc::c_void, bFreeOnExit: libc::c_int);
}
pub type CPLTLSFreeFunc = ::std::option::Option<unsafe extern "C" fn(pData: *mut libc::c_void)>;
extern "C" {
    pub fn CPLSetTLSWithFreeFunc(
        nIndex: libc::c_int,
        pData: *mut libc::c_void,
        pfnFree: CPLTLSFreeFunc,
    );
}
extern "C" {
    pub fn CPLSetTLSWithFreeFuncEx(
        nIndex: libc::c_int,
        pData: *mut libc::c_void,
        pfnFree: CPLTLSFreeFunc,
        pbMemoryErrorOccurred: *mut libc::c_int,
    );
}
extern "C" {
    pub fn CPLCleanupTLS();
}
pub mod GDALResampleAlg {
    #[doc = " Warp Resampling Algorithm"]
    pub type Type = libc::c_uint;
    #[doc = " Nearest neighbour (select on one input pixel)"]
    pub const GRA_NearestNeighbour: Type = 0;
    #[doc = " Bilinear (2x2 kernel)"]
    pub const GRA_Bilinear: Type = 1;
    #[doc = " Cubic Convolution Approximation (4x4 kernel)"]
    pub const GRA_Cubic: Type = 2;
    #[doc = " Cubic B-Spline Approximation (4x4 kernel)"]
    pub const GRA_CubicSpline: Type = 3;
    #[doc = " Lanczos windowed sinc interpolation (6x6 kernel)"]
    pub const GRA_Lanczos: Type = 4;
    #[doc = " Average (computes the weighted average of all non-NODATA contributing pixels)"]
    pub const GRA_Average: Type = 5;
    #[doc = " Mode (selects the value which appears most often of all the sampled points)"]
    pub const GRA_Mode: Type = 6;
    #[doc = " Max (selects maximum of all non-NODATA contributing pixels)"]
    pub const GRA_Max: Type = 8;
    #[doc = " Min (selects minimum of all non-NODATA contributing pixels)"]
    pub const GRA_Min: Type = 9;
    #[doc = " Med (selects median of all non-NODATA contributing pixels)"]
    pub const GRA_Med: Type = 10;
    #[doc = " Q1 (selects first quartile of all non-NODATA contributing pixels)"]
    pub const GRA_Q1: Type = 11;
    #[doc = " Q3 (selects third quartile of all non-NODATA contributing pixels)"]
    pub const GRA_Q3: Type = 12;
    #[doc = " Sum (weighed sum of all non-NODATA contributing pixels). Added in GDAL 3.1"]
    pub const GRA_Sum: Type = 13;
    #[doc = " RMS (weighted root mean square (quadratic mean) of all non-NODATA contributing pixels)"]
    pub const GRA_RMS: Type = 14;
    #[doc = " @cond Doxygen_Suppress"]
    pub const GRA_LAST_VALUE: Type = 14;
}
#[doc = " @cond Doxygen_Suppress"]
pub type GDALMaskFunc = ::std::option::Option<
    unsafe extern "C" fn(
        pMaskFuncArg: *mut libc::c_void,
        nBandCount: libc::c_int,
        eType: GDALDataType::Type,
        nXOff: libc::c_int,
        nYOff: libc::c_int,
        nXSize: libc::c_int,
        nYSize: libc::c_int,
        papabyImageData: *mut *mut GByte,
        bMaskIsFloat: libc::c_int,
        pMask: *mut libc::c_void,
    ) -> libc::c_int,
>;
extern "C" {
    pub fn GDALWarpNoDataMasker(
        pMaskFuncArg: *mut libc::c_void,
        nBandCount: libc::c_int,
        eType: GDALDataType::Type,
        nXOff: libc::c_int,
        nYOff: libc::c_int,
        nXSize: libc::c_int,
        nYSize: libc::c_int,
        papabyImageData: *mut *mut GByte,
        bMaskIsFloat: libc::c_int,
        pValidityMask: *mut libc::c_void,
        pbOutAllValid: *mut libc::c_int,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALWarpDstAlphaMasker(
        pMaskFuncArg: *mut libc::c_void,
        nBandCount: libc::c_int,
        eType: GDALDataType::Type,
        nXOff: libc::c_int,
        nYOff: libc::c_int,
        nXSize: libc::c_int,
        nYSize: libc::c_int,
        arg1: *mut *mut GByte,
        bMaskIsFloat: libc::c_int,
        pValidityMask: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALWarpSrcAlphaMasker(
        pMaskFuncArg: *mut libc::c_void,
        nBandCount: libc::c_int,
        eType: GDALDataType::Type,
        nXOff: libc::c_int,
        nYOff: libc::c_int,
        nXSize: libc::c_int,
        nYSize: libc::c_int,
        arg1: *mut *mut GByte,
        bMaskIsFloat: libc::c_int,
        pValidityMask: *mut libc::c_void,
        pbOutAllOpaque: *mut libc::c_int,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALWarpSrcMaskMasker(
        pMaskFuncArg: *mut libc::c_void,
        nBandCount: libc::c_int,
        eType: GDALDataType::Type,
        nXOff: libc::c_int,
        nYOff: libc::c_int,
        nXSize: libc::c_int,
        nYSize: libc::c_int,
        arg1: *mut *mut GByte,
        bMaskIsFloat: libc::c_int,
        pValidityMask: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALWarpCutlineMasker(
        pMaskFuncArg: *mut libc::c_void,
        nBandCount: libc::c_int,
        eType: GDALDataType::Type,
        nXOff: libc::c_int,
        nYOff: libc::c_int,
        nXSize: libc::c_int,
        nYSize: libc::c_int,
        arg1: *mut *mut GByte,
        bMaskIsFloat: libc::c_int,
        pValidityMask: *mut libc::c_void,
    ) -> CPLErr::Type;
}
#[doc = " Warp control options for use with GDALWarpOperation::Initialize()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALWarpOptions {
    pub papszWarpOptions: *mut *mut libc::c_char,
    #[doc = " In bytes, 0.0 for internal default"]
    pub dfWarpMemoryLimit: f64,
    #[doc = " Resampling algorithm to use"]
    pub eResampleAlg: GDALResampleAlg::Type,
    #[doc = " data type to use during warp operation, GDT_Unknown lets the algorithm\nselect the type"]
    pub eWorkingDataType: GDALDataType::Type,
    #[doc = " Source image dataset."]
    pub hSrcDS: GDALDatasetH,
    #[doc = " Destination image dataset - may be NULL if only using GDALWarpOperation::WarpRegionToBuffer()."]
    pub hDstDS: GDALDatasetH,
    #[doc = " Number of bands to process, may be 0 to select all bands."]
    pub nBandCount: libc::c_int,
    #[doc = " The band numbers for the source bands to process (1 based)"]
    pub panSrcBands: *mut libc::c_int,
    #[doc = " The band numbers for the destination bands to process (1 based)"]
    pub panDstBands: *mut libc::c_int,
    #[doc = " The source band so use as an alpha (transparency) value, 0=disabled"]
    pub nSrcAlphaBand: libc::c_int,
    #[doc = " The dest. band so use as an alpha (transparency) value, 0=disabled"]
    pub nDstAlphaBand: libc::c_int,
    #[doc = " The \"nodata\" value real component for each input band, if NULL there isn't one"]
    pub padfSrcNoDataReal: *mut f64,
    #[doc = " The \"nodata\" value imaginary component - may be NULL even if real\ncomponent is provided. This value is not used to flag invalid values.\nOnly the real component is used."]
    pub padfSrcNoDataImag: *mut f64,
    #[doc = " The \"nodata\" value real component for each output band, if NULL there isn't one"]
    pub padfDstNoDataReal: *mut f64,
    #[doc = " The \"nodata\" value imaginary component - may be NULL even if real\ncomponent is provided. Note that warp operations only use real component\nfor flagging invalid data."]
    pub padfDstNoDataImag: *mut f64,
    #[doc = " GDALProgressFunc() compatible progress reporting function, or NULL\nif there isn't one."]
    pub pfnProgress: GDALProgressFunc,
    #[doc = " Callback argument to be passed to pfnProgress."]
    pub pProgressArg: *mut libc::c_void,
    #[doc = " Type of spatial point transformer function"]
    pub pfnTransformer: GDALTransformerFunc,
    #[doc = " Handle to image transformer setup structure"]
    pub pTransformerArg: *mut libc::c_void,
    #[doc = " Unused. Must be NULL"]
    pub papfnSrcPerBandValidityMaskFunc: *mut GDALMaskFunc,
    #[doc = " Unused. Must be NULL"]
    pub papSrcPerBandValidityMaskFuncArg: *mut *mut libc::c_void,
    #[doc = " Unused. Must be NULL"]
    pub pfnSrcValidityMaskFunc: GDALMaskFunc,
    #[doc = " Unused. Must be NULL"]
    pub pSrcValidityMaskFuncArg: *mut libc::c_void,
    #[doc = " Unused. Must be NULL"]
    pub pfnSrcDensityMaskFunc: GDALMaskFunc,
    #[doc = " Unused. Must be NULL"]
    pub pSrcDensityMaskFuncArg: *mut libc::c_void,
    #[doc = " Unused. Must be NULL"]
    pub pfnDstDensityMaskFunc: GDALMaskFunc,
    #[doc = " Unused. Must be NULL"]
    pub pDstDensityMaskFuncArg: *mut libc::c_void,
    #[doc = " Unused. Must be NULL"]
    pub pfnDstValidityMaskFunc: GDALMaskFunc,
    #[doc = " Unused. Must be NULL"]
    pub pDstValidityMaskFuncArg: *mut libc::c_void,
    #[doc = " Unused. Must be NULL"]
    pub pfnPreWarpChunkProcessor: ::std::option::Option<
        unsafe extern "C" fn(pKern: *mut libc::c_void, pArg: *mut libc::c_void) -> CPLErr::Type,
    >,
    #[doc = " Unused. Must be NULL"]
    pub pPreWarpProcessorArg: *mut libc::c_void,
    #[doc = " Unused. Must be NULL"]
    pub pfnPostWarpChunkProcessor: ::std::option::Option<
        unsafe extern "C" fn(pKern: *mut libc::c_void, pArg: *mut libc::c_void) -> CPLErr::Type,
    >,
    #[doc = " Unused. Must be NULL"]
    pub pPostWarpProcessorArg: *mut libc::c_void,
    #[doc = " Optional OGRPolygonH for a masking cutline."]
    pub hCutline: *mut libc::c_void,
    #[doc = " Optional blending distance to apply across cutline in pixels, default is zero."]
    pub dfCutlineBlendDist: f64,
}
#[test]
fn bindgen_test_layout_GDALWarpOptions() {
    const UNINIT: ::std::mem::MaybeUninit<GDALWarpOptions> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GDALWarpOptions>(),
        264usize,
        concat!("Size of: ", stringify!(GDALWarpOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<GDALWarpOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(GDALWarpOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).papszWarpOptions) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(papszWarpOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dfWarpMemoryLimit) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(dfWarpMemoryLimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eResampleAlg) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(eResampleAlg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eWorkingDataType) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(eWorkingDataType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hSrcDS) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(hSrcDS)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hDstDS) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(hDstDS)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nBandCount) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(nBandCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).panSrcBands) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(panSrcBands)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).panDstBands) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(panDstBands)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nSrcAlphaBand) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(nSrcAlphaBand)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nDstAlphaBand) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(nDstAlphaBand)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padfSrcNoDataReal) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(padfSrcNoDataReal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padfSrcNoDataImag) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(padfSrcNoDataImag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padfDstNoDataReal) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(padfDstNoDataReal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padfDstNoDataImag) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(padfDstNoDataImag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pfnProgress) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(pfnProgress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pProgressArg) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(pProgressArg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pfnTransformer) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(pfnTransformer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pTransformerArg) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(pTransformerArg)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).papfnSrcPerBandValidityMaskFunc) as usize - ptr as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(papfnSrcPerBandValidityMaskFunc)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).papSrcPerBandValidityMaskFuncArg) as usize - ptr as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(papSrcPerBandValidityMaskFuncArg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pfnSrcValidityMaskFunc) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(pfnSrcValidityMaskFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pSrcValidityMaskFuncArg) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(pSrcValidityMaskFuncArg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pfnSrcDensityMaskFunc) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(pfnSrcDensityMaskFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pSrcDensityMaskFuncArg) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(pSrcDensityMaskFuncArg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pfnDstDensityMaskFunc) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(pfnDstDensityMaskFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pDstDensityMaskFuncArg) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(pDstDensityMaskFuncArg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pfnDstValidityMaskFunc) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(pfnDstValidityMaskFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pDstValidityMaskFuncArg) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(pDstValidityMaskFuncArg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pfnPreWarpChunkProcessor) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(pfnPreWarpChunkProcessor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pPreWarpProcessorArg) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(pPreWarpProcessorArg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pfnPostWarpChunkProcessor) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(pfnPostWarpChunkProcessor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pPostWarpProcessorArg) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(pPostWarpProcessorArg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hCutline) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(hCutline)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dfCutlineBlendDist) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(dfCutlineBlendDist)
        )
    );
}
extern "C" {
    pub fn GDALCreateWarpOptions() -> *mut GDALWarpOptions;
}
extern "C" {
    pub fn GDALDestroyWarpOptions(arg1: *mut GDALWarpOptions);
}
extern "C" {
    pub fn GDALCloneWarpOptions(arg1: *const GDALWarpOptions) -> *mut GDALWarpOptions;
}
extern "C" {
    pub fn GDALWarpInitDstNoDataReal(arg1: *mut GDALWarpOptions, dNoDataReal: f64);
}
extern "C" {
    pub fn GDALWarpInitSrcNoDataReal(arg1: *mut GDALWarpOptions, dNoDataReal: f64);
}
extern "C" {
    pub fn GDALWarpInitNoDataReal(arg1: *mut GDALWarpOptions, dNoDataReal: f64);
}
extern "C" {
    pub fn GDALWarpInitDstNoDataImag(arg1: *mut GDALWarpOptions, dNoDataImag: f64);
}
extern "C" {
    pub fn GDALWarpInitSrcNoDataImag(arg1: *mut GDALWarpOptions, dNoDataImag: f64);
}
extern "C" {
    pub fn GDALWarpResolveWorkingDataType(arg1: *mut GDALWarpOptions);
}
extern "C" {
    pub fn GDALWarpInitDefaultBandMapping(arg1: *mut GDALWarpOptions, nBandCount: libc::c_int);
}
extern "C" {
    #[doc = " @cond Doxygen_Suppress"]
    pub fn GDALSerializeWarpOptions(arg1: *const GDALWarpOptions) -> *mut CPLXMLNode;
}
extern "C" {
    pub fn GDALDeserializeWarpOptions(arg1: *mut CPLXMLNode) -> *mut GDALWarpOptions;
}
extern "C" {
    pub fn GDALReprojectImage(
        hSrcDS: GDALDatasetH,
        pszSrcWKT: *const libc::c_char,
        hDstDS: GDALDatasetH,
        pszDstWKT: *const libc::c_char,
        eResampleAlg: GDALResampleAlg::Type,
        dfWarpMemoryLimit: f64,
        dfMaxError: f64,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut libc::c_void,
        psOptions: *mut GDALWarpOptions,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALCreateAndReprojectImage(
        hSrcDS: GDALDatasetH,
        pszSrcWKT: *const libc::c_char,
        pszDstFilename: *const libc::c_char,
        pszDstWKT: *const libc::c_char,
        hDstDriver: GDALDriverH,
        papszCreateOptions: *mut *mut libc::c_char,
        eResampleAlg: GDALResampleAlg::Type,
        dfWarpMemoryLimit: f64,
        dfMaxError: f64,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut libc::c_void,
        psOptions: *mut GDALWarpOptions,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALAutoCreateWarpedVRT(
        hSrcDS: GDALDatasetH,
        pszSrcWKT: *const libc::c_char,
        pszDstWKT: *const libc::c_char,
        eResampleAlg: GDALResampleAlg::Type,
        dfMaxError: f64,
        psOptions: *const GDALWarpOptions,
    ) -> GDALDatasetH;
}
extern "C" {
    pub fn GDALAutoCreateWarpedVRTEx(
        hSrcDS: GDALDatasetH,
        pszSrcWKT: *const libc::c_char,
        pszDstWKT: *const libc::c_char,
        eResampleAlg: GDALResampleAlg::Type,
        dfMaxError: f64,
        psOptions: *const GDALWarpOptions,
        papszTransformerOptions: CSLConstList,
    ) -> GDALDatasetH;
}
extern "C" {
    pub fn GDALCreateWarpedVRT(
        hSrcDS: GDALDatasetH,
        nPixels: libc::c_int,
        nLines: libc::c_int,
        padfGeoTransform: *mut f64,
        psOptions: *mut GDALWarpOptions,
    ) -> GDALDatasetH;
}
extern "C" {
    pub fn GDALInitializeWarpedVRT(hDS: GDALDatasetH, psWO: *mut GDALWarpOptions) -> CPLErr::Type;
}
#[doc = " Opaque type representing a GDALWarpOperation object"]
pub type GDALWarpOperationH = *mut libc::c_void;
extern "C" {
    pub fn GDALCreateWarpOperation(arg1: *const GDALWarpOptions) -> GDALWarpOperationH;
}
extern "C" {
    pub fn GDALDestroyWarpOperation(arg1: GDALWarpOperationH);
}
extern "C" {
    pub fn GDALChunkAndWarpImage(
        arg1: GDALWarpOperationH,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: libc::c_int,
        arg5: libc::c_int,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALChunkAndWarpMulti(
        arg1: GDALWarpOperationH,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: libc::c_int,
        arg5: libc::c_int,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALWarpRegion(
        arg1: GDALWarpOperationH,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: libc::c_int,
        arg5: libc::c_int,
        arg6: libc::c_int,
        arg7: libc::c_int,
        arg8: libc::c_int,
        arg9: libc::c_int,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALWarpRegionToBuffer(
        arg1: GDALWarpOperationH,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: libc::c_int,
        arg5: libc::c_int,
        arg6: *mut libc::c_void,
        arg7: GDALDataType::Type,
        arg8: libc::c_int,
        arg9: libc::c_int,
        arg10: libc::c_int,
        arg11: libc::c_int,
    ) -> CPLErr::Type;
}
pub mod OGRErr {
    #[doc = " Type for a OGR error\n\n <div rustbindgen replaces=\"OGRErr\"></div>"]
    pub type Type = libc::c_uint;
    #[doc = " Success\n\n <div rustbindgen replaces=\"OGRERR_NONE\"></div>"]
    pub const OGRERR_NONE: Type = 0;
    #[doc = " Not enough data to deserialize\n\n <div rustbindgen replaces=\"OGRERR_NOT_ENOUGH_DATA\"></div>"]
    pub const OGRERR_NOT_ENOUGH_DATA: Type = 1;
    #[doc = " Not enough memory\n\n <div rustbindgen replaces=\"OGRERR_NOT_ENOUGH_MEMORY\"></div>"]
    pub const OGRERR_NOT_ENOUGH_MEMORY: Type = 2;
    #[doc = " Unsupported geometry type\n\n <div rustbindgen replaces=\"OGRERR_UNSUPPORTED_GEOMETRY_TYPE\"></div>"]
    pub const OGRERR_UNSUPPORTED_GEOMETRY_TYPE: Type = 3;
    #[doc = " Unsupported operation\n\n <div rustbindgen replaces=\"OGRERR_UNSUPPORTED_OPERATION\"></div>"]
    pub const OGRERR_UNSUPPORTED_OPERATION: Type = 4;
    #[doc = " Corrupt data\n\n <div rustbindgen replaces=\"OGRERR_CORRUPT_DATA\"></div>"]
    pub const OGRERR_CORRUPT_DATA: Type = 5;
    #[doc = " Failure\n\n <div rustbindgen replaces=\"OGRERR_FAILURE\"></div>"]
    pub const OGRERR_FAILURE: Type = 6;
    #[doc = " Unsupported SRS\n\n <div rustbindgen replaces=\"OGRERR_UNSUPPORTED_SRS\"></div>"]
    pub const OGRERR_UNSUPPORTED_SRS: Type = 7;
    #[doc = " Invalid handle\n\n <div rustbindgen replaces=\"INVALID_HANDLE\"></div>"]
    pub const INVALID_HANDLE: Type = 8;
    #[doc = " Non existing feature. Added in GDAL 2.0\n\n <div rustbindgen replaces=\"NON_EXISTING_FEATURE\"></div>"]
    pub const NON_EXISTING_FEATURE: Type = 9;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: libc::c_uint,
    pub fp_offset: libc::c_uint,
    pub overflow_arg_area: *mut libc::c_void,
    pub reg_save_area: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__va_list_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
